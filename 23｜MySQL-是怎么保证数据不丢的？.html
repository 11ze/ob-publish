<!DOCTYPE html>
<html><head><title>23｜MySQL 是怎么保证数据不丢的？</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="23｜MySQL 是怎么保证数据不丢的？"/><meta property="og:description" content="只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。 binlog 的写入机制 § 写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交时再把 binlog cache 写到 binlog 文件。 一个事务的 binlog 是要确保一次性写入，不能被打断 系统给 binlog cache 分配了一片内存，每个线程一个， 参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图所示。 图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。 图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。 write 和 fsync 的时机，是由参数 sync_binlog 控制的： sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync； sync_binlog=1 的时候，表示每次提交事务都会执行 fsync； sync_binlog=N(N&amp;gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。 redo log 的写入机制 § 都先写到 redo log buffer 不用每次生成后都直接持久化到磁盘 如果事务执行期间 MySQL 异常重启，这部分日志丢了，由于事务并没有提交，所以没损失 事务没提交，这时日志也有可能被持久化到磁盘 redo log 的存储状态 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。 没有提交的事务的 redo log 也会 另外两个会让没有提交的事务的 redo log 写入到磁盘的场景 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。 注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。 假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。 通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。 组提交机制 § 日志逻辑序列号（log sequence number，LSN） 单调递增，用来对应 redo log 的一个个写入点 每次写入长度为 length 的 redo log， LSN 的值就会加上 length。 LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log 一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。 trx1 先到达，会被选为 leader 开始写盘，因为组里有了三个事务，所以 LSN 变成了最大值 160 等到 trx1 返回时，所有 LSN 小于等于 160 的 redo log 都已经被持久化到磁盘，所以 trx2 和 trx3 可以直接返回 在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。 为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。 两阶段提交 两阶段提交细化 写 binlog 是分成两步的 先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件； 调用 fsync 持久化。 MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后 3 执行很快，所以 binlog 的组提交效果通常不如 redo log 的效果好 提升 binlog 组提交的效果 binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync; binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。 两个条件是 或 的关系 WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？ § redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快； 组提交机制可以大幅度降低磁盘的 IOPS 消耗。 MySQL 出现 IO 性能瓶颈的提升性能方法 § 设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。 这个方法基于“额外的故意等待”来实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。 将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。 ⚠️ 这样做的风险是，主机掉电时会丢 binlog 日志。 将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。 不建议设置为 0（只保存在内存中） 0 跟 2 的性能差不多，但 2 的风险更小 数据库的 crash-safe 的作用 § 如果客户端收到事务成功的消息，事务就一定持久化了； 双 1 配置时 如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了； 如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。 思考题 § 你的生产库设置的是「双 1」吗？ 如果平时是的话，你有在什么场景下改成过“非双 1”吗？你的这个操作又是基于什么决定的？ 业务高峰期 备库延迟 用备份恢复主库的副本，应用 binlog 的过程 批量导入数据的时候 我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？ 一般情况下，把生产库改成“非双 1 ”配置，是设置 innodb_flush_logs_at_trx_commit=2 sync_binlog=1000 评论区 § 看到的「binlog 的记录」是从 page cache 读，page cache 在操作系统文件系统上 ls 的结果也是 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？ binlog 存储是以 statement 或者 row 格式存储的，而 redo log 是以 page 页格式存储的。page 格式，天生就是共有的，而 row 格式，只跟当前事务相关 在这里联系到 binlog 的格式，statement 记录的是更新的 SQL，但是要写上下文，因此不能中断，不然同步到从库后从库无法恢复一样的数据内容 如果 sync_binlog = N｜binlog_group_commit_sync_no_delay_count = M｜binlog_group_commit_sync_delay = 很大值，这种情况 fsync 什么时候发生 sync_delay 和 sync_no_delay_count 的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入 sync_binlog 阶段。这时候如果判断 sync_binlog=0，就直接跳过，还是不调 fsync。 ."/><meta property="og:image" content="https://wangze.tech/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。 binlog 的写入机制 § 写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交时再把 binlog cache 写到 binlog 文件。 一个事务的 binlog 是要确保一次性写入，不能被打断 系统给 binlog cache 分配了一片内存，每个线程一个， 参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图所示。 图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。 图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。 write 和 fsync 的时机，是由参数 sync_binlog 控制的： sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync； sync_binlog=1 的时候，表示每次提交事务都会执行 fsync； sync_binlog=N(N&amp;gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。 redo log 的写入机制 § 都先写到 redo log buffer 不用每次生成后都直接持久化到磁盘 如果事务执行期间 MySQL 异常重启，这部分日志丢了，由于事务并没有提交，所以没损失 事务没提交，这时日志也有可能被持久化到磁盘 redo log 的存储状态 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。 没有提交的事务的 redo log 也会 另外两个会让没有提交的事务的 redo log 写入到磁盘的场景 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。 注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。 假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。 通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。 组提交机制 § 日志逻辑序列号（log sequence number，LSN） 单调递增，用来对应 redo log 的一个个写入点 每次写入长度为 length 的 redo log， LSN 的值就会加上 length。 LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log 一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。 trx1 先到达，会被选为 leader 开始写盘，因为组里有了三个事务，所以 LSN 变成了最大值 160 等到 trx1 返回时，所有 LSN 小于等于 160 的 redo log 都已经被持久化到磁盘，所以 trx2 和 trx3 可以直接返回 在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。 为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。 两阶段提交 两阶段提交细化 写 binlog 是分成两步的 先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件； 调用 fsync 持久化。 MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后 3 执行很快，所以 binlog 的组提交效果通常不如 redo log 的效果好 提升 binlog 组提交的效果 binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync; binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。 两个条件是 或 的关系 WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？ § redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快； 组提交机制可以大幅度降低磁盘的 IOPS 消耗。 MySQL 出现 IO 性能瓶颈的提升性能方法 § 设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。 这个方法基于“额外的故意等待”来实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。 将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。 ⚠️ 这样做的风险是，主机掉电时会丢 binlog 日志。 将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。 不建议设置为 0（只保存在内存中） 0 跟 2 的性能差不多，但 2 的风险更小 数据库的 crash-safe 的作用 § 如果客户端收到事务成功的消息，事务就一定持久化了； 双 1 配置时 如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了； 如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。 思考题 § 你的生产库设置的是「双 1」吗？ 如果平时是的话，你有在什么场景下改成过“非双 1”吗？你的这个操作又是基于什么决定的？ 业务高峰期 备库延迟 用备份恢复主库的副本，应用 binlog 的过程 批量导入数据的时候 我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？ 一般情况下，把生产库改成“非双 1 ”配置，是设置 innodb_flush_logs_at_trx_commit=2 sync_binlog=1000 评论区 § 看到的「binlog 的记录」是从 page cache 读，page cache 在操作系统文件系统上 ls 的结果也是 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？ binlog 存储是以 statement 或者 row 格式存储的，而 redo log 是以 page 页格式存储的。page 格式，天生就是共有的，而 row 格式，只跟当前事务相关 在这里联系到 binlog 的格式，statement 记录的是更新的 SQL，但是要写上下文，因此不能中断，不然同步到从库后从库无法恢复一样的数据内容 如果 sync_binlog = N｜binlog_group_commit_sync_no_delay_count = M｜binlog_group_commit_sync_delay = 很大值，这种情况 fsync 什么时候发生 sync_delay 和 sync_no_delay_count 的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入 sync_binlog 阶段。这时候如果判断 sync_binlog=0，就直接跳过，还是不调 fsync。 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`./static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="23｜MySQL-是怎么保证数据不丢的？"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href=".">🫧 11ze</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[]"><h1>Explorer</h1><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><li><a href="./00｜开篇词" data-for="00｜开篇词">00｜开篇词</a></li></li><li><li><a href="./01｜基础架构：一个键值数据库包含什么？" data-for="01｜基础架构：一个键值数据库包含什么？">01｜基础架构：一个键值数据库包含什么？</a></li></li><li><li><a href="./01｜基础架构：一条-SQL-查询语句是如何执行的？" data-for="01｜基础架构：一条-SQL-查询语句是如何执行的？">01｜基础架构：一条 SQL 查询语句是如何执行的？</a></li></li><li><li><a href="./02｜数据结构：快速的-Redis-有哪些慢操作？" data-for="02｜数据结构：快速的-Redis-有哪些慢操作？">02｜数据结构：快速的 Redis 有哪些慢操作？</a></li></li><li><li><a href="./02｜日志系统：一条-SQL-更新语句是如何执行的？" data-for="02｜日志系统：一条-SQL-更新语句是如何执行的？">02｜日志系统：一条 SQL 更新语句是如何执行的？</a></li></li><li><li><a href="./3-2-1-的有趣想法" data-for="3-2-1-的有趣想法">3-2-1 的有趣想法</a></li></li><li><li><a href="./03｜事务隔离：为什么你改了为还看不见？" data-for="03｜事务隔离：为什么你改了为还看不见？">03｜事务隔离：为什么你改了为还看不见？</a></li></li><li><li><a href="./03｜高性能-IO-模型：为什么单线程-Redis-那么快？" data-for="03｜高性能-IO-模型：为什么单线程-Redis-那么快？">03｜高性能 IO 模型：为什么单线程 Redis 那么快？</a></li></li><li><li><a href="./04｜AOF-日志：宕机了，Redis-如何避免数据丢失？" data-for="04｜AOF-日志：宕机了，Redis-如何避免数据丢失？">04｜AOF 日志：宕机了，Redis 如何避免数据丢失？</a></li></li><li><li><a href="./04｜深入浅出索引（上）" data-for="04｜深入浅出索引（上）">04｜深入浅出索引（上）</a></li></li><li><li><a href="./05｜内存快照：宕机后，Redis-如何实现快速恢复？" data-for="05｜内存快照：宕机后，Redis-如何实现快速恢复？">05｜内存快照：宕机后，Redis 如何实现快速恢复？</a></li></li><li><li><a href="./05｜深入浅出索引（下）" data-for="05｜深入浅出索引（下）">05｜深入浅出索引（下）</a></li></li><li><li><a href="./06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？" data-for="06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？">06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？</a></li></li><li><li><a href="./06｜数据同步：主从库如何实现数据一致？" data-for="06｜数据同步：主从库如何实现数据一致？">06｜数据同步：主从库如何实现数据一致？</a></li></li><li><li><a href="./07｜哨兵机制：主库挂了，如何不间断服务？" data-for="07｜哨兵机制：主库挂了，如何不间断服务？">07｜哨兵机制：主库挂了，如何不间断服务？</a></li></li><li><li><a href="./07｜行锁功过：怎么减少锁对性能的影响？" data-for="07｜行锁功过：怎么减少锁对性能的影响？">07｜行锁功过：怎么减少锁对性能的影响？</a></li></li><li><li><a href="./08｜事务到底是隔离的还是不隔离的？" data-for="08｜事务到底是隔离的还是不隔离的？">08｜事务到底是隔离的还是不隔离的？</a></li></li><li><li><a href="./08｜哨兵集群：哨兵挂了，主从库还能切换吗？" data-for="08｜哨兵集群：哨兵挂了，主从库还能切换吗？">08｜哨兵集群：哨兵挂了，主从库还能切换吗？</a></li></li><li><li><a href="./09｜切片集群：数据增多了，是该加内存还是加实例？" data-for="09｜切片集群：数据增多了，是该加内存还是加实例？">09｜切片集群：数据增多了，是该加内存还是加实例？</a></li></li><li><li><a href="./09｜普通索引和唯一索引，应该怎么选择？" data-for="09｜普通索引和唯一索引，应该怎么选择？">09｜普通索引和唯一索引，应该怎么选择？</a></li></li><li><li><a href="./10｜MySQL-为什么有时候会选错索引？" data-for="10｜MySQL-为什么有时候会选错索引？">10｜MySQL 为什么有时候会选错索引？</a></li></li><li><li><a href="./11｜“万金油”的-String，为什么不好用了？" data-for="11｜“万金油”的-String，为什么不好用了？">11｜“万金油”的 String，为什么不好用了？</a></li></li><li><li><a href="./11｜怎么给字符串字段加索引？" data-for="11｜怎么给字符串字段加索引？">11｜怎么给字符串字段加索引？</a></li></li><li><li><a href="./12｜为什么我的-MySQL-会“抖”一下？" data-for="12｜为什么我的-MySQL-会“抖”一下？">12｜为什么我的 MySQL 会“抖”一下？</a></li></li><li><li><a href="./12｜有一亿个-keys-要统计，应该用哪种集合？" data-for="12｜有一亿个-keys-要统计，应该用哪种集合？">12｜有一亿个 keys 要统计，应该用哪种集合？</a></li></li><li><li><a href="./13｜GEO-是什么？还可以定义新的数据类型吗？" data-for="13｜GEO-是什么？还可以定义新的数据类型吗？">13｜GEO 是什么？还可以定义新的数据类型吗？</a></li></li><li><li><a href="./13｜为什么表数据删掉一半，表文件大小不变？" data-for="13｜为什么表数据删掉一半，表文件大小不变？">13｜为什么表数据删掉一半，表文件大小不变？</a></li></li><li><li><a href="./14｜count(*)-这么慢，我该怎么办？" data-for="14｜count(*)-这么慢，我该怎么办？">14｜count(*) 这么慢，我该怎么办？</a></li></li><li><li><a href="./14｜如何在-Redis-中保存时间序列数据？" data-for="14｜如何在-Redis-中保存时间序列数据？">14｜如何在 Redis 中保存时间序列数据？</a></li></li><li><li><a href="./15｜消息队列的考验：Redis-有哪些解决方案？" data-for="15｜消息队列的考验：Redis-有哪些解决方案？">15｜消息队列的考验：Redis 有哪些解决方案？</a></li></li><li><li><a href="./15｜答疑文章（一）：日志和索引相关问题" data-for="15｜答疑文章（一）：日志和索引相关问题">15｜答疑文章（一）：日志和索引相关问题</a></li></li><li><li><a href="./16｜“order-by”是怎么工作的？" data-for="16｜“order-by”是怎么工作的？">16｜“order by”是怎么工作的？</a></li></li><li><li><a href="./16｜异步机制：如何避免单线程模型的阻塞？" data-for="16｜异步机制：如何避免单线程模型的阻塞？">16｜异步机制：如何避免单线程模型的阻塞？</a></li></li><li><li><a href="./17｜为什么-CPU-结构也会影响-Redis-的性能？" data-for="17｜为什么-CPU-结构也会影响-Redis-的性能？">17｜为什么 CPU 结构也会影响 Redis 的性能？</a></li></li><li><li><a href="./17｜如何正确地显示随机消息？" data-for="17｜如何正确地显示随机消息？">17｜如何正确地显示随机消息？</a></li></li><li><li><a href="./18｜为什么这些-SQL-语句逻辑相同，性能却差异巨大？" data-for="18｜为什么这些-SQL-语句逻辑相同，性能却差异巨大？">18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？</a></li></li><li><li><a href="./18｜波动的响应延迟：如何应对变慢的-Redis？（上）" data-for="18｜波动的响应延迟：如何应对变慢的-Redis？（上）">18｜波动的响应延迟：如何应对变慢的 Redis？（上）</a></li></li><li><li><a href="./19｜为什么我只查一行的语句，也执行这么慢？" data-for="19｜为什么我只查一行的语句，也执行这么慢？">19｜为什么我只查一行的语句，也执行这么慢？</a></li></li><li><li><a href="./19｜波动的响应延迟：如何应对变慢的-Redis？（下）" data-for="19｜波动的响应延迟：如何应对变慢的-Redis？（下）">19｜波动的响应延迟：如何应对变慢的 Redis？（下）</a></li></li><li><li><a href="./20｜删除数据后，为什么内存占用率还是很高？" data-for="20｜删除数据后，为什么内存占用率还是很高？">20｜删除数据后，为什么内存占用率还是很高？</a></li></li><li><li><a href="./20｜幻读是什么，幻读有什么问题？" data-for="20｜幻读是什么，幻读有什么问题？">20｜幻读是什么，幻读有什么问题？</a></li></li><li><li><a href="./21｜为什么我只改一行的语句，锁这么多？" data-for="21｜为什么我只改一行的语句，锁这么多？">21｜为什么我只改一行的语句，锁这么多？</a></li></li><li><li><a href="./21｜缓冲区：一个可能引发“惨案”的地方" data-for="21｜缓冲区：一个可能引发“惨案”的地方">21｜缓冲区：一个可能引发“惨案”的地方</a></li></li><li><li><a href="./22｜MySQL有哪些“饮鸩止渴”提高性能的方法？" data-for="22｜MySQL有哪些“饮鸩止渴”提高性能的方法？">22｜MySQL有哪些“饮鸩止渴”提高性能的方法？</a></li></li><li><li><a href="./22｜第-11～21-讲课后思考题答案及常见问题答疑" data-for="22｜第-11～21-讲课后思考题答案及常见问题答疑">22｜第 11～21 讲课后思考题答案及常见问题答疑</a></li></li><li><li><a href="./23｜MySQL-是怎么保证数据不丢的？" data-for="23｜MySQL-是怎么保证数据不丢的？">23｜MySQL 是怎么保证数据不丢的？</a></li></li><li><li><a href="./23｜旁路缓存：Redis-是如何工作的？" data-for="23｜旁路缓存：Redis-是如何工作的？">23｜旁路缓存：Redis 是如何工作的？</a></li></li><li><li><a href="./24｜MySQL-是怎么保证主备一致的？" data-for="24｜MySQL-是怎么保证主备一致的？">24｜MySQL 是怎么保证主备一致的？</a></li></li><li><li><a href="./24｜替换策略：缓存满了怎么办？" data-for="24｜替换策略：缓存满了怎么办？">24｜替换策略：缓存满了怎么办？</a></li></li><li><li><a href="./25｜MySQL-是怎么保证高可用的？" data-for="25｜MySQL-是怎么保证高可用的？">25｜MySQL 是怎么保证高可用的？</a></li></li><li><li><a href="./25｜缓存异常（上）：如何解决缓存和数据库的数据不一致问题？" data-for="25｜缓存异常（上）：如何解决缓存和数据库的数据不一致问题？">25｜缓存异常（上）：如何解决缓存和数据库的数据不一致问题？</a></li></li><li><li><a href="./26｜备库为什么会延迟好几个小时？" data-for="26｜备库为什么会延迟好几个小时？">26｜备库为什么会延迟好几个小时？</a></li></li><li><li><a href="./26｜缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？" data-for="26｜缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？">26｜缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？</a></li></li><li><li><a href="./27｜主库出问题了，从库怎么办？" data-for="27｜主库出问题了，从库怎么办？">27｜主库出问题了，从库怎么办？</a></li></li><li><li><a href="./27｜缓存被污染了，该怎么办？" data-for="27｜缓存被污染了，该怎么办？">27｜缓存被污染了，该怎么办？</a></li></li><li><li><a href="./28｜Pika：如何基于-SSD-实现大容量-Redis？" data-for="28｜Pika：如何基于-SSD-实现大容量-Redis？">28｜Pika：如何基于 SSD 实现大容量 Redis？</a></li></li><li><li><a href="./28｜读写分离有哪些坑？" data-for="28｜读写分离有哪些坑？">28｜读写分离有哪些坑？</a></li></li><li><li><a href="./29｜如何判断一个数据库是不是出问题了？" data-for="29｜如何判断一个数据库是不是出问题了？">29｜如何判断一个数据库是不是出问题了？</a></li></li><li><li><a href="./29｜无锁的原子操作：Redis-如何应对并发访问？" data-for="29｜无锁的原子操作：Redis-如何应对并发访问？">29｜无锁的原子操作：Redis 如何应对并发访问？</a></li></li><li><li><a href="./30｜如何使用-Redis-实现分布式锁？" data-for="30｜如何使用-Redis-实现分布式锁？">30｜如何使用 Redis 实现分布式锁？</a></li></li><li><li><a href="./30｜答疑文章（二）：用动态的观点看加锁" data-for="30｜答疑文章（二）：用动态的观点看加锁">30｜答疑文章（二）：用动态的观点看加锁</a></li></li><li><li><a href="./31｜事务机制｜Redis-能实现-ACID-属性吗？" data-for="31｜事务机制｜Redis-能实现-ACID-属性吗？">31｜事务机制｜Redis 能实现 ACID 属性吗？</a></li></li><li><li><a href="./31｜误删数据后除了跑路，还能怎么办？" data-for="31｜误删数据后除了跑路，还能怎么办？">31｜误删数据后除了跑路，还能怎么办？</a></li></li><li><li><a href="./32｜Redis-主从同步与故障切换，有哪些坑？" data-for="32｜Redis-主从同步与故障切换，有哪些坑？">32｜Redis 主从同步与故障切换，有哪些坑？</a></li></li><li><li><a href="./32｜为什么还有-kill-不掉的语句？" data-for="32｜为什么还有-kill-不掉的语句？">32｜为什么还有 kill 不掉的语句？</a></li></li><li><li><a href="./33｜我查这么多数据，会不会把数据库内存打爆？" data-for="33｜我查这么多数据，会不会把数据库内存打爆？">33｜我查这么多数据，会不会把数据库内存打爆？</a></li></li><li><li><a href="./33｜脑裂：一次奇怪的数据丢失" data-for="33｜脑裂：一次奇怪的数据丢失">33｜脑裂：一次奇怪的数据丢失</a></li></li><li><li><a href="./34｜到底可不可以使用-join-？" data-for="34｜到底可不可以使用-join-？">34｜到底可不可以使用 join ？</a></li></li><li><li><a href="./35｜Codis-VS-Redis-Cluster：我该选择哪一个集群方案？" data-for="35｜Codis-VS-Redis-Cluster：我该选择哪一个集群方案？">35｜Codis VS Redis Cluster：我该选择哪一个集群方案？</a></li></li><li><li><a href="./35｜join-语句怎么优化？" data-for="35｜join-语句怎么优化？">35｜join 语句怎么优化？</a></li></li><li><li><a href="./36｜Redis-支撑秒杀场景的关键技术和实践都有哪些？" data-for="36｜Redis-支撑秒杀场景的关键技术和实践都有哪些？">36｜Redis 支撑秒杀场景的关键技术和实践都有哪些？</a></li></li><li><li><a href="./36｜为什么临时表可以重名？" data-for="36｜为什么临时表可以重名？">36｜为什么临时表可以重名？</a></li></li><li><li><a href="./37｜什么时候会使用内部临时表？" data-for="37｜什么时候会使用内部临时表？">37｜什么时候会使用内部临时表？</a></li></li><li><li><a href="./37｜数据分布优化：如何应对数据倾斜？" data-for="37｜数据分布优化：如何应对数据倾斜？">37｜数据分布优化：如何应对数据倾斜？</a></li></li><li><li><a href="./38｜通信开销：限制-Redis-Cluster-规模的关键因素" data-for="38｜通信开销：限制-Redis-Cluster-规模的关键因素">38｜通信开销：限制 Redis Cluster 规模的关键因素</a></li></li><li><li><a href="./38｜都说-InnoDB-好，那还要不要使用-Memory-引擎？" data-for="38｜都说-InnoDB-好，那还要不要使用-Memory-引擎？">38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？</a></li></li><li><li><a href="./39｜Redis-6.0-的新特性：多线程、客户端缓存与安全" data-for="39｜Redis-6.0-的新特性：多线程、客户端缓存与安全">39｜Redis 6.0 的新特性：多线程、客户端缓存与安全</a></li></li><li><li><a href="./39｜自增主键为什么不是连续的？" data-for="39｜自增主键为什么不是连续的？">39｜自增主键为什么不是连续的？</a></li></li><li><li><a href="./40｜insert-语句的锁为什么这么多？" data-for="40｜insert-语句的锁为什么这么多？">40｜insert 语句的锁为什么这么多？</a></li></li><li><li><a href="./40｜Redis-的下一步：基于-NVM-内存的实践" data-for="40｜Redis-的下一步：基于-NVM-内存的实践">40｜Redis 的下一步：基于 NVM 内存的实践</a></li></li><li><li><a href="./41｜怎么最快地复制一张表？" data-for="41｜怎么最快地复制一张表？">41｜怎么最快地复制一张表？</a></li></li><li><li><a href="./41｜第-35～40-讲课后思考题答案及常见问题答疑" data-for="41｜第-35～40-讲课后思考题答案及常见问题答疑">41｜第 35～40 讲课后思考题答案及常见问题答疑</a></li></li><li><li><a href="./42｜grant-之后要跟着-flush-privileges-吗？" data-for="42｜grant-之后要跟着-flush-privileges-吗？">42｜grant 之后要跟着 flush privileges 吗？</a></li></li><li><li><a href="./43｜要不要使用分区表？" data-for="43｜要不要使用分区表？">43｜要不要使用分区表？</a></li></li><li><li><a href="./44｜答疑文章（三）：说一说这些好问题" data-for="44｜答疑文章（三）：说一说这些好问题">44｜答疑文章（三）：说一说这些好问题</a></li></li><li><li><a href="./45｜自增-id-用完怎么办？" data-for="45｜自增-id-用完怎么办？">45｜自增 id 用完怎么办？</a></li></li><li><li><a href="./About-Atlas" data-for="About-Atlas">About Atlas</a></li></li><li><li><a href="./Capslock" data-for="Capslock">Capslock</a></li></li><li><li><a href="./Crontab-执行提示没有权限" data-for="Crontab-执行提示没有权限">Crontab 执行提示没有权限</a></li></li><li><li><a href="./Docker" data-for="Docker">Docker</a></li></li><li><li><a href="./Egg.js-手动热更新" data-for="Egg.js-手动热更新">Egg.js 手动热更新</a></li></li><li><li><a href="./GitHub-加速访问" data-for="GitHub-加速访问">GitHub 加速访问</a></li></li><li><li><a href="./iCloud-不同步指定文件" data-for="iCloud-不同步指定文件">iCloud 不同步指定文件</a></li></li><li><li><a href="./iCloud-同步卡住" data-for="iCloud-同步卡住">iCloud 同步卡住</a></li></li><li><li><a href="./Laravel-Pint-使用" data-for="Laravel-Pint-使用">Laravel Pint 使用</a></li></li><li><li><a href="./Linux-安装-oh-my-zsh" data-for="Linux-安装-oh-my-zsh">Linux 安装 oh-my-zsh</a></li></li><li><li><a href="./Mac-应用已损坏" data-for="Mac-应用已损坏">Mac 应用已损坏</a></li></li><li><li><a href="./MySQL-实战-45-讲" data-for="MySQL-实战-45-讲">MySQL 实战 45 讲</a></li></li><li><li><a href="./Obsidian" data-for="Obsidian">Obsidian</a></li></li><li><li><a href="./Obsidian-插件" data-for="Obsidian-插件">Obsidian 插件</a></li></li><li><li><a href="./Oh-My-Zsh" data-for="Oh-My-Zsh">Oh My Zsh</a></li></li><li><li><a href="./PHP" data-for="PHP">PHP</a></li></li><li><li><a href="./PHP-开发设置" data-for="PHP-开发设置">PHP 开发设置</a></li></li><li><li><a href="./PHP-测试" data-for="PHP-测试">PHP 测试</a></li></li><li><li><a href="./PHP-错误码设计" data-for="PHP-错误码设计">PHP 错误码设计</a></li></li><li><li><a href="./PHP-FPM-配置" data-for="PHP-FPM-配置">PHP-FPM 配置</a></li></li><li><li><a href="./Rate-Limit" data-for="Rate-Limit">Rate Limit</a></li></li><li><li><a href="./README" data-for="README">README</a></li></li><li><li><a href="./Redis-学习路径" data-for="Redis-学习路径">Redis 学习路径</a></li></li><li><li><a href="./Redis-客户端如何与服务端交换命令和数据？" data-for="Redis-客户端如何与服务端交换命令和数据？">Redis 客户端如何与服务端交换命令和数据？</a></li></li><li><li><a href="./Redis-有哪些好用的运维工具？" data-for="Redis-有哪些好用的运维工具？">Redis 有哪些好用的运维工具？</a></li></li><li><li><a href="./Redis-核心技术与实战" data-for="Redis-核心技术与实战">Redis 核心技术与实战</a></li></li><li><li><a href="./Redis-的使用规范小建议" data-for="Redis-的使用规范小建议">Redis 的使用规范小建议</a></li></li><li><li><a href="./Think-in-English" data-for="Think-in-English">Think in English</a></li></li><li><li><a href="./Tips" data-for="Tips">Tips</a></li></li><li><li><a href="./Vault" data-for="Vault">Vault</a></li></li><li><li><a href="./Docker-不常见问题" data-for="Docker-不常见问题">不常见问题</a></li></li><li><li><a href="./从微博的-Redis-实践中，我们可以学到哪些经验？" data-for="从微博的-Redis-实践中，我们可以学到哪些经验？">从微博的 Redis 实践中，我们可以学到哪些经验？</a></li></li><li><li><a href="./发布方案" data-for="发布方案">发布方案</a></li></li><li><li><a href="./同步方案" data-for="同步方案">同步方案</a></li></li><li><li><a href="./学习方法" data-for="学习方法">学习方法</a></li></li><li><li><a href="./常见错误" data-for="常见错误">常见错误</a></li></li><li><li><a href="./开发环境" data-for="开发环境">开发环境</a></li></li><li><li><a href="./抢红包系统" data-for="抢红包系统">抢红包系统</a></li></li><li><li><a href="./换新设备" data-for="换新设备">换新设备</a></li></li><li><li><a href="./搭建数字花园" data-for="搭建数字花园">搭建数字花园</a></li></li><li><li><a href="./支付技术方案" data-for="支付技术方案">支付技术方案</a></li></li><li><li><a href="./收藏文章" data-for="收藏文章">收藏文章</a></li></li><li><li><a href="./本库自动提交到-GitHub" data-for="本库自动提交到-GitHub">本库自动提交到 GitHub</a></li></li><li><li><a href="./油猴脚本" data-for="油猴脚本">油猴脚本</a></li></li><li><li><a href="./添加评论区" data-for="添加评论区">添加评论区</a></li></li><li><li><a href="./特殊字符" data-for="特殊字符">特殊字符</a></li></li><li><li><a href="./秒杀系统" data-for="秒杀系统">秒杀系统</a></li></li><li><li><a href="./发布笔记-404" data-for="发布笔记-404">笔记 404</a></li></li><li><li><a href="./经典的-Redis-学习资料" data-for="经典的-Redis-学习资料">经典的 Redis 学习资料</a></li></li><li><li><a href="./背单词" data-for="背单词">背单词</a></li></li><li><li><a href="./英语" data-for="英语">英语</a></li></li><li><li><a href="./配置图床" data-for="配置图床">配置图床</a></li></li><li><li><a href="./配置自定义域名" data-for="配置自定义域名">配置自定义域名</a></li></li><li><li><a href="./问题合集" data-for="问题合集">问题合集</a></li></li></ul></div></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container " aria-label="breadcrumbs"><div class="breadcrumb-element"><a href=".">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>23｜MySQL 是怎么保证数据不丢的？</a></div></nav><h1 class="article-title ">23｜MySQL 是怎么保证数据不丢的？</h1><p class="content-meta ">Aug 22, 2023, 11 min read</p><ul class="tags "><li><a href="./tags/mysql" class="internal tag-link">#mysql</a></li></ul></div></div><article class="popover-hint"><p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p>
<h2 id="binlog-的写入机制">binlog 的写入机制<a aria-hidden="true" tabindex="-1" href="#binlog-的写入机制" class="internal"> §</a></h2>
<ul>
<li>
<p>写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交时再把 binlog cache 写到 binlog 文件。</p>
<ul>
<li>一个事务的 binlog 是要确保一次性写入，不能被打断</li>
<li>系统给 binlog cache 分配了一片内存，每个线程一个，
<ul>
<li>参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</li>
</ul>
</li>
<li>事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图所示。
<ul>
<li>
<p><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-1.png" alt="image.png"/></p>
</li>
<li>
<p>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</p>
</li>
<li>
<p>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。</p>
</li>
<li>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ul>
<li>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
</ol>
</li>
<li>
<ol start="2">
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
</ol>
</li>
<li>
<ol start="3">
<li>
<p>sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
</li>
</ol>
<ul>
<li>如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="redo-log-的写入机制">redo log 的写入机制<a aria-hidden="true" tabindex="-1" href="#redo-log-的写入机制" class="internal"> §</a></h2>
<ul>
<li>
<p>都先写到 redo log buffer</p>
<ul>
<li>不用每次生成后都直接持久化到磁盘
<ul>
<li>如果事务执行期间 MySQL 异常重启，这部分日志丢了，由于事务并没有提交，所以没损失</li>
</ul>
</li>
<li>事务没提交，这时日志也有可能被持久化到磁盘</li>
</ul>
</li>
<li>
<p>redo log 的存储状态</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-2.png" alt="image.png"/></li>
</ul>
</li>
<li>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数</p>
<ul>
<li>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
</ol>
</li>
<li>
<ol start="2">
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
</ol>
</li>
<li>
<ol start="3">
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<ul>
<li>没有提交的事务的 redo log 也会</li>
</ul>
</li>
<li>
<p>另外两个会让没有提交的事务的 redo log 写入到磁盘的场景</p>
<ul>
<li>
<ol>
<li>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</li>
</ol>
<ul>
<li>注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</li>
</ul>
</li>
<li>
<ol start="2">
<li>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</li>
</ol>
<ul>
<li>假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
</li>
</ul>
<h2 id="组提交机制">组提交机制<a aria-hidden="true" tabindex="-1" href="#组提交机制" class="internal"> §</a></h2>
<ul>
<li>
<p>日志逻辑序列号（log sequence number，LSN）</p>
<ul>
<li>单调递增，用来对应 redo log 的一个个写入点</li>
<li>每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</li>
<li>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log</li>
</ul>
</li>
<li>
<p>一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p>
<ul>
<li>
<p><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-3.png" alt="image.png"/></p>
</li>
<li>
<p>trx1 先到达，会被选为 leader</p>
</li>
<li>
<p>开始写盘，因为组里有了三个事务，所以 LSN 变成了最大值 160</p>
</li>
<li>
<p>等到 trx1 返回时，所有 LSN 小于等于 160 的 redo log 都已经被持久化到磁盘，所以 trx2 和 trx3 可以直接返回</p>
</li>
</ul>
</li>
<li>
<p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。</p>
</li>
<li>
<p>为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。</p>
<ul>
<li>
<p>两阶段提交</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-4.png" alt="image.png"/></li>
</ul>
</li>
<li>
<p>两阶段提交细化</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-5.png" alt="image.png"/></li>
</ul>
</li>
<li>
<p>写 binlog 是分成两步的</p>
<ul>
<li>
<ol>
<li>先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件；</li>
</ol>
</li>
<li>
<ol start="2">
<li>调用 fsync 持久化。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后</p>
</li>
<li>
<p>3 执行很快，所以 binlog 的组提交效果通常不如 redo log 的效果好</p>
</li>
</ul>
</li>
<li>
<p>提升 binlog 组提交的效果</p>
<ul>
<li>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
</ol>
</li>
<li>
<ol start="2">
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
</li>
<li>两个条件是 或 的关系</li>
</ul>
</li>
</ul>
<h2 id="wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少">WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？<a aria-hidden="true" tabindex="-1" href="#wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少" class="internal"> §</a></h2>
<ul>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制可以大幅度降低磁盘的 IOPS 消耗。</li>
</ul>
<h2 id="mysql-出现-io-性能瓶颈的提升性能方法">MySQL 出现 IO 性能瓶颈的提升性能方法<a aria-hidden="true" tabindex="-1" href="#mysql-出现-io-性能瓶颈的提升性能方法" class="internal"> §</a></h2>
<ul>
<li>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。</li>
</ol>
<ul>
<li>这个方法基于“额外的故意等待”来实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
</ul>
</li>
<li>
<ol start="2">
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。</li>
</ol>
<ul>
<li>⚠️ 这样做的风险是，主机掉电时会丢 binlog 日志。</li>
</ul>
</li>
<li>
<ol start="3">
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
<ul>
<li>不建议设置为 0（只保存在内存中）</li>
<li>0 跟 2 的性能差不多，但 2 的风险更小</li>
</ul>
</li>
</ul>
<h2 id="数据库的-crash-safe-的作用">数据库的 crash-safe 的作用<a aria-hidden="true" tabindex="-1" href="#数据库的-crash-safe-的作用" class="internal"> §</a></h2>
<ul>
<li>
<ol>
<li>如果客户端收到事务成功的消息，事务就一定持久化了；</li>
</ol>
<ul>
<li>双 1 配置时</li>
</ul>
</li>
<li>
<ol start="2">
<li>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。</li>
</ol>
</li>
</ul>
<h2 id="思考题">思考题<a aria-hidden="true" tabindex="-1" href="#思考题" class="internal"> §</a></h2>
<ul>
<li>
<p>你的生产库设置的是「双 1」吗？ 如果平时是的话，你有在什么场景下改成过“非双 1”吗？你的这个操作又是基于什么决定的？</p>
<ul>
<li>
<ol>
<li>业务高峰期</li>
</ol>
</li>
<li>
<ol start="2">
<li>备库延迟</li>
</ol>
</li>
<li>
<ol start="3">
<li>用备份恢复主库的副本，应用 binlog 的过程</li>
</ol>
</li>
<li>
<ol start="4">
<li>批量导入数据的时候</li>
</ol>
</li>
</ul>
</li>
<li>
<p>我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？</p>
</li>
<li>
<p>一般情况下，把生产库改成“非双 1 ”配置，是设置</p>
<ul>
<li><code>innodb_flush_logs_at_trx_commit=2</code></li>
<li><code>sync_binlog=1000</code></li>
</ul>
</li>
</ul>
<h2 id="评论区">评论区<a aria-hidden="true" tabindex="-1" href="#评论区" class="internal"> §</a></h2>
<ul>
<li>
<p>看到的「binlog 的记录」是从 page cache 读，page cache 在操作系统文件系统上</p>
<ul>
<li>ls 的结果也是</li>
</ul>
</li>
<li>
<p>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</p>
<ul>
<li>binlog 存储是以 statement 或者 row 格式存储的，而 redo log 是以 page 页格式存储的。page 格式，天生就是共有的，而 row 格式，只跟当前事务相关</li>
<li>在这里联系到 binlog 的格式，statement 记录的是更新的 SQL，但是要写上下文，因此不能中断，不然同步到从库后从库无法恢复一样的数据内容</li>
</ul>
</li>
<li>
<p>如果 <code>sync_binlog = N｜binlog_group_commit_sync_no_delay_count = M｜binlog_group_commit_sync_delay = 很大值</code>，这种情况 fsync 什么时候发生</p>
<ul>
<li>sync_delay 和 sync_no_delay_count 的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入 sync_binlog 阶段。这时候如果判断 sync_binlog=0，就直接跳过，还是不调 fsync。</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#binlog-的写入机制" data-for="binlog-的写入机制">binlog 的写入机制</a></li><li class="depth-0"><a href="#redo-log-的写入机制" data-for="redo-log-的写入机制">redo log 的写入机制</a></li><li class="depth-0"><a href="#组提交机制" data-for="组提交机制">组提交机制</a></li><li class="depth-0"><a href="#wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少" data-for="wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少">WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？</a></li><li class="depth-0"><a href="#mysql-出现-io-性能瓶颈的提升性能方法" data-for="mysql-出现-io-性能瓶颈的提升性能方法">MySQL 出现 IO 性能瓶颈的提升性能方法</a></li><li class="depth-0"><a href="#数据库的-crash-safe-的作用" data-for="数据库的-crash-safe-的作用">数据库的 crash-safe 的作用</a></li><li class="depth-0"><a href="#思考题" data-for="思考题">思考题</a></li><li class="depth-0"><a href="#评论区" data-for="评论区">评论区</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="./MySQL-实战-45-讲" class="internal">MySQL 实战 45 讲</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.1</a>, © 2023</p><ul><li><a href="https://github.com/11ze/ob-publish">GitHub</a></li><li><a href="https://twitter.com/11ze4">Twitter</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-SZZLS6FREP" type="application/javascript"></script><script src="./postscript.js" type="module"></script></html>