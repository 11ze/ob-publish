<!DOCTYPE html>
<html><head><title>23｜MySQL 是怎么保证数据不丢的？</title><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="23｜MySQL 是怎么保证数据不丢的？"/><meta property="og:description" content="只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。 binlog 的写入机制 § 写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交时再把 binlog cache 写到 binlog 文件。 一个事务的 binlog 是要确保一次性写入，不能被打断 系统给 binlog cache 分配了一片内存，每个线程一个， 参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图所示。 图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。 图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。 write 和 fsync 的时机，是由参数 sync_binlog 控制的： sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync； sync_binlog=1 的时候，表示每次提交事务都会执行 fsync； sync_binlog=N(N&amp;gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。 redo log 的写入机制 § 都先写到 redo log buffer 不用每次生成后都直接持久化到磁盘 如果事务执行期间 MySQL 异常重启，这部分日志丢了，由于事务并没有提交，所以没损失 事务没提交，这时日志也有可能被持久化到磁盘 redo log 的存储状态 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。 没有提交的事务的 redo log 也会 另外两个会让没有提交的事务的 redo log 写入到磁盘的场景 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。 注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。 假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。 通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。 组提交机制 § 日志逻辑序列号（log sequence number，LSN） 单调递增，用来对应 redo log 的一个个写入点 每次写入长度为 length 的 redo log， LSN 的值就会加上 length。 LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log 一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。 trx1 先到达，会被选为 leader 开始写盘，因为组里有了三个事务，所以 LSN 变成了最大值 160 等到 trx1 返回时，所有 LSN 小于等于 160 的 redo log 都已经被持久化到磁盘，所以 trx2 和 trx3 可以直接返回 在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。 为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。 两阶段提交 两阶段提交细化 写 binlog 是分成两步的 先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件； 调用 fsync 持久化。 MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后 3 执行很快，所以 binlog 的组提交效果通常不如 redo log 的效果好 提升 binlog 组提交的效果 binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync; binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。 两个条件是 或 的关系 WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？ § redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快； 组提交机制可以大幅度降低磁盘的 IOPS 消耗。 MySQL 出现 IO 性能瓶颈的提升性能方法 § 设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。 这个方法基于“额外的故意等待”来实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。 将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。 ⚠️ 这样做的风险是，主机掉电时会丢 binlog 日志。 将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。 不建议设置为 0（只保存在内存中） 0 跟 2 的性能差不多，但 2 的风险更小 数据库的 crash-safe 的作用 § 如果客户端收到事务成功的消息，事务就一定持久化了； 双 1 配置时 如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了； 如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。 思考题 § 你的生产库设置的是「双 1」吗？ 如果平时是的话，你有在什么场景下改成过“非双 1”吗？你的这个操作又是基于什么决定的？ 业务高峰期 备库延迟 用备份恢复主库的副本，应用 binlog 的过程 批量导入数据的时候 我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？ 一般情况下，把生产库改成“非双 1 ”配置，是设置 innodb_flush_logs_at_trx_commit=2 sync_binlog=1000 评论区 § 看到的「binlog 的记录」是从 page cache 读，page cache 在操作系统文件系统上 ls 的结果也是 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？ binlog 存储是以 statement 或者 row 格式存储的，而 redo log 是以 page 页格式存储的。page 格式，天生就是共有的，而 row 格式，只跟当前事务相关 在这里联系到 binlog 的格式，statement 记录的是更新的 SQL，但是要写上下文，因此不能中断，不然同步到从库后从库无法恢复一样的数据内容 如果 sync_binlog = N｜binlog_group_commit_sync_no_delay_count = M｜binlog_group_commit_sync_delay = 很大值，这种情况 fsync 什么时候发生 sync_delay 和 sync_no_delay_count 的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入 sync_binlog 阶段。这时候如果判断 sync_binlog=0，就直接跳过，还是不调 fsync。 ."/><meta property="og:image" content="https://wangze.tech/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。 binlog 的写入机制 § 写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交时再把 binlog cache 写到 binlog 文件。 一个事务的 binlog 是要确保一次性写入，不能被打断 系统给 binlog cache 分配了一片内存，每个线程一个， 参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图所示。 图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。 图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。 write 和 fsync 的时机，是由参数 sync_binlog 控制的： sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync； sync_binlog=1 的时候，表示每次提交事务都会执行 fsync； sync_binlog=N(N&amp;gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。 redo log 的写入机制 § 都先写到 redo log buffer 不用每次生成后都直接持久化到磁盘 如果事务执行期间 MySQL 异常重启，这部分日志丢了，由于事务并没有提交，所以没损失 事务没提交，这时日志也有可能被持久化到磁盘 redo log 的存储状态 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。 没有提交的事务的 redo log 也会 另外两个会让没有提交的事务的 redo log 写入到磁盘的场景 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。 注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。 假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。 通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。 组提交机制 § 日志逻辑序列号（log sequence number，LSN） 单调递增，用来对应 redo log 的一个个写入点 每次写入长度为 length 的 redo log， LSN 的值就会加上 length。 LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log 一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。 trx1 先到达，会被选为 leader 开始写盘，因为组里有了三个事务，所以 LSN 变成了最大值 160 等到 trx1 返回时，所有 LSN 小于等于 160 的 redo log 都已经被持久化到磁盘，所以 trx2 和 trx3 可以直接返回 在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。 为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。 两阶段提交 两阶段提交细化 写 binlog 是分成两步的 先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件； 调用 fsync 持久化。 MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后 3 执行很快，所以 binlog 的组提交效果通常不如 redo log 的效果好 提升 binlog 组提交的效果 binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync; binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。 两个条件是 或 的关系 WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？ § redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快； 组提交机制可以大幅度降低磁盘的 IOPS 消耗。 MySQL 出现 IO 性能瓶颈的提升性能方法 § 设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。 这个方法基于“额外的故意等待”来实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。 将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。 ⚠️ 这样做的风险是，主机掉电时会丢 binlog 日志。 将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。 不建议设置为 0（只保存在内存中） 0 跟 2 的性能差不多，但 2 的风险更小 数据库的 crash-safe 的作用 § 如果客户端收到事务成功的消息，事务就一定持久化了； 双 1 配置时 如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了； 如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。 思考题 § 你的生产库设置的是「双 1」吗？ 如果平时是的话，你有在什么场景下改成过“非双 1”吗？你的这个操作又是基于什么决定的？ 业务高峰期 备库延迟 用备份恢复主库的副本，应用 binlog 的过程 批量导入数据的时候 我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？ 一般情况下，把生产库改成“非双 1 ”配置，是设置 innodb_flush_logs_at_trx_commit=2 sync_binlog=1000 评论区 § 看到的「binlog 的记录」是从 page cache 读，page cache 在操作系统文件系统上 ls 的结果也是 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？ binlog 存储是以 statement 或者 row 格式存储的，而 redo log 是以 page 页格式存储的。page 格式，天生就是共有的，而 row 格式，只跟当前事务相关 在这里联系到 binlog 的格式，statement 记录的是更新的 SQL，但是要写上下文，因此不能中断，不然同步到从库后从库无法恢复一样的数据内容 如果 sync_binlog = N｜binlog_group_commit_sync_no_delay_count = M｜binlog_group_commit_sync_delay = 很大值，这种情况 fsync 什么时候发生 sync_delay 和 sync_no_delay_count 的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入 sync_binlog 阶段。这时候如果判断 sync_binlog=0，就直接跳过，还是不调 fsync。 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="23｜MySQL-是怎么保证数据不丢的？"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href=".">🫧 11ze</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#binlog-的写入机制" data-for="binlog-的写入机制">binlog 的写入机制</a></li><li class="depth-0"><a href="#redo-log-的写入机制" data-for="redo-log-的写入机制">redo log 的写入机制</a></li><li class="depth-0"><a href="#组提交机制" data-for="组提交机制">组提交机制</a></li><li class="depth-0"><a href="#wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少" data-for="wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少">WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？</a></li><li class="depth-0"><a href="#mysql-出现-io-性能瓶颈的提升性能方法" data-for="mysql-出现-io-性能瓶颈的提升性能方法">MySQL 出现 IO 性能瓶颈的提升性能方法</a></li><li class="depth-0"><a href="#数据库的-crash-safe-的作用" data-for="数据库的-crash-safe-的作用">数据库的 crash-safe 的作用</a></li><li class="depth-0"><a href="#思考题" data-for="思考题">思考题</a></li><li class="depth-0"><a href="#评论区" data-for="评论区">评论区</a></li></ul></div></div><div class="recent-notes desktop-only"><h3>Recent Notes</h3><ul class="recent-ul"><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./Capslock" class="internal">Capslock</a></h3></div><p class="meta">Jan 12, 2024</p><ul class="tags"><li><a class="internal tag-link" href="./tags/软件">#软件</a></li><li><a class="internal tag-link" href="./tags/工具">#工具</a></li><li><a class="internal tag-link" href="./tags/Mac">#Mac</a></li></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./Crontab-执行提示没有权限" class="internal">Crontab 执行提示没有权限</a></h3></div><p class="meta">Jan 12, 2024</p><ul class="tags"><li><a class="internal tag-link" href="./tags/Linux">#Linux</a></li><li><a class="internal tag-link" href="./tags/自动化">#自动化</a></li></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./Linux-安装-oh-my-zsh" class="internal">Linux 安装 oh-my-zsh</a></h3></div><p class="meta">Jan 12, 2024</p><ul class="tags"><li><a class="internal tag-link" href="./tags/Linux">#Linux</a></li><li><a class="internal tag-link" href="./tags/zsh">#zsh</a></li></ul></div></li></ul></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">23｜MySQL 是怎么保证数据不丢的？</h1><p class="content-meta ">Jan 12, 2024, 11 min read</p><ul class="tags "><li><a href="./tags/MySQL" class="internal tag-link">#MySQL</a></li></ul></div></div><article class="popover-hint"><p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p>
<h2 id="binlog-的写入机制">binlog 的写入机制<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#binlog-的写入机制" class="internal alias"> §</a></h2>
<ul>
<li>
<p>写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交时再把 binlog cache 写到 binlog 文件。</p>
<ul>
<li>一个事务的 binlog 是要确保一次性写入，不能被打断</li>
<li>系统给 binlog cache 分配了一片内存，每个线程一个，
<ul>
<li>参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</li>
</ul>
</li>
<li>事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图所示。
<ul>
<li>
<p><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-1.png" alt="image.png"/></p>
</li>
<li>
<p>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</p>
</li>
<li>
<p>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。</p>
</li>
<li>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ul>
<li>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
</ol>
</li>
<li>
<ol start="2">
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
</ol>
</li>
<li>
<ol start="3">
<li>
<p>sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
</li>
</ol>
<ul>
<li>如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="redo-log-的写入机制">redo log 的写入机制<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#redo-log-的写入机制" class="internal alias"> §</a></h2>
<ul>
<li>
<p>都先写到 redo log buffer</p>
<ul>
<li>不用每次生成后都直接持久化到磁盘
<ul>
<li>如果事务执行期间 MySQL 异常重启，这部分日志丢了，由于事务并没有提交，所以没损失</li>
</ul>
</li>
<li>事务没提交，这时日志也有可能被持久化到磁盘</li>
</ul>
</li>
<li>
<p>redo log 的存储状态</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-2.png" alt="image.png"/></li>
</ul>
</li>
<li>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数</p>
<ul>
<li>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
</ol>
</li>
<li>
<ol start="2">
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
</ol>
</li>
<li>
<ol start="3">
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<ul>
<li>没有提交的事务的 redo log 也会</li>
</ul>
</li>
<li>
<p>另外两个会让没有提交的事务的 redo log 写入到磁盘的场景</p>
<ul>
<li>
<ol>
<li>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</li>
</ol>
<ul>
<li>注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</li>
</ul>
</li>
<li>
<ol start="2">
<li>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</li>
</ol>
<ul>
<li>假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
</li>
</ul>
<h2 id="组提交机制">组提交机制<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#组提交机制" class="internal alias"> §</a></h2>
<ul>
<li>
<p>日志逻辑序列号（log sequence number，LSN）</p>
<ul>
<li>单调递增，用来对应 redo log 的一个个写入点</li>
<li>每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</li>
<li>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log</li>
</ul>
</li>
<li>
<p>一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p>
<ul>
<li>
<p><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-3.png" alt="image.png"/></p>
</li>
<li>
<p>trx1 先到达，会被选为 leader</p>
</li>
<li>
<p>开始写盘，因为组里有了三个事务，所以 LSN 变成了最大值 160</p>
</li>
<li>
<p>等到 trx1 返回时，所有 LSN 小于等于 160 的 redo log 都已经被持久化到磁盘，所以 trx2 和 trx3 可以直接返回</p>
</li>
</ul>
</li>
<li>
<p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。</p>
</li>
<li>
<p>为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。</p>
<ul>
<li>
<p>两阶段提交</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-4.png" alt="image.png"/></li>
</ul>
</li>
<li>
<p>两阶段提交细化</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-23-5.png" alt="image.png"/></li>
</ul>
</li>
<li>
<p>写 binlog 是分成两步的</p>
<ul>
<li>
<ol>
<li>先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件；</li>
</ol>
</li>
<li>
<ol start="2">
<li>调用 fsync 持久化。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后</p>
</li>
<li>
<p>3 执行很快，所以 binlog 的组提交效果通常不如 redo log 的效果好</p>
</li>
</ul>
</li>
<li>
<p>提升 binlog 组提交的效果</p>
<ul>
<li>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
</ol>
</li>
<li>
<ol start="2">
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
</li>
<li>两个条件是 或 的关系</li>
</ul>
</li>
</ul>
<h2 id="wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少">WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，磁盘读写没减少？<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#wal-机制是减少磁盘写但每次提交事务都要写-redo-log-和-binlog磁盘读写没减少" class="internal alias"> §</a></h2>
<ul>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制可以大幅度降低磁盘的 IOPS 消耗。</li>
</ul>
<h2 id="mysql-出现-io-性能瓶颈的提升性能方法">MySQL 出现 IO 性能瓶颈的提升性能方法<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#mysql-出现-io-性能瓶颈的提升性能方法" class="internal alias"> §</a></h2>
<ul>
<li>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。</li>
</ol>
<ul>
<li>这个方法基于“额外的故意等待”来实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
</ul>
</li>
<li>
<ol start="2">
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。</li>
</ol>
<ul>
<li>⚠️ 这样做的风险是，主机掉电时会丢 binlog 日志。</li>
</ul>
</li>
<li>
<ol start="3">
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
<ul>
<li>不建议设置为 0（只保存在内存中）</li>
<li>0 跟 2 的性能差不多，但 2 的风险更小</li>
</ul>
</li>
</ul>
<h2 id="数据库的-crash-safe-的作用">数据库的 crash-safe 的作用<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#数据库的-crash-safe-的作用" class="internal alias"> §</a></h2>
<ul>
<li>
<ol>
<li>如果客户端收到事务成功的消息，事务就一定持久化了；</li>
</ol>
<ul>
<li>双 1 配置时</li>
</ul>
</li>
<li>
<ol start="2">
<li>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。</li>
</ol>
</li>
</ul>
<h2 id="思考题">思考题<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#思考题" class="internal alias"> §</a></h2>
<ul>
<li>
<p>你的生产库设置的是「双 1」吗？ 如果平时是的话，你有在什么场景下改成过“非双 1”吗？你的这个操作又是基于什么决定的？</p>
<ul>
<li>
<ol>
<li>业务高峰期</li>
</ol>
</li>
<li>
<ol start="2">
<li>备库延迟</li>
</ol>
</li>
<li>
<ol start="3">
<li>用备份恢复主库的副本，应用 binlog 的过程</li>
</ol>
</li>
<li>
<ol start="4">
<li>批量导入数据的时候</li>
</ol>
</li>
</ul>
</li>
<li>
<p>我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？</p>
</li>
<li>
<p>一般情况下，把生产库改成“非双 1 ”配置，是设置</p>
<ul>
<li><code>innodb_flush_logs_at_trx_commit=2</code></li>
<li><code>sync_binlog=1000</code></li>
</ul>
</li>
</ul>
<h2 id="评论区">评论区<a aria-hidden="true" tabindex="-1" data-no-popover="true" href="#评论区" class="internal alias"> §</a></h2>
<ul>
<li>
<p>看到的「binlog 的记录」是从 page cache 读，page cache 在操作系统文件系统上</p>
<ul>
<li>ls 的结果也是</li>
</ul>
</li>
<li>
<p>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</p>
<ul>
<li>binlog 存储是以 statement 或者 row 格式存储的，而 redo log 是以 page 页格式存储的。page 格式，天生就是共有的，而 row 格式，只跟当前事务相关</li>
<li>在这里联系到 binlog 的格式，statement 记录的是更新的 SQL，但是要写上下文，因此不能中断，不然同步到从库后从库无法恢复一样的数据内容</li>
</ul>
</li>
<li>
<p>如果 <code>sync_binlog = N｜binlog_group_commit_sync_no_delay_count = M｜binlog_group_commit_sync_delay = 很大值</code>，这种情况 fsync 什么时候发生</p>
<ul>
<li>sync_delay 和 sync_no_delay_count 的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入 sync_binlog 阶段。这时候如果判断 sync_binlog=0，就直接跳过，还是不调 fsync。</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:false,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:false,&quot;removeTags&quot;:[]}"></div></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="./MySQL-实战-45-讲" class="internal">MySQL 实战 45 讲</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.4</a>, © 2024</p><ul><li><a href="https://github.com/11ze/knowledge-garden">GitHub</a></li><li><a href="https://twitter.com/11ze4">Twitter</a></li></ul></footer></div></body><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://www.googletagmanager.com/gtag/js?id=G-SZZLS6FREP" type="application/javascript"></script><script src="./postscript.js" type="module"></script></html>