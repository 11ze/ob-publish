<!DOCTYPE html>
<html lang="en"><head><title>12｜为什么我的 MySQL 会“抖”一下？</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="12｜为什么我的 MySQL 会“抖”一下？"/><meta property="og:description" content="概念 脏页：跟磁盘数据页内容不一致的内存数据页 干净页：跟磁盘数据页内容一致的内存数据页 何时内存中的脏页往硬盘上刷？ redo log 满 a. b. 把绿色部分的日志对应的所有脏页都 flush 到磁盘上 c. 之后，write pos 到 cp’ 之间是可以再写入的 redo log 的区域 当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘 不直接把内存淘汰掉，下次需求请求的时候从磁盘读入数据页，然后拿 redo log 出来应用的原因：为了保证每个数据页有两种状态 内存里存在，内存里肯定是正确的结果，直接返回； 内存里没有数据，可以肯定数据文件上是正确的结果，读入内存后返回。 MySQL 认为系统“空闲”的时候会刷，忙的时候也会找机会刷 正常关闭数据库时，会把内存的脏页都 flush 到磁盘上，下次启动时直接从磁盘读数据，启动速度快 第 2 种情况是常态 InnoDB 用缓冲池管理内存，缓冲池中的内存页有三种状态 还没有使用：很少 使用了并且是干净页 使用了并且是脏页。 当要读入的数据页没有在内存的时候，必须到缓冲池申请一个数据页 把最久不使用的数据页从内存中淘汰掉 影响性能的情况 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长； 日志写满，更新全部堵住，写性能跌为 0 InnoDB 刷脏页的控制策略 innodb_io_capacity 建议设置成磁盘的 IOPS 通过 fio 工具测试 IOPS fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest InnoDB 刷盘速度主要参考两个因素 脏页比例 innodb_max_dirty_pages_pct 脏页比例，默认值 75% 平时多关注脏页比例，不要让它经常接近 75% 脏页比例通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到，具体的命令参考下面的代码 mysql&amp;gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &amp;#039;Innodb_buffer_pool_pages_dirty&amp;#039;;select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &amp;#039;Innodb_buffer_pool_pages_total&amp;#039;;select @a/@b; InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样 伪代码 F1(M){ if M&amp;gt;=innodb_max_dirty_pages_pct then return 100; return 100*M/innodb_max_dirty_pages_pct;} redo log 写盘速度 InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。 根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。 在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。 使用 SSD 这类 IOPS 比较高的设备时，建议设为 0 MySQL 8.0 中默认值为 0 思考题 一个内存配置为 128GB、innodb_io_capacity 设置为 20000 的大规格实例，正常会建议你将 redo log 设置成 4 个 1GB 的文件。 但如果你在配置的时候不慎将 redo log 设置成了 1 个 100M 的文件，会发生什么情况呢？又为什么会出现这样的情况呢？ 每次事务提交都要写 redo log，如果设置太小，很快就会被写满，write pos 一直追着 CP 系统不得不停止所有更新，推进 checkpoint 现象：磁盘压力很小，但是数据库出现间歇性的性能下跌 评论区 redo log 在“重放”的时候，如果一个数据页已经刷过，会识别出来并跳过 基于 LSN（log sequence number 日志序列号） 每个数据页头部有 LSN，8 字节，每次修改都会变大。 对比这个 LSN 跟 checkpoint 的 LSN，比 checkpoint 小的一定是干净页 将脏页 flush 到磁盘上是直接将脏页数据覆盖到对应磁盘上的数据 断电重启后从 checkpoint 的位置往后扫，已经扫过盘的不会重复应用 redo log 名词解释 plush：刷脏页 purge：清 undo log merge：应用 change buffer change buffer 只对非唯一索引有效 常见的误用场景 很多测试人员在做压力测试的时候 出现刚开始 insert update 很快 一会 就出现很慢,并且延迟很大，大部分是因为 redo log 设置太小（跟上面思考题相同原理） ."/><meta property="og:image" content="https://wangze.tech/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="概念 脏页：跟磁盘数据页内容不一致的内存数据页 干净页：跟磁盘数据页内容一致的内存数据页 何时内存中的脏页往硬盘上刷？ redo log 满 a. b. 把绿色部分的日志对应的所有脏页都 flush 到磁盘上 c. 之后，write pos 到 cp’ 之间是可以再写入的 redo log 的区域 当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘 不直接把内存淘汰掉，下次需求请求的时候从磁盘读入数据页，然后拿 redo log 出来应用的原因：为了保证每个数据页有两种状态 内存里存在，内存里肯定是正确的结果，直接返回； 内存里没有数据，可以肯定数据文件上是正确的结果，读入内存后返回。 MySQL 认为系统“空闲”的时候会刷，忙的时候也会找机会刷 正常关闭数据库时，会把内存的脏页都 flush 到磁盘上，下次启动时直接从磁盘读数据，启动速度快 第 2 种情况是常态 InnoDB 用缓冲池管理内存，缓冲池中的内存页有三种状态 还没有使用：很少 使用了并且是干净页 使用了并且是脏页。 当要读入的数据页没有在内存的时候，必须到缓冲池申请一个数据页 把最久不使用的数据页从内存中淘汰掉 影响性能的情况 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长； 日志写满，更新全部堵住，写性能跌为 0 InnoDB 刷脏页的控制策略 innodb_io_capacity 建议设置成磁盘的 IOPS 通过 fio 工具测试 IOPS fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest InnoDB 刷盘速度主要参考两个因素 脏页比例 innodb_max_dirty_pages_pct 脏页比例，默认值 75% 平时多关注脏页比例，不要让它经常接近 75% 脏页比例通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到，具体的命令参考下面的代码 mysql&amp;gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &amp;#039;Innodb_buffer_pool_pages_dirty&amp;#039;;select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &amp;#039;Innodb_buffer_pool_pages_total&amp;#039;;select @a/@b; InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样 伪代码 F1(M){ if M&amp;gt;=innodb_max_dirty_pages_pct then return 100; return 100*M/innodb_max_dirty_pages_pct;} redo log 写盘速度 InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。 根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。 在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。 使用 SSD 这类 IOPS 比较高的设备时，建议设为 0 MySQL 8.0 中默认值为 0 思考题 一个内存配置为 128GB、innodb_io_capacity 设置为 20000 的大规格实例，正常会建议你将 redo log 设置成 4 个 1GB 的文件。 但如果你在配置的时候不慎将 redo log 设置成了 1 个 100M 的文件，会发生什么情况呢？又为什么会出现这样的情况呢？ 每次事务提交都要写 redo log，如果设置太小，很快就会被写满，write pos 一直追着 CP 系统不得不停止所有更新，推进 checkpoint 现象：磁盘压力很小，但是数据库出现间歇性的性能下跌 评论区 redo log 在“重放”的时候，如果一个数据页已经刷过，会识别出来并跳过 基于 LSN（log sequence number 日志序列号） 每个数据页头部有 LSN，8 字节，每次修改都会变大。 对比这个 LSN 跟 checkpoint 的 LSN，比 checkpoint 小的一定是干净页 将脏页 flush 到磁盘上是直接将脏页数据覆盖到对应磁盘上的数据 断电重启后从 checkpoint 的位置往后扫，已经扫过盘的不会重复应用 redo log 名词解释 plush：刷脏页 purge：清 undo log merge：应用 change buffer change buffer 只对非唯一索引有效 常见的误用场景 很多测试人员在做压力测试的时候 出现刚开始 insert update 很快 一会 就出现很慢,并且延迟很大，大部分是因为 redo log 设置太小（跟上面思考题相同原理） ."/><meta name="generator" content="Quartz"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="12｜为什么我的-MySQL-会“抖”一下？"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title"><a href=".">🫧 11ze</a></h1><div class="spacer mobile-only"></div><div class="search"><div id="search-icon"><p>Search</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="darkmode"><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="recent-notes desktop-only"><h3>Recent Notes</h3><ul class="recent-ul"><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./15｜消息队列的考验：Redis-有哪些解决方案？" class="internal">15｜消息队列的考验：Redis 有哪些解决方案？</a></h3></div><p class="meta">Apr 05, 2024</p><ul class="tags"><li><a class="internal tag-link" href="./tags/Redis">Redis</a></li></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./16｜异步机制：如何避免单线程模型的阻塞？" class="internal">16｜异步机制：如何避免单线程模型的阻塞？</a></h3></div><p class="meta">Apr 05, 2024</p><ul class="tags"><li><a class="internal tag-link" href="./tags/Redis">Redis</a></li></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./17｜为什么-CPU-结构也会影响-Redis-的性能？" class="internal">17｜为什么 CPU 结构也会影响 Redis 的性能？</a></h3></div><p class="meta">Apr 05, 2024</p><ul class="tags"><li><a class="internal tag-link" href="./tags/Redis">Redis</a></li></ul></div></li></ul></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title">12｜为什么我的 MySQL 会“抖”一下？</h1><p show-comma="true" class="content-meta"><span>Apr 05, 2024</span><span>7 min read</span></p><ul class="tags"><li><a href="./tags/MySQL" class="internal tag-link">MySQL</a></li></ul></div></div><article class="popover-hint"><h2 id="概念">概念<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#概念" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>脏页：跟磁盘数据页内容不一致的内存数据页</li>
<li>干净页：跟磁盘数据页内容一致的内存数据页</li>
</ul>
<h2 id="何时内存中的脏页往硬盘上刷">何时内存中的脏页往硬盘上刷？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#何时内存中的脏页往硬盘上刷" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ol>
<li>redo log 满
a. <img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-12-1.png" alt="image.png"/>
b. 把绿色部分的日志对应的所有脏页都 flush 到磁盘上
c. 之后，write pos 到 cp’ 之间是可以再写入的 redo log 的区域</li>
<li>当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘
<ul>
<li>不直接把内存淘汰掉，下次需求请求的时候从磁盘读入数据页，然后拿 redo log 出来应用的原因：为了保证每个数据页有两种状态
<ol>
<li>内存里存在，内存里肯定是正确的结果，直接返回；</li>
<li>内存里没有数据，可以肯定数据文件上是正确的结果，读入内存后返回。</li>
</ol>
</li>
</ul>
</li>
<li>MySQL 认为系统“空闲”的时候会刷，忙的时候也会找机会刷</li>
<li>正常关闭数据库时，会把内存的脏页都 flush 到磁盘上，下次启动时直接从磁盘读数据，启动速度快</li>
</ol>
<ul>
<li>第 2 种情况是常态
<ul>
<li>InnoDB 用缓冲池管理内存，缓冲池中的内存页有三种状态
<ol>
<li>还没有使用：很少</li>
<li>使用了并且是干净页</li>
<li>使用了并且是脏页。</li>
</ol>
</li>
</ul>
</li>
<li>当要读入的数据页没有在内存的时候，必须到缓冲池申请一个数据页
<ul>
<li>把最久不使用的数据页从内存中淘汰掉</li>
<li>影响性能的情况
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为 0</li>
</ol>
</li>
</ul>
</li>
<li>InnoDB 刷脏页的控制策略
<ul>
<li><code>innodb_io_capacity</code>
<ul>
<li>建议设置成磁盘的 IOPS</li>
<li>通过 fio 工具测试 IOPS
<ul>
<li><code>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</code></li>
</ul>
</li>
</ul>
</li>
<li>InnoDB 刷盘速度主要参考两个因素
<ul>
<li>脏页比例
<ul>
<li><code>innodb_max_dirty_pages_pct</code> 脏页比例，默认值 75%</li>
<li>平时多关注脏页比例，不要让它经常接近 75%</li>
<li>脏页比例通过 <code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code> 得到，具体的命令参考下面的代码
<ul>
<li><code>mysql> select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;</code></li>
</ul>
</li>
<li>InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样
<ul>
<li>伪代码
<ul>
<li><code>F1(M){ if M>=innodb_max_dirty_pages_pct then return 100; return 100*M/innodb_max_dirty_pages_pct;}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>redo log 写盘速度
<ul>
<li>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。</li>
<li>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力乘以 R% 来控制刷脏页的速度。</li>
<li><img src="https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-12-2.png" alt="image.png"/></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在 InnoDB 中，<code>innodb_flush_neighbors</code> 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。
<ul>
<li>使用 SSD 这类 IOPS 比较高的设备时，建议设为 0</li>
<li>MySQL 8.0 中默认值为 0</li>
</ul>
</li>
</ul>
<h2 id="思考题">思考题<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#思考题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>一个内存配置为 128GB、<code>innodb_io_capacity</code> 设置为 20000 的大规格实例，正常会建议你将 redo log 设置成 4 个 1GB 的文件。</li>
<li>但如果你在配置的时候不慎将 redo log 设置成了 1 个 100M 的文件，会发生什么情况呢？又为什么会出现这样的情况呢？
<ul>
<li>每次事务提交都要写 redo log，如果设置太小，很快就会被写满，write pos 一直追着 CP</li>
<li>系统不得不停止所有更新，推进 checkpoint</li>
<li>现象：磁盘压力很小，但是数据库出现间歇性的性能下跌</li>
</ul>
</li>
</ul>
<h2 id="评论区">评论区<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#评论区" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>redo log 在“重放”的时候，如果一个数据页已经刷过，会识别出来并跳过
<ul>
<li>基于 LSN（log sequence number 日志序列号）</li>
<li>每个数据页头部有 LSN，8 字节，每次修改都会变大。</li>
<li>对比这个 LSN 跟 checkpoint 的 LSN，比 checkpoint 小的一定是干净页</li>
</ul>
</li>
<li>将脏页 flush 到磁盘上是直接将脏页数据覆盖到对应磁盘上的数据</li>
<li>断电重启后从 checkpoint 的位置往后扫，已经扫过盘的不会重复应用 redo log</li>
<li>名词解释
<ul>
<li>plush：刷脏页</li>
<li>purge：清 undo log</li>
<li>merge：应用 change buffer
<ul>
<li>change buffer 只对非唯一索引有效</li>
</ul>
</li>
</ul>
</li>
<li>常见的误用场景
<ul>
<li>很多测试人员在做压力测试的时候 出现刚开始 insert update 很快 一会 就出现很慢,并且延迟很大，大部分是因为 redo log 设置太小（跟上面思考题相同原理）</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:false,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:false,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#概念" data-for="概念">概念</a></li><li class="depth-0"><a href="#何时内存中的脏页往硬盘上刷" data-for="何时内存中的脏页往硬盘上刷">何时内存中的脏页往硬盘上刷？</a></li><li class="depth-0"><a href="#思考题" data-for="思考题">思考题</a></li><li class="depth-0"><a href="#评论区" data-for="评论区">评论区</a></li></ul></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li><a href="./04｜深入浅出索引（上）" class="internal">04｜深入浅出索引（上）</a></li><li><a href="./MySQL-实战-45-讲" class="internal">MySQL 实战 45 讲</a></li></ul></div><script src="https://giscus.app/client.js" data-repo="11ze/knowledge-garden" data-repo-id="R_kgDOJhaxtw" data-category="General" data-category-id="DIC_kwDOJhaxt84CWa3R" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.2.3</a> © 2024</p><ul><li><a href="https://github.com/11ze/knowledge-garden">GitHub</a></li><li><a href="https://twitter.com/11ze4">Twitter</a></li></ul></footer></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script type="module">
          let mermaidImport = undefined
          document.addEventListener('nav', async () => {
            if (document.querySelector("code.mermaid")) {
              mermaidImport ||= await import('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs')
              const mermaid = mermaidImport.default
              const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
              mermaid.initialize({
                startOnLoad: false,
                securityLevel: 'loose',
                theme: darkMode ? 'dark' : 'default'
              })

              await mermaid.run({
                querySelector: '.mermaid'
              })
            }
          });
          </script><script src="./postscript.js" type="module"></script></html>