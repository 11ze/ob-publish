---
title: 13｜为什么表数据删掉一半，表文件大小不变？
tags:
  - MySQL
createdAt: 2023-08-17T14:31:26+08:00
updatedAt: 2023-08-17T14:36:59+08:00
---

## 参数 innodb_file_per_table

- OFF：表的数据放在系统共享表空间，跟数据字典放在一起
- ON：每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中
  - 从 5.6.6 版本开始是默认值
- 建议无论使用哪个版本都将这个值设置为 ON
- 因为一个表单独存储为一个文件更容易管理
- 在不需要这个表的时候，通过 `drop table` 命令可以直接删除这个文件，而如果放在共享表空间，即使表删掉了，空间也不会回收。
- 下面的内容基于 ON 展开

## 数据删除流程

- 删除一行记录，InnoDB 引擎只会把这个记录标记为删除
  - 当再插入一个在被删记录位置的记录时，可能复用该位置
- 如果删掉一整个数据页上的所有记录，则整个数据页可以被复用
- 数据页的复用跟记录的复用不同
  - 记录的复用只限于符合范围条件的数据
  - 数据页的复用可以复用到任何位置
- 如果相邻的两个数据页利用率都很小，系统会把两个页的数据合到其中一个页，另一个被标记为可复用
- 如果用 delete 命令删除整个表的数据，则所有的数据页都会被标记为可复用，但是磁盘上文件不会变小

## 重建表

- `alter table A engine=InnoDB`
  - 起到收缩表 A 的作用
- 5.5 版本之前
  - 新建跟 A 结构相同的表 B，将 A 的数据按照主键 ID 递增的顺序一行行地读出来插入表 B，然后用 B 替换 A
  - 隐含意思：`alter table t engine=innodb, ALGORITHM=copy;`
- 5.6 版本开始引入 `Online DDL`，对上面的流程做了优化
  - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-13-1.png)

  - 1. 建立一个临时文件，扫描表 A 主键的所有数据页；
  - 2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
  - 3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
  - 4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
  - 5. 用临时文件替换表 A 的数据文件。
  - 隐含意思：`alter table t engine=innodb, ALGORITHM=inplace;`
- DDL 之前需要拿 MDL 写锁
  - 在真正拷贝数据之前会退化成读锁
  - MDL 读锁不会阻塞增删改操作
  - 不直接解锁的原因是为了禁止其他线程对这个表同时做 DDL
  - 写锁时间很短，对业务来说可以认为是 Online 的
- ⚠️ 上述操作都会扫描原表数据和构建临时文件，对于大表，很消耗 IO 和 CPU 资源
  - 如果是线上服务，要小心地控制操作时间
  - 推荐使用 gh-ost

## Online 和 Inplace

- 5.6 版本之后，根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。
  - 临时文件也要占用临时空间
- 关系
  - 1. DDL 过程如果是 Online 的，就一定是 inplace 的；
  - 2. 反过来未必，inplace 的 DDL，有可能不是 Online 的。
       - 截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引（SPATIAL index）就属于这种情况
- `optimize table`、`analyze table` 和 `alter table` 这三种方式重建表的区别
- 从 MySQL 5.6 版本开始，`alter table t engine = InnoDB`（也就是 recreate）默认的就是上面优化后的流程了；
- `analyze table t` 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；
- `optimize table t` 等于 recreate + analyze。
  - 新的表基本上统计信息是全新的，建议直接用 alter

## 思考题

- 1. 一个表 t 文件大小为 1TB；
- 2. 对这个表执行 `alter table t engine=InnoDB`；
- 3. 发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了 1.01TB。
- 原因
  - 本来就很紧凑，没能整出多少剩余空间。重新收缩的过程中，页会按 90% 满的比例来重新整理页数据（10% 留给 UPDATE 使用），未整理之前页已经占用 90% 以上，收缩之后，文件就反而变大了。

## 评论区

- 既然 MySQL 支持了打包数据排序模式，能够更紧凑的分配内存进行排序，那定义表结构的时候，varchar(10) 存储 hello 和 varchar(100) 存储 hello 的优势在哪里呢？
  - 以前不支持紧凑排序的时候有，现在没啥了差别了，小于256都差不多
