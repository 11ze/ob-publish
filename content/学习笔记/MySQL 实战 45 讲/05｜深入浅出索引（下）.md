---

title: 05｜深入浅出索引（下）
tags:
- MySQL
createdAt: 2023-05-17T10:13:29+08:00

---

## 如何安排联合索引内的字段顺序

- 第一原则：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
- 如果既有联合查询，又有基于 a、b 各自的查询，此时要考虑空间
  - 比如 a 比 b 大，就建 (a, b) + 单 b
- 还有其他情况，需要结合业务分析

## 查询语句的 where 里面各个判断调换顺序不影响

## 覆盖索引

- 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果
- 要全用上必须是条件 =，不能是 > 或 <

## 在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？

- 如果有一个高频请求是根据身份证号查询姓名，就有必要

## 前缀索引

- 最左前缀原则
  - 可以是联合索引的最左 N 个字段
  - 也可以是字符串索引的最左 M 个字符

## 索引下推

- MySQL 5.6 之后引入
- 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
- 例子：有个 (name, age) 索引
  - `where name like '张%' and age=10`
  - 因为最左前缀原则，只能用到 name 索引
  - 5.6 之前：查找到所有`张`开头的记录，一个个回表找出数据行，对比 age 字段值
  - 5.6 之后：索引下推

## 思考题

- 已有条件
  - 多个索引
    - primary ab (a, b)
    - c (c)
    - ca (c, a)
    - cb (c, b)
  - DBA 解释：业务中有两个语句
    - select * from geek where c=N order by a limit 1;
    - select * from geek where c=N order by b limit 1;
  - 所以需要 ca 和 cb，而不是单个 c
- 问题
  - 这样解释对吗，ca 和 cb 是否都是必须的
    - 只需要 cb
  - 为什么
    - 因为存在 ab，普通索引包含主键，即 c + ab => cab
  - 题外话
    - 对于 order by，如果索引合理，数据有序，就不需要排序了

## 评论区

- 面试题：怎么让 MySQL 的 `myisam` 引擎支持事务
  - 用 `lock table` 实现，但只能实现串行化隔离级别
  - 因为 `mysiam` 不支持崩溃恢复，所以即使用 `lock table` 硬实现，也是问题多多
  - ACID 里面，原子性和持久性做不到
  - 隔离性只能实现基本用不上的串行化
  - 一致性在正常运行的时候依赖于串行化，在异常崩溃的时候也不能保证
  - 这样实现的事务不要也罢
- 订单表查询，有多个条件，不选则不传，怎么建索引
  - 老师回复
    - 按照查询的模式，选最常见的创建联合索引。
      - 比如，如果时间 + 客户标志用得最多，就创建这两个的联合索引
    - 比较少用的条件，就单独建，然后查 id 出来跟别的字段的查询结果，在客户端取交集
  - 跟评
    - 用 [[ElasticSearch]]，相当于全建索引
      - 好处是快，减轻数据库压力
      - 坏处是多维护一个中间件
- 使用联合索引的时候，联合索引的多个属性都在同一棵树上
  - [[InnoDB]] 的普通索引，都是这个索引字段 + 主键字段的联合索引
- 用 key 和 index 创建索引没有区别
- 什么情况下会一次取出多个主键回表
  - 自动，代码版本支持就会这么做
- 联合索引是怎么存储的
  - 联合索引是依次按照联合字段的`先后顺序`，依次进行排序。如 a, b, c 三个字段是联合索引，则叶子节点存储的是三个字段的数据，且按照先后顺序进行排序；而非叶子节点存储的是第一个关键字的索引。故当执行查询的时候，因为联合索引中是先根据 a 进行排序的，如果 a 没有先确定，直接对 b 或 c 进行查询的话，就相当于是`乱序查询`，因此联合索引无法生效，此时就相当于是全表查询。
- in 速度很快，in 里面的项`递增`输入的话，理论上会快些
  - 如果太多项，可以拆成多个 `in()`，分批处理
  - ⚠️ 不要用 `union all`
- b+ 树中的索引节点应该都是由指针和索引组成。但现在要将磁盘索引节点加载到内存中，这些指针地址是怎么映射的（磁盘和内存指针的映射）
  - 首先磁盘的数据和数据页是一样的，
  - 所以磁盘只能记录 “我的第一个叶子节点在 page_n”
  - 在内存里面也是，当把 page_n 读到内存以后，内存里面记录的是 page_n 的内存地址在哪里
