---

title: 45｜自增 id 用完怎么办？
tags:
- MySQL
createdAt: 2023-05-17T22:27:40+08:00

---

- 表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。
- row_id

  - InnoDB 表没有指定主键时，会创建一个不可见的，长度为 6 个字节的 row_id。
  - row_id 是一个长度 8 字节的无符号长整形
  - 但是 InnoDB 只留了 6 个字节的长度给 row_id 用

    - 1. row_id 写入表中的值范围，是从 0 到 248-1；
    - 2. 达到上限后从 0 开始，写入时会覆盖原有的行

- Xid

  - redo log 和 binlog 相配合时都有的一个共同字段
  - MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。
  - global_query_id 是一个纯内存变量，重启之后就清零了

    - 1. 重启后会清零

      - 不同事务的 Xid 可能相同

  - 2. 重启后会重新生成新的 binlog 文件

    - 同一个 binlog 文件里，Xid 唯一
    - 达到上限（超大）后从 0 开始，还是可能不唯一，但是只存在于理论上

  - 长度是 8 个字节，上限超大

- Innodb trx_id

  - 第 8 篇讲事务可见性用到的事务 id（transaction id）
  - Xid 由 server 层维护，InnoDB 内部使用 Xid 是为了在 InnoDB 事务和 server 之间做关联
  - InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。

    - 对于正在执行的事务，可以从 information_schema.innodb_trx 表中看到事务的 trx_id。
    - 对于只读事务，InnoDB 不分配 trx_id，在表中查看到的很大的 trx_id 只是显示用的

      - 把当前事务的 trx 变量的指针地址转成整数，再加上 2^48

        - 1. 因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在 innodb_trx 还是在 innodb_locks 表里，同一个只读事务查出来的 trx_id 就会是一样的。
        - 2. 如果有并行的多个只读事务，每个事务的 trx 变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的 trx_id 就是不同的。
        - 加上是为了避免跟真正的 trx_id 一样

      - 不分配的好处

        - 可以减小事务视图里面活跃事务数组的大小
        - 可以减少 trx_id 的申请次数（减少并发事务申请 trx_id 的锁冲突）

    - select 语句后面加上 for update 则不是只读事务
    - 1. update 和 delete 语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到 purge 队列里等待后续物理删除，这个操作也会把 max_trx_id+1， 因此在一个事务中至少加 2；
    - 2. InnoDB 的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id 值并不是按照加 1 递增的。

  - InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。
  - 重启 MySQL时 max_trx_id 不会清零

    - 理论上，MySQL 实例运行得足够久，trx_id 达到上限后从 0 开始，就会持续出现脏读

- thread_id

  - 4 个字节，达到 2^32 - 1 后重置为 0，然后继续增加
  - 不会在 show processlist 看到两个相同的 thread_id

    - MySQL 设计了一个唯一数组：循环尝试插入自增 1 的线程 id 直到成功

- 小结

  - 1. 表的自增 id 达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。
  - 2. row_id 达到上限后，则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据。
  - 3. Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。
  - 4. InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，所以我们文章中提到的脏读的例子就是一个必现的 bug，好在留给我们的时间还很充裕。
  - 5. thread_id 是我们使用中最常见的，而且也是处理得最好的一个自增 id 逻辑了。
