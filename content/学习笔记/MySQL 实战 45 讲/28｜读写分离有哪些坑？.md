---

title: 28｜读写分离有哪些坑？
tags:
- MySQL
createdAt: 2023-05-17T21:40:49+08:00

---

- 1. 客户端直连

  - 查询性能稍微好点，整体架构简单，排查问题更方便
  - 主备切换、库迁移等操作时，客户端会感知到，并且需要调整数据库连接信息
  - 一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发

- 2. 带 proxy 的架构

  - 对客户端友好，连接维护、后端信息等工作都由 proxy 完成
  - 对后端维护团队的要求更高，需要高可用，整体架构比较复杂

- 过期读：在从库上会读到系统的一个过期状态
- 强制走主库方案

  - 1. 对于必须要拿到最新结果的请求，强制将其发到主库上
  - 2. 对于可以读到旧数据的请求，才将其发到从库上

- sleep 方案

  - 不精确

- 判断主备无延迟方案

  - 三种方法
  - 1. 每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。

    - seconds_behind_master 的单位是秒，可能精度不够

  - 2. 对比位点

    - Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。如果Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。

  - 3. 对比GTID 集合

    - Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。如果这两个集合相同，也表示备库接收到的日志都已经同步完成。

  - 后两种准确度更高，但还不够

    - 可能还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。
      - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-28-1.png)


- 配合 semi-sync（半同步复制） 方案

  - semi-sync 的设计

    - 1. 事务提交的时候，主库把 binlog 发给从库；
    - 2. 从库收到 binlog 以后，发回给主库一个 ack，表示收到了；
    - 3。 主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。

  - 如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。
  - 存在问题

    - 1. 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；

      - 主库只要等到一个从库的 ack，就开始给客户端返回确认

    - 2. 在持续延迟的情况下，可能出现过度等待的问题。

      - 如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。

- 等主库位点方案

  - 主备持续延迟一个事务
    - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-28-2.png)

  - 1. trx1 事务更新完成后，客户端马上执行 show master status 得到当前主库执行到的 File 和 Position；
  - 2. 选定一个从库执行查询语句；
  - 3. 在从库上执行 select master_pos_wait(File, Position, 1)；

    - a. 参数 file 和 pos 指的是主库上的文件名和位置；
    - b. timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。
    - 这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。等于 0：代表这个 file 和 postion 已经执行过；大于 0：代表在时间内已经执行到这个 file 和 position，并且已经执行了 n 条事务。

  - 4. 如果返回值是 >=0 的正整数，则在这个从库执行查询语句；
  - 5. 否则，到主库执行查询语句。

- 等 GTID 方案

  - >= MySQL 5.7.6

  - select wait_for_executed_gtid_set(gtid_set, 1);

    - 1. 等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；
    - 2. 超时返回 1。

  - 1. trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；

    - 将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值。

  - 2. 选定一个从库执行查询语句；
  - 3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；
  - 4. 如果返回值是 0，则在这个从库执行查询语句；
  - 5. 否则，到主库执行查询语句。

- 方案可以混合使用
- 思考题

  - 假设你的系统采用了我们文中介绍的最后一个方案，也就是等 GTID 的方案，现在你要对主库的一张大表做 DDL（加减索引、增加字段在最后一列），可能会出现什么情况呢？

    - 假设，这条语句在主库上要执行 10 分钟，提交后传到备库就要 10 分钟（典型的大事务）。那么，在主库 DDL 之后再提交的事务的 GTID，去备库查的时候，就会等 10 分钟才出现。
    - 这样，这个读写分离机制在这 10 分钟之内都会超时，然后走主库。

  - 为了避免这种情况，你会怎么做呢？

    - 这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询。然后把读请求都切到主库，再在主库上做 DDL。等备库延迟追上以后，再把读请求切回备库。
