---

title: 39｜自增主键为什么不是连续的？
tags:
- MySQL
createdAt: 2023-05-17T22:15:09+08:00

---

- 自增值保存在哪儿？

  - 表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。
  - MyISAM 引擎的自增值保存在数据文件中。
  - InnoDB

    - 在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。
    - 在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。

- 自增值修改机制

  - 1. 如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；
  - 2. 如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。

    - 如果大于当前自增值，则会将插入的值的下一个大于的值作为自增值（基于步长）

- 自增值的修改时机

  - insert into t values(null, 1, 1); 发现没指定自增值，获取表当前的自增值（假设是 2）将传入的行改成 (2, 1, 1)将表的自增值改成 3继续执行插入操作发生唯一键冲突，插入失败

    - 第一种原因：唯一键冲突

  - 第二种原因：事务回滚，自增值不回退

    - 两个事务，前一个拿到自增值，后一个再拿到自增值，前一个执行失败，如果回退，将导致主键冲突
    - 为了解决主键冲突有两种方法，但是影响性能

- 自增锁的优化

  - MySQL 5.0 版本，自增锁的范围是语句级别，等语句执行完才释放，影响并发度
  - MySQL 5.1.22 引入一个新策略，新增参数 innodb_autoinc_lock_mode，默认值 1

    - 1. 这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略
    - 2. 这个参数的值被设置为 1 时：  a. 普通 insert 语句，自增锁在申请之后就马上释放；  b. 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

      - 关于 b，如果像参数设置 2 一样，将会导致主备不一致（binlog_format=statement），因为事务的 binlog 是记录到一起的，在备库是连续，但在主库时却不一定是连续拿到自增值
      - 这里说的批量插入数据，包含的语句类型是 insert … select、replace … select 和 load data 语句。
      - b 的设定是因为“不知道要预先申请多少个 id”

    - 3. 这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。

      - 推荐，需配合 binlog_format=row

  - 在 8.0.3 版本后，innodb_autoinc_lock_mode 默认值已是 2

- 对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：

  - 1. 语句执行过程中，第一次申请自增 id，会分配 1 个；
  - 2. 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；
  - 3. 依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。
  - 最后一次申请的如果没用完就浪费掉了

    - 第三种原因

- 思考题

  - 在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement。这个语句会对表 t 的所有记录和间隙加锁。
  - 你觉得为什么需要这么做呢？

- 评论区

  - 在 binlog 为 statement 的情况下。语句 A 先获取 id=1，然后 B 获取 id=2，接着 B 提交，写 binlog，再 A 写 binlog。这个时候如果 binlog 重放，是不是会发生 B 的 id 为 1，而 A的 id 为 2 的不一致的情况？

    - 不会因为 binlog 在记录这种带自增值的语句之前，会在前面多一句，用于指定“接下来这个语句要需要的 自增 ID 值是多少”，而这个值，是在主库上这一行插入成功后对应的自增值，所以是一致的

      - 跟这里不冲突，因为这里是在说主库事务中不能连续拿到的问题
