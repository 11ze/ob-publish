---

title: 38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？
tags:
- MySQL
createdAt: 2023-05-17T22:13:35+08:00

---

- 内存表的数据组织结构

  - InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。
  - 而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。
    - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-38-1.png)

  - 1. InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
  - 2. 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；
  - 3. 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；
  - 4. InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。
  - 5. InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。

- 内存表也支持 B-Tree 索引的

  - alter table t1 add index a_btree_index using btree (id);

- 不建议在生产环境使用普通内存表

  - 1. 锁粒度问题

    - 不支持行锁，只支持表锁

  - 2. 数据持久化问题

    - M - S 架构下，比如备库重启，内存表被清空，此时内存表被清空，导致主备同步停止
    - 双 M 架构下，在备库重启的时候，备库 binlog 里的 delete 语句就会传到主库，然后把主库内存表的内容删除。

- 建议把普通内存表都用 InnoDB 代替

  - 例外：内存临时表

    - 1. 临时表不会被其他线程访问，没有并发性的问题；
    - 2. 临时表重启后也是需要删除的，清空数据这个问题不存在；
    - 3. 备库的临时表也不会影响主库的用户线程。

- 思考题

  - 假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成 InnoDB 引擎表。
  - 假设当时的业务场景暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止呢？

    - 先避免备库重启的时候数据丢失：set sql_log_bin=off;alter table tbl_name engine=innodb;由于主库重启后，会往 binlog 写 delete from tbl_name，传到备库，备库的同名的表数据也会被清空，所以不会出现主备同步停止的问题
    - 如果主库变成新备库，重复上面的操作
    - 所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。
