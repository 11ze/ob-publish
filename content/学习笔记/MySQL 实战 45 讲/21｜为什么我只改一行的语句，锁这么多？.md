---
title: 21｜为什么我只改一行的语句，锁这么多？
tags:
  - MySQL
createdAt: 2023-05-17T21:03:23+08:00
updatedAt: 2023-08-17T14:25:30+08:00
---

- 此章节的规则有效的前提
  - 加锁策略可能改变，下面的只限于
    - 5.x 系列 <= 5.7.24
    - 8.0 系列 <= 8.0.13

- 间隙锁在可重复读隔离级别下才有效
  - 读提交在外键场景下也有

- 两个原则、两个优化、一个 bug
  - 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
  - 原则 2：查找过程中访问到的对象才会加锁。逐个加
  - 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
  - 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
  - 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
    - MySQL 8.0.18 版本已修复

- 八个案例
  - lock in share mode 只锁覆盖索引，而执行 for update 时，系统认为接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁；
    - 说明锁是加在索引上的
  - 要用 lock in share mode 给行加读锁避免数据被更新的话，必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段
    - 比如，将查询语句 `select id from t where c=5;` 改成 `select d from t where c=5 lock in share mode;`
  - 等价的语句加锁范围不一定相同
    - 比如等值查询和范围查询
  - delete 语句加锁的逻辑跟 `select … for update` 类似
  - ⚠️ 在删除数据的时候尽量加 limit
    - 不仅可以控制删除数据的条数，还可以减小加锁的范围
  - 加 next-key lock 实际上是分成来两步，先加间隙锁，然后再加行锁

- 小结
  - 读提交隔离级别下还有一个优化：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放，不需要等到事务提交
    - 锁的范围更小，锁的时间更短
    - 不少业务默认使用读提交隔离级别的原因
    - 只对 update 有效，delete 无效
