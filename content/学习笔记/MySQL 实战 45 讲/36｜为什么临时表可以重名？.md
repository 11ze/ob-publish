---

title: 36｜为什么临时表可以重名？
tags:
- MySQL
createdAt: 2023-05-17T22:07:50+08:00

---

- 临时表和内存表不同

  - 内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。
  - 而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。临时表也可以使用 Memory 引擎。

- 临时表的特性

  - 1. 建表语法是 create temporary table …。
  - 2. 一个临时表只能被创建它的 session 访问，对其他线程不可见。

    - 在 session 结束的时候会自动删除临时表

      - 不用担心数据删除问题

    - 不同 session 的临时表可以重名

  - 3. 临时表可以与普通表同名。
  - 4. session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。
  - 5. show tables 命令不显示临时表。

- 临时表的应用

  - 经常被用在复杂查询的优化过程中
  - 典型：分库分表系统的跨库查询

    - 第一种思路：在 proxy 层的进程代码中实现排序

      - 1. 开发工作量比较大
      - 2. 对 proxy 端压力大：内存、CPU

    - 第二种思路：把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。

      - 1. 在汇总库创建临时表
      - 2. 在分库拿到需要的数据，插入到临时表中

- 临时表可以重名

  - 物理上的文件

  - #sql{进程 id}_{线程 id}_ 序列号.frm 文件保存表结构定义

    - 通过 select @@tmpdir 命令可以查看临时文件目录

  - 5.6 以及之前的版本：#sql{进程 id}_{线程 id}_ 序列号.ibd 存放数据文件
  - 5.7 开始：MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。不需要再创建 ibd 文件了。

  - 内存里面

    - 每个表对应一个 table_def_key

      - 普通表：库名 + 表名
      - 临时表：库名 + 表名 + server_id + thread_id

    - 在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE + 表名”操作。

- 临时表和主备复制

  - 只在 binlog_format=statment/mixed 的时候，binlog 中才会记录临时表的操作。

    - row 格式会记录操作的数据

      - 删除临时表的语句会被改写，因为备库找不到临时表会报错
      - /* generated by server */ 说明是被服务端改写过的语句

  - MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key：

- 本章的内存表都是用户手动创建的

  - 内存临时表在 17 章和下一章有介绍

- 思考题

  - 可以用 alter table 修改临时表的表名，不能使用 rename 语法的原因？

    - 在实现上，执行 rename table 语句的时候，要求按照“库名 / 表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是“#sql{进程 id}_{线程 id}_ 序列号.frm”，因此会报“找不到文件名”的错误。

- 评论区

  - “临时表会自动回收”这个功能，主要用于“应用程序异常断开、MySQL异常重启”后，不需要主动去删除表。平时正常使用的时候，建议用完手动删除。

    - 如果 A 客户端在执行过程中创建了临时表，用完了连接就放回池子里面，没有做别的清理工作，然后新的客户端 B 复用这个连接，就可能会看到 A 的临时表。具体要看连接池怎么实现的。

  - 一般一个事务创建临时表以后，读写分离就会默认接下来的请求都路由到主库去了
  - 用户没有显示指定主键的话，InnoDB 引擎会自己创建一个隐藏的主键，但是这个主键对 server 层是透明的，优化器用不上。
  - 启以后 MySQL 会扫描临时目录，把表都删掉；
