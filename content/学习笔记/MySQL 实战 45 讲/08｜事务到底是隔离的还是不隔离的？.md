---

title: 08｜事务到底是隔离的还是不隔离的？
tags:
- MySQL
createdAt: 2023-05-17T14:45:12+08:00

---

## 事务的启动时机

- `begin/start transaction` 命令之后的第一个操作 InnoDB 表的语句，事务才真正启动。
- 马上启动一个事务：`start transaction with consistent snapshot`。
- 事务自动提交设置，默认为 1，即除非显示声明一个事务的开始，否则每一个查询都会被当做独立的事务被处理。
- 整个专栏，如果没有特别说明，都默认 autocommit = 1。

## MySQL 里的两个“视图”的概念

- 一个是 view。是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。
  - 创建视图的语法是 `create view …`，查询方法和表一样。
- 另一个是 InnoDB 在实现 MVCC（多版本并发控制） 时用到的一致性读视图（consistent read view），用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。
- 视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”

## “快照”在 MVCC 里是怎么工作的？

- 秒级创建快照的能力，快照是基于整库的。
- InnoDB 的行数据有多个版本（row），每个版本有自己的 `row trx_id`（严格递增）。
  - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-08-1.png)
  - 图中的虚线就是 undo log。
- 在实现上，InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。
  - 活跃：启动了但还没提交。
  - 数组里事务 ID 的最小值记为低水位。
  - 当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。
  - 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。
  - 数据版本的可见性规则：基于数据的 `row trx_id` 和一致性视图的对比结果得到的。
    - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-08-2.png)
    - 绿色：表示这个版本是已提交的事务或者是当前事务自己生成的，可见。
    - 红色：表示是由将来启动的事务生成的，不可见。
    - 黄色
      - a）若 `row trx_id` 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
      - b）若 `row trx_id` 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
- 翻译：对于一个事务视图，除了自己的更新总是可见以外，有三种情况
  1. 版本未提交，不可见；
  2. 版本已提交，但是是在视图创建后提交的，不可见；
  3. 版本已提交，而且是在视图创建前提交的，可见。
- 每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 `row trx_id` 和一致性视图确定数据版本的可见性。
  - 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
  - 对于读提交，查询只承认在语句启动前就已经提交完成的数据；

## 更新逻辑

- 更新数据都是先读后写。
- 当前读：总是读取已经提交完成的最新版本。
- 除了 update 语句，select 语句如果加锁，也是当前读。
  - 加上 `lock in share mode` 或 `for update`。

## 事务的可重复读是怎么实现的？

- 可重复读的核心是一致性读；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
- 读提交的逻辑和可重复读的逻辑类似，最主要的区别：
  - 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
  - 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的事务。

## 为什么表结构不支持“可重复读”？

- 因为表结构没有对应的行数据，也没有 `row trx_id`，因此只能遵循当前读的逻辑。
- MySQL 8.0 可以把表结构放在 InnoDB 字典里，也许以后会支持表结构的可重复读。

## 思考题

- 表
  - id 1 2 3 4
  - c 1 2 3 4
  - InnoDB，主键 id
- 想要把所有字段 c 和 id 值相等的行的 c 值清零，却改不掉
  - 1. `begin`；2. `select * from t`；3. `update t set c=0 where id=c`；4. `select * from t`；
  - 2、4 查到的结果一样。
- 构造出这种情况
  - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-08-3.png)
  - 用另一个事务在更新语句前先进行更新
- 说明原理
  - 更新操作是当前读，被抢先更新后的数据版本号不属于自己，看不到，在可重复读下还是读到旧值，此时就出现：数据正确，却更新不了
- 在实际业务开发中有没有可能碰到这种情况？
  - 有
- 怎么解决？
  - 根据更新语句的 `affected_rows` 判断是否更新成功

## 评论区

- 在同一行数据，最新版本的 `row trx_id` 是可能会小于旧版本的 `row trx_id` 的。因为后开启的事务可能先提交。
- 只读事务“不分配 trx_id”
  - 5.6 以后的优化
  - 其实不是不分配，而是随机分配。
- 读提交和当前读
  - 读提交不加锁
  - 考虑下，一个语句开始执行之后，执行期间别的事务修改了数据的情况。
