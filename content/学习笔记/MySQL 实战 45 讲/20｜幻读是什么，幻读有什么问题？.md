---
title: 20｜幻读是什么，幻读有什么问题？
tags:
  - MySQL
createdAt: 2023-05-17T20:59:11+08:00
updatedAt: 2023-08-17T14:25:31+08:00
---

- InnoDB 的默认事务隔离级别是可重复读
- 和下一章共用的表：

  ```sql
  CREATE TABLE `t` (
    `id` int(11) NOT NULL, 
    `c` int(11) DEFAULT NULL, 
    `d` int(11) DEFAULT NULL, 
    PRIMARY KEY (`id`), 
    KEY `c` (`c`)
  ) ENGINE=InnoDB;
  insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
  ```

## 幻读

- 幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
  1. ⚠️ 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
  2. 幻读专指“新插入的行”。

- 原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”
- 幻读有什么问题？
  - 语义上被破坏，比如，假设只把所有 d = 5 的行锁住，不准别的事务进行读写操作，此时更新别的未被锁住的 d != 5 的行，让 d = 5
  - 数据一致性问题
    - 即使把即将要改成 d = 5 的行也锁住，还是拦不住插入 d = 5 的行

## 解决

- InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。
  - 间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。
    - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-20-1.png)

  - 间隙锁记为开区间

- 跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。
- 间隙锁和行锁合称 `next-key lock`，是前开后闭区间。
  - 如果用 `select * from t for update` 要把整个表所有记录锁起来，就形成了 7 个 `next-key lock`，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。

- 间隙锁和 next-key lock 的引入带来的问题
  - 加大了加锁范围，降低并发度

- 上面的讨论都是在可重复度隔离级别下的，间隙锁在此级别下才会生效
- 如果改成读提交，就没有间隙锁，同时也不会有上面的问题，但同时也需要把 binlog 格式设置为 row
  - 常见的配置组合：读提交 + `binlog_format=row`

## 思考题

- ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-20-2.png)
  - B 和 C 都会进入锁等待状态
- 原因是什么
  - desc，向右扫描变成向左扫描
  - 前开后闭没变
  - 加锁范围
    - (20, 25) (15, 20] (5, 10]

## 评论区

- MySQL 里单引号双引号一样
- <= 是间隙锁还是行锁？
  - 找第一个值是，按等值，找下一个值，按范围查找
