---
title: 14｜count(*) 这么慢，我该怎么办？
tags:
  - MySQL
createdAt: 2023-08-17T14:31:33+08:00
updatedAt: 2023-08-17T14:31:33+08:00
---

## `count(*)` 的实现方式

- MyISAM 引擎把一个表的总行数存在磁盘上，执行时直接返回这个数
- InnoDB 引擎每次都需要把数据一行行地从引擎里面读出来，累计行数
- 以上都是在说没有过滤条件的 `count(*)
- count 是一行行读数据，是一致性读（快照读），不加锁

## 其他计数方式

- 在数据库保存计数
  - 新建一个表专门用于计数
  - 全部用 InnoDB 引擎
  - 在修改计数时使用事务
- `show table status` 命令：输出结果有一个 `TABLE_ROWS` 用于显示这个表当前行数，执行很快，但这个结果是采样估算的（误差可能达到 40% 到 50%）
- 用缓存系统保存计数
  - 比如用 `Redis`
  - 将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。
    - 两个系统间存在数据不一致的时刻

## 不同的 Count 用法（InnoDB）

- `count()` 是一个聚合函数，对于返回的结果集，一行行地判断，如果 `count` 函数的参数不是 `NULL`，累计值就加 1，否则不加。最后返回累计值。
- `count(*)`、`count(主键 id)` 和 `count(1)` 都表示返回满足条件的结果集的总行数；而 `count(字段）` 则表示返回满足条件的数据行里面，参数“字段”不为 `NULL` 的总个数。
- 分析性能差别的时候的原则
  1. server 层要什么就给什么；
  2. InnoDB 只给必要的值；
  3. 现在的优化器只优化了 `count(*)` 的语义为“取行数”，其他“显而易见”的优化并没有做。
    - `count(主键 id)`：遍历整张表，把每一行的 id 值都取出来，返回给 server 层，server 层拿到后判断是不可能为空的，就按行累加。
    - `count(1)`：遍历整张表，但不取值，server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
    - `count(字段)`
      1. 如果这个“字段”是定义为 `not null` 的话，一行行地从记录里面读出这个字段，判断不能为 `null`，按行累加；
      2. 如果这个“字段”定义`允许为 null`，那么执行的时候，判断到有可能是 `null`，还要把值取出来再判断一下，不是 `null` 才累加。
    - `count(*)`：例外，并不会把全部字段取出来，而是专门做了优化，不取值。`count(*)` 肯定不是 null，按行累加。
      - MySQL 版本 >= 5.5
    - 效率：`count(*)` ≈ `count(1)` > `count(主键 id)` > `count(字段)`

## 思考题

- 在刚刚讨论的方案中，我们用了事务来确保计数准确。由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？
  - 应该先插入记录再更新计数表
  - 因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少了事务之间的锁等待，提升了并发度。
