---

title: 01｜基础架构：一条 SQL 查询语句是如何执行的？
tags:
- MySQL
createdAt: 2023-05-17T09:36:32+08:00

---

## MySQL 的逻辑链接架构图

![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/mysql45-01-1.png)

## 1. 客户端连接数据库

- `wait_timeout` 参数控制连接器长时间没操作自动断开的时间
- 只有新建的连接才会使用新的权限设置
- 尽量使用长连接
  - 使用长连接的问题：可能内存疯涨，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面，在连接断开的时候才释放
  - 两个解决方案
    1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，主动断开连接，之后要查询再重连
    2. MySQL 5.7 或更新版本，可以在执行一个比较大的操作后，执行 `mysql_reset_connection` 重新初始化连接资源
        - 这个过程不需要重连和重新做权限验证，会将连接恢复到刚刚创建完时的状态

## 2. 查询缓存

- 建议不使用查询缓存，弊大于利
  - 对一个表的更新，表上所有的查询缓存都会被清空
  - 设置 `query_cache_type = DEMAND`，对于默认的 SQL 语句都不使用查询缓存，用 SQL_CACHE 显示置顶要使用查询缓存的语句 `select SQL_CACHE * from T`;
- ⚠️ MySQL 8.0 版本删除此功能

## 3. 分析器

1. 词法分析
2. 语法分析
    - 关注紧接“use near”的内容

## 4. 优化器

- 决定使用哪个索引
- 决定各个表的连接顺序
- 后面的文章会单独展开说明优化器的内容

## 5. 执行器

- 判断执行权限
- 根据表的引擎定义，使用引擎提供的接口
- 关于慢查询日志中的 `rows_examined` 字段
  - 执行器每次调用引擎获取数据行的时候累加
  - 跟引擎扫描行数并不是完全相同的
    - 可能执行器调用一次，引擎内部扫描了多行
  - 后面有实战文章单独展开讲存储引擎的内部机制

## 思考题

- 如果表 T 中没有字段 k，而你执行了这个语句 `select * from T where k=1`, 那肯定是会报“不存在这个列”的错误：“Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？
  - 分析器
