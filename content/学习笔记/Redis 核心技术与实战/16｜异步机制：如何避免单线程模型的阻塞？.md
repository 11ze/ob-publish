---

title: 16｜异步机制：如何避免单线程模型的阻塞？
tags:
- Redis
- mindmap-plugin: basic
createdAt: 2023-05-22T21:21:08+08:00

---

- 4 类交互对象和具体的操作之间的关系
  - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/redis-16-1.png)

- 和客户端交互时的阻塞点

  - 1. 集合的全量查询和聚合操作
  - 2. 删除 bigkey
  - 3. 清空数据库

- 和磁盘交互时的阻塞点

  - 4. 同步写 AOF 日志

- 主从节点交互时的阻塞点

  - 5. 加载 RDB 文件

    - 从库接收 RDB 文件后会清空当前数据库
    - 然后加载 RDB 到内存，文件越大越慢

- 切片集群实例交互时的阻塞点

  - 6. 使用 Redis Cluster 方案，并迁移 bigkey

    - Redis Cluster 方案使用了同步迁移
    - 当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程

- 可以异步操作的阻塞点：2、3、4
- 如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作

  - 客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作
  - 读操作是典型的关键路径操作

- 异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供了新的命令来执行这两个操作

  - 键值对删除：当集合类型中有大量元素（百万或千万级别）需要删除时，使用 UNLINK 命令
  - 清空数据库：在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项

- 小建议

  - 4.0 之前删除 bigkey：先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除
  - 集合的全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算
  - 从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载

- lazy-free（惰性删除）

  - 1. 4.0 新增功能，默认关闭
  - 2. 4 个控制选项

    - a) lazyfree-lazy-expire：key 在过期删除时尝试异步释放内存
    - b) lazyfree-lazy-eviction：内存达到 maxmemory 并设置了淘汰策略时尝试异步释放内存
    - c) lazyfree-lazy-server-del：执行 RENAME/MOVE 等命令或需要覆盖一个 key 时，删除旧 key 尝试异步释放内存
    - d) replica-lazy-flush：主从全量同步，从库清空数据库时异步释放内存

  - 3. 即使开启了lazy-free，如果直接使用 DEL 命令还是会同步删除 key，只有使用 UNLINK 命令才可能会异步删除 key
  - 4. 最关键的一点，上面提到开启 lazy-free 的场景，除了 d）replica-lazy-flush，其他情况都只是 *可能* 去异步释放 key 的内存，并不是每次必定异步释放内存的
  - 真正异步释放内存的情况：与 key 的类型、编码方式、元素数量都有关系

    - a) 当 Hash/Set 底层采用哈希表存储（非 ziplist/int 编码存储）时，并且元素数量超过64个
    - b) 当 ZSet 底层采用跳表存储（非 ziplist 编码存储）时，并且元素数量超过64个
    - c) 当 List 链表节点数量超过 64 个（注意，不是元素数量，而是链表节点的数量，List 的实现是在每个节点包含了若干个元素的数据，这些元素采用 ziplist 存储）
    - 其他情况一律还是在主线程操作
