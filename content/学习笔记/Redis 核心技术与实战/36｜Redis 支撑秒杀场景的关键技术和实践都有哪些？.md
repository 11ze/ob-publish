---

title: 36｜Redis 支撑秒杀场景的关键技术和实践都有哪些？
tags:
- Redis
- mindmap-plugin: basic
createdAt: 2023-05-24T21:23:19+08:00

---

- 特征

  - 1. 瞬时并发访问量非常高
  - 2. 读多写少

- 秒杀场景的所有环节

  - 活动前

    - 不需要 Redis
    - 尽量把商品详情页页面元素静态化，然后使用前端 CDN 或浏览器缓存把元素缓存起来

  - 活动开始

    - Redis 参与的两个环节
      - ![image.png](https://cdn.jsdelivr.net/gh/11ze/static/images/redis-36-1.png)

    - 使用 Redis 保存库存量，不交给数据库做库存扣减

      - 如果把库存扣减在数据库执行，会带来两个问题
      - 1. 额外的开销。Redis 中保存了库存量，而库存量的最新值又是数据库在维护，所以数据库更新后，还需要和 Redis 进行同步，这个过程增加了额外的操作逻辑，也带来了额外的开销。
      - 2. 数据库处理较慢，不能及时更新库存余量，导致大量库存查验请求读取到 Redis 中的旧库存值，此时会出现下单数量大于实际的库存量，导致超售

    - 最后在数据库处理订单

      - 订单处理涉及支付、商品出库、物流等多个关联操作，要保证处理的事务性，需要在数据库中完成
      - 订单处理时的请求压力已经不大

  - 活动结束后

    - 不需要 Redis

- 库存数据保存方式

  - 使用切片集群，用不同实例保存不同商品的库存
  - 每个商品用一个 Hash 类型的键值对保存

    - key: itemID
    - value: {total: N, ordered: M}

  - 先用 CRC 算法计算不同商品 key 对应的 Slot，然后，在分配 Slot 和实例对应关系时，才能把不同秒杀商品对应的 Slot 分配到不同实例上保存

- 基于原子操作支撑秒杀场景

  - 使用 Lua 脚本执行库存查验和库存扣减操作，保证原子性

- 基于分布式锁来支撑秒杀场景

  - 先让客户端向 Redis 申请分布式锁，只有拿到锁的客户端才能执行库存查验和库存扣减
  - 这样可以在争夺分布式锁时过滤掉大量的秒杀请求
  - 库存查验和扣减也不用使用原子操作了，因为多个并发客户端只有一个客户端能够拿到锁，已经保证了客户端并发访问的互斥性

- 建议

  - 使用切片集群中的不同实例，分别保存分布式锁和商品库存信息

    - 减轻保存库存信息的实例的压力

  - 把秒杀商品的库存信息用单独的实例保存，不要和日常业务系统的数据保存在同一个实例上，避免干扰业务系统的正常运行

- 其他环节

  - 1. 前端静态页面的设计
  - 2. 请求拦截和流控

    - 使用黑名单禁止恶意 IP 进行访问；限流；等等

  - 3. 库存信息过期时间处理

    - Redis 中的库存信息 = 数据库的缓存，不给 Reids 的库存信息设置过期时间

  - 4. 数据库订单异常处理

    - 增加订单重试功能
