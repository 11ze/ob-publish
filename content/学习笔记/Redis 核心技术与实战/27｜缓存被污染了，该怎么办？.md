---

title: 27｜缓存被污染了，该怎么办？
tags:
- Redis
- mindmap-plugin: basic
createdAt: 2023-05-23T21:03:11+08:00

---

- 缓存污染

  - 留存在缓存中的数据，实际不会被再次访问了，但是又占据了缓存空间。
  - 如果这样的数据体量很大，甚至占满了缓存，每次有新数据写入缓存时，还需要把这些数据逐步淘汰出缓存，就会增加缓存操作的时间开销。

- 解决

  - volatile-ttl 策略：设置时需明确知道数据被再次访问的情况时
  - LRU 缓存策略：只看数据的访问时间，可能在对大量数据进行一次全体读取后没能及时删除缓存数据
  - LFU 缓存策略

    - 在 LRU 策略基础上，为每个数据增加一个计数器，用于统计数据的访问次数
    - 淘汰数据时，首先根据数据的访问次数进行筛选
    - 如果访问次数相同，则比较两个数据的访问时效性

  - LFU 与 LRU 实现的异同

    - LRU 使用 24bit 大小的 lru 字段
    - LFU 使用前 16bit 作为 ldt 值，表示数据的访问时间戳
    - 后 8bit 作为 counter 值，表示数据的访问次数（最大值 255）

  - LFU 的计数规则

    - 增加机制

      - 1. 每当数据被访问一次
      - 2. 用计数器当前值 * 配置项 lfu_log_factor，再加 1，再取倒数，得到一个 p 值
      - 3. 把 p 值和一个取值范围再（0，1）间的随机数 r 值比大小
      - 4. p 值大于 r 值时，计数器加 1
      - 计数器默认值为 5（由代码中的 LFU_INIT_VAL 常量设置），避免数据刚写入就被淘汰
      - 一般将 lfu_log_factor 设置为 10 就可以对百、千、十万级别的访问次数做明显区分

    - 衰减机制

      - 1. 假设设置 lfu_decay_time 取值为 1
      - 2. 如果数据在 N 分钟没有被访问
      - 3. 访问次数减 N
      - 如果业务应用中有短时高频访问的数据，建议把 lfu_decay_time 设置为 1

  - 使用 LFU 策略后，缓存还会被污染，因为存在参数设置不合理的问题

    - 如设置太大导致衰减过慢
    - 或者一个数据只在短时间内被高频访问，也有可能滞留在缓存中
