---

title: 30｜如何使用 Redis 实现分布式锁？
tags:
- Redis
- mindmap-plugin: basic
createdAt: 2023-05-23T21:12:16+08:00

---

- 单机版

  - 用一个变量表示：0 没有线程获取到锁；1 有线程获取到锁

- 分布式锁

  - 锁变量需要有一个共享存储系统来维护
  - 基于单个节点

    - 加锁

      - 1. SET lock_key unique_value NX [EX seconds | PX milliseconds]

        - key 不存在时会被创建
        - key 存在，不做任何赋值操作
        - 例：SET lock_key unique_value NX PX 10000

      - 2. 加锁成功后设置有效期
      - 3. 将上述操作写进 Lua 脚本

    - 释放锁

      - 1. 比较锁变量的 unique_value 是否相等，避免误释放

        - unique_value：随机值，唯一，和其他客户端作区分

      - 2. 使用 Lua 脚本保证原子性

        - 例：redis-cli --eval unlock.script lock_key, unique_value

  - 基于多个节点

    - Redis 的开发者 Antirez 提出了分布式锁算法 Redlock

      - 基本思路：让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，就认为加锁成功，否则加锁失败
      - 需要避免机器始终发生跳跃，需要运维来保证，否则可能会导致 Redlock 失效
      - 通常是 5 个 Redis（都是 Master） 节点
      - 能不用尽量不用

    - 1. 客户端获取当前时间
    - 2. 客户端按顺序依次向 N 个 Redis 实例执行加锁操作

      - 和在单实例上执行的加锁操作一样
      - 设置超时时间：远远小于锁的有效时间，如几十毫秒

    - 3. 完成和所有 Redis 实例的加锁操作后，客户端计算整个加锁过程的总耗时，满足两个条件才算成功

      - a. 客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁
      - b. 客户端获取锁的总耗时没有超过锁的有效时间
      - 未满足条件时，向所有实例发起释放锁的操作

        - 即使是加锁失败的实例

    - 4 重新计算这把锁的有效时间：最初有效时间 - 客户端获取锁的总耗时
    - 5. 如果锁的有效时间已经不够完成共享数据的操作，可以主动释放锁，避免没完成数据操作，锁就过期的情况

  - 如果为了效率，可以使用单节点，缺点是允许锁偶尔失效，优点是简单效率高
  - 业务对结果要求非常严格，为了正确性，使用 Redlock，缺点是比较重，部署成本高

- 这篇文章详细介绍了争论 Redlock 算法涉及的可靠性的细节，以及 Redis 分布式锁在各种异常情况是否安全的分析，收益会非常大：http://zhangtielei.com/posts/blog-redlock-reasoning.html

  - 基于 ZooKeeper 的分布式锁

    - 不是唯一的实现方式
    - 1. 客户端尝试创建一个 znode 节点，比如 /lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode 已存在），获取锁失败
    - 2. 持有锁的客户端访问共享资源完成后，将 znode 删掉，这样其它客户端接下来就能来获取锁了
    - 3. znode 应该被创建成 ephemeral 的。这是 znode 的一个特性，它保证如果创建 znode 的那个客户端崩溃了，那么相应的 znode 会被自动删除。这保证了锁一定会被释放
    - ZooKeeper 一个很有用的特性是 watch 机制。这个机制可以这样来使用，比如当客户端试图创建 /lock 的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当 /lock 节点被删除的时候，ZooKeeper 通过 watch 机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。这样的特性 Redlock 就无法实现

  - 和 Redlock 的不同

    - 优点

      - 1. 在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于 Redis 的锁对于有效时间（lock validity time）到底设置多长的两难问题。实际上，基于 ZooKeeper 的锁是依靠 Session（心跳）来维持锁的持有状态的，而 Redis 不支持 Session
      - 2. 基于 ZooKeeper 的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活

    - 缺点

      - 3. 性能不如 Redis

  - 此实现并不是最优的，会引发“herd effect”（羊群效应），降低获取锁的性能
  - 一个更好的实现

    - http://zookeeper.apache.org/doc/r3.4.9/recipes.html#sc_recipes_Locks
