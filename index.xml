<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>🫧 11ze</title>
      <link>https://wangze.tech</link>
      <description>Last 10 notes on 🫧 11ze</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>12｜有一亿个 keys 要统计，应该用哪种集合？</title>
    <link>https://wangze.tech/12%EF%BD%9C%E6%9C%89%E4%B8%80%E4%BA%BF%E4%B8%AA-keys-%E8%A6%81%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9B%86%E5%90%88%EF%BC%9F</link>
    <guid>https://wangze.tech/12%EF%BD%9C%E6%9C%89%E4%B8%80%E4%BA%BF%E4%B8%AA-keys-%E8%A6%81%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9B%86%E5%90%88%EF%BC%9F</guid>
    <description>数据类型汇总表格 聚合统计 统计多个集合元素的聚合结果，包括： 统计多个集合的共有元素（交集统计） 把两个集合相比，统计其中一个集合独有的元素（差集统计） 统计多个集合的所有元素（并集统计） 使用 Set 并集：SUNIONSTORE user:new user:id user:id:20200803 差集：SDIFFSTORE user:new user:id:20200804 user:id 交集：SINTERSTORE user:id:rem user:id:20200803 user:id:20200804 计算复杂度较高，数据量较大时会导致 Redis 实例阻塞 三个命令都会生成新 key，但从库一般是 readonly（不建议开写），想在从库操作需使用 SUNION、SDIFF、SINTER，这些命令可以计算出结果，但不会生成新 key 可以从主从集群中选择一个从库专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了 排序统计 使用有序集合：List、Sorted Set List 是按照元素进入 List 的顺序进行排序，而 Sorted Set 可以根据元素的权重来排序 数据更新频繁或需要分页显示，优先考虑使用 Sorted Set 二值状态统计 指集合元素的取值就只有 0 和 1 两种 Bitmap 对多个以日期为 key，位值为每个学生签到情况的 Bitmap，执行按位与操作可以统计出连续签到的学生数量 亦或者 uid:sign:3000:202008 2 1 可以统计学生在某段时间的签到情况 优势：节省内存空间 基数统计 指统计一个集合中不重复的元素个数，如统计网页的 UV Set 和 Hash 消耗比较多的内存空间 HyperLogLog 用于统计基数的数据类型 会用就行 标准误算率：0.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>13｜GEO 是什么？还可以定义新的数据类型吗？</title>
    <link>https://wangze.tech/13%EF%BD%9CGEO-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F</link>
    <guid>https://wangze.tech/13%EF%BD%9CGEO-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F</guid>
    <description> LBS：位置信息服务（Location-Based Service） GEO：数据类型 底层数据结构：Sorted Set GeoHash 编码方法 基本原理：二分区间，区间编码 对经纬度分别编码，再组合 经度范围 [-180, 180]，纬度范围 [-90, 90] 做 N 次二分区操作，N 可以自定义 根据经纬度值落在左还是右分区得到 1 位编码值 重复 N 次，得到一个 N bit 的数 例：116.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>14｜如何在 Redis 中保存时间序列数据？</title>
    <link>https://wangze.tech/14%EF%BD%9C%E5%A6%82%E4%BD%95%E5%9C%A8-Redis-%E4%B8%AD%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%EF%BC%9F</link>
    <guid>https://wangze.tech/14%EF%BD%9C%E5%A6%82%E4%BD%95%E5%9C%A8-Redis-%E4%B8%AD%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%EF%BC%9F</guid>
    <description> 要求 写要快 查询模式多 一、同时使用 Hash 和 Sorted Set {1: a, 2: b, 3: c} + setKey: {1: a, 2: b, 3: c} Hash 负责单键查询，Sorted Set 负责范围查询 多个写操作的原子性 MULTI 命令：表示一系列原子性操作的开始 EXEC 命令：表示一系列原子性操作的结束 建议客户端使用 pipeline，一次性批量发送命令给服务端，减少网络 IO 次数 聚合计算需要借助客户端，数据量大时比较耗资源 二、RedisTimeSeries 是专门为时间序列数据访问设计的扩展模块 支持聚合计算 可以按标签属性过滤查询数据集合 不属于内建功能模块，需要先把它的源码单独编译成动态链接库 redistimeseries.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>15｜消息队列的考验：Redis 有哪些解决方案？</title>
    <link>https://wangze.tech/15%EF%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E8%80%83%E9%AA%8C%EF%BC%9ARedis-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F</link>
    <guid>https://wangze.tech/15%EF%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E8%80%83%E9%AA%8C%EF%BC%9ARedis-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F</guid>
    <description> 消息队列的三大需求：消息保序、重复消息处理、消息可靠性保证 List 支持阻塞获取数据 不支持消费组 Stream Redis 5.0 之后专门为消息队列设计的数据类型 不同消费组的消费者可以消费同一个消息 同一消费组的消费者不消费同一消息 自动生成全局唯一 ID 两者比较 ⚠️ 不能丢数据的场景应该采用专业的队列中间件：Kafka + Zookeeper、RabbitMQ .</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>16｜异步机制：如何避免单线程模型的阻塞？</title>
    <link>https://wangze.tech/16%EF%BD%9C%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E%EF%BC%9F</link>
    <guid>https://wangze.tech/16%EF%BD%9C%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E%EF%BC%9F</guid>
    <description> 4 类交互对象和具体的操作之间的关系 和客户端交互时的阻塞点 集合的全量查询和聚合操作 删除 bigkey 清空数据库 和磁盘交互时的阻塞点 同步写 AOF 日志 主从节点交互时的阻塞点 加载 RDB 文件 从库接收 RDB 文件后会清空当前数据库 然后加载 RDB 到内存，文件越大越慢 切片集群实例交互时的阻塞点 使用 Redis Cluster 方案，并迁移 bigkey Redis Cluster 方案使用了同步迁移 当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程 可以异步操作的阻塞点：2、3、4 如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作 客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作 读操作是典型的关键路径操作 异步的键值对删除和数据库清空操作是 Redis 4.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>17｜为什么 CPU 结构也会影响 Redis 的性能？</title>
    <link>https://wangze.tech/17%EF%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88-CPU-%E7%BB%93%E6%9E%84%E4%B9%9F%E4%BC%9A%E5%BD%B1%E5%93%8D-Redis-%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F</link>
    <guid>https://wangze.tech/17%EF%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88-CPU-%E7%BB%93%E6%9E%84%E4%B9%9F%E4%BC%9A%E5%BD%B1%E5%93%8D-Redis-%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F</guid>
    <description>NUMA 架构（Non-Uniform Memory Access 非统一内存访问架构） 图 第一步 第二步 文字描述 多个 CPU 处理器（多 CPU Socket） 每个都有自己的： 多个物理核（包括 L1、L2 缓存） 每个物理核私有的 L1、L2 大小受限于处理器的制造基数，KB 级别大小 缓存应用程序访问最频繁的指令和数据 L3 缓存 多个物理核共用 几 MB 到几十 MB 大小 在 L1、L2 缓存中没有数据缓存时被访问，尽可能避免访问内存 连接的内存 不同处理器间通过总线连接 CPU 架构对应用程序运行的影响 L1、L2 缓存中的指令和数据的访问速度很快，充分利用 L1、L2 缓存，可以有效缩短应用程序的执行时间 在 NUMA 架构下，如果应用程序从一个 Socket 上调度到另一个 Socket 上，就可能会出现远端内存访问的情况，这会直接增加应用程序的执行时间 ECS 主机提供的 vCPU 虚拟核，一般对应一个物理核心上的一个超线程，这是因为底层服务器一般会开启超线程 通常，一个物理核心会对应 2 个超线程，每个超线程对应一个 vCPU 多个 vCPU 一般在同一个 NUMA 节点上 如果希望减少 CPU 超线程对性能的影响，可以通过阿里云 SDK 的选项关闭超线程 同一个物理核的逻辑核会共享使用 L1、L2 缓存 CPU 多核对 Redis 性能的影响 99% 尾延迟：99% 的请求延迟小于的值 context switch：一个线程先在一个 CPU 核上运行，之后又切换到另一个 CPU 核上运行，这时就会发生 context switch 此时 Redis 主线程的运行时信息需要被加载到另一个 CPU 核上 CPU 的 NUMA 架构对 Redis 性能的影响 把操作系统的网络中断处理程序和 CPU 核绑定 网络中断处理程序 操作系统内核中用来处理网卡中断事件、把数据从内核的缓冲区拷贝到应用程序缓冲区的程序。 当网卡接收到数据后，会触发网卡中断，用来通知操作系统内核进行数据处理。 避免网络中断处理程序在不同核上来回调度执行，能有效提升 Redis 的网络处理性能 为了避免 Redis 跨 CPU Socket 访问网络数据，最好把网络中断程序和 Redis 实例绑在同一个 CPU Socket 的不同核上 在 CPU 的 NUMA 架构下，对 CPU 核的编号规则，并不是先把一个 CPU Socket 中的所有逻辑核编完，再对下一个 CPU Socket 中的逻辑核编码，而是先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号 执行 lscpu 命令 查看核的编号 绑核的风险和解决方案 风险 把 Redis 实例绑到一个 CPU 逻辑核上时，会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加 解决方案 一个 Redis 实例对应绑一个物理核 将实例绑到一个物理核上的所有逻辑核 Redis 的主线程、子进程和后台线程可以共享使用一个物理核上的两个逻辑核，缓解 CPU 资源竞争 优化 Redis 源码 避免切换核带来的性能影响 让子进程、后台线程核主线程不在同一个核上运行，避免 CPU 资源竞争 Redis 6.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>18｜波动的响应延迟：如何应对变慢的 Redis？（上）</title>
    <link>https://wangze.tech/18%EF%BD%9C%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89</link>
    <guid>https://wangze.tech/18%EF%BD%9C%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89</guid>
    <description> Redis 真的变慢了吗？ 查看 Redis 的响应延迟 redis-cli —latency -h host -p port 基于当前环境下的 Redis 基线性能做判断 基线性能：一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定 redis-cli 命令提供的 -intrinsic-latency 选项可以用来检测和统计测试期间的最大延迟，这个延迟可以作为基线性能 要在服务器端运行，只考虑服务器端软硬件环境的影响 Redis 运行时延迟是其基线性能的 2 倍及以上表示 Redis 变慢了 如何应对 Redis 变慢？ 从慢查询命令开始排查，并且根据业务需求替换慢查询命令 在客户端进行排序、交集、并集操作，不使用 SORT、SUNION、SINTER 命令，避免拖慢 Redis 实例 排查过期 key 的时间设置，并根据实际使用需求，设置不同的过期时间，给过期时间加上随机数 在 Redis 中，还有哪些其他命令可以代替 KEYS 命令，实现同样的功能呢？这些命令的复杂度会导致 Redis 变慢吗？ 使用 SCAN 命令获取整个实例所有 key SCAN cursorCOUNTcount 一次最多返回 count 个数的 key，数量不会超过 count 不会漏 key SCAN 采用高位进位法的方式遍历哈希桶，当哈希表扩容后，通过此算法遍历，旧哈希表中的数据映射到新哈希表，依旧会保留原来的先后顺序，此时不会遗漏也不会重复 key 可能会返回重复的 key 与 Redis 的 Rehash 机制有关，哈希表缩容时，已经遍历过的哈希表会映射到新哈希表没有遍历到的位置 Redis 针对 Hash/Set/Sorted Set 提供了 HSCAN/SSCAN/ZSCAN 命令，用于遍历一个 key 中的所有元素，建议在获取一个 bigkey 的所有数据时使用，避免发生阻塞风险 key 的元素较少时，底层采用 intset/ziplist 方式存储，会无视命令的 count 参数 Redis 4.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>19｜波动的响应延迟：如何应对变慢的 Redis？（下）</title>
    <link>https://wangze.tech/19%EF%BD%9C%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89</link>
    <guid>https://wangze.tech/19%EF%BD%9C%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89</guid>
    <description> 文件系统：AOF 模式 AOF 重写会对磁盘进行大量 IO 操作，fsync 需要等到数据写到磁盘后才能返回 everysec 时，使用后台子线程调用 fsync 写日志 虽然 fsync 由后台子线程负责执行，但主线程会监控 fsync 的执行进度 上次 fsync 未执行完时，下次 fsync 会被阻塞 always 时，主线程中调用 fsync 避免使用操作系统的 swap 增加机器的内存 使用 Redis 集群 查看 Redis 进程的 swap 使用情况 redis-cli info | grep process_id cd /proc/{process_id} cat smaps | egrep ’^(Swap|Size)’ 操作系统：内存大页 写时复制：一旦数据要被修改，Redis 不会直接修改内存中的数据，会先拷贝一份再进行修改 常规内存机制只用拷贝 4KB，内存大页需要拷贝 2MB 关闭即可 cat /sys/kernel/mm/transparent_hugepage/enabled 查看是否 always 打开 关闭：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled Checklist 获取 Redis 实例在当前环境下的基线性能 是否用了慢查询命令？使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做 是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除 是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>20｜删除数据后，为什么内存占用率还是很高？</title>
    <link>https://wangze.tech/20%EF%BD%9C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98%EF%BC%9F</link>
    <guid>https://wangze.tech/20%EF%BD%9C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98%EF%BC%9F</guid>
    <description> 内存碎片 现象：内存空间闲置 生成原因：操作系统的内存分配机制 + Redis 的负载特征 操作系统按固定大小分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配 当程序申请的内存最接近某个固定值时，Redis 使用的 jemalloc 会给它分配相应大小的空间 为了减少分配次数 判断是否有内存碎片 执行 INFO memory used_memory_rss：操作系统实际分配的物理内存空间，包含了碎片 used_memory：保存数据实际申请使用的空间 mem_fragmentation_ratio：当前的内存碎片率 mem_fragmentation_ratio = used_memory_rss / used_memory 经验阈值 合理情况：mem_fragmentation_ratio 大于 1 但小于 1.</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item><item>
    <title>21｜缓冲区：一个可能引发“惨案”的地方</title>
    <link>https://wangze.tech/21%EF%BD%9C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E2%80%9C%E6%83%A8%E6%A1%88%E2%80%9D%E7%9A%84%E5%9C%B0%E6%96%B9</link>
    <guid>https://wangze.tech/21%EF%BD%9C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E2%80%9C%E6%83%A8%E6%A1%88%E2%80%9D%E7%9A%84%E5%9C%B0%E6%96%B9</guid>
    <description> 客户端输入和输出缓冲区 避免客户端和服务端的请求发送和处理速度不匹配 输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端 查看输入缓冲区的内存使用情况：CLIENT LIST 命令 cmd：最新执行的命令 qbuf：输入缓冲区已经使用的大小 qbuf-free：尚未使用的大小 服务端允许为每个客户端最多暂存 1GB 的命令和数据，上限阈值在代码中设定 1GB，不可变（输入缓冲区） 输出缓冲区会溢出的情况 返回 bigkey 的大量结果 执行了 MONITOR 命令：检测 Redis 执行 缓冲区大小设置不合理 大小上限阈值 持续写入数据的数量上限阈值 普通客户端通用设置 - 配置文件：client-output-buffer-limit normal 0 0 0 订阅客户端 - 配置文件：client-output-buffer-limit pubsub 8mb 2mb 60 主从集群中的缓冲区 复制缓冲区的溢出问题 在主节点执行：config set client-output-buffer-limit slave 512mb 128mb 60 进行设置 slave 表示该配置项是针对复制缓冲区的 每个从节点各一个 复制积压缓冲区（repl_backlog_buffer）的溢出问题 导致数据丢失 其他缓冲区导致网络连接关闭 应用程序中使用的客户端需要使用缓冲区时 在 buffer 中拼装好数据，一次性由操作系统发送给服务端 使用 Pipeline 批量发送命令到服务端 主库上的从库输出缓冲区 slave-client-output-buffer 不计算在 Redis 使用的总内存中，不会超过 maxmemory 导致淘汰数据，只有普通和订阅客户端的输出缓冲区内存增长，超过 maxmemory 时，才会淘汰数据 .</description>
    <pubDate>Mon, 05 Feb 2024 15:00:44 GMT</pubDate>
  </item>
    </channel>
  </rss>