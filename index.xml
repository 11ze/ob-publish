<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>🫧 11ze</title>
      <link>https://wangze.tech</link>
      <description>Last 10 notes on 🫧 11ze</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>英语</title>
    <link>https:/wangze.tech/%E8%8B%B1%E8%AF%AD</link>
    <guid>https:/wangze.tech/%E8%8B%B1%E8%AF%AD</guid>
    <description> GitHub - xiaolai/everyone-can-use-english: 人人都能用英语 Think in English 英语学习唯一正确方法具体实践 - 哔哩哔哩 背单词 BigShot英语 - 哔哩哔哩视频 .</description>
    <pubDate>Fri, 29 Dec 2023 15:00:53 GMT</pubDate>
  </item><item>
    <title>44｜答疑文章（三）：说一说这些好问题</title>
    <link>https:/wangze.tech/44%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98</link>
    <guid>https:/wangze.tech/44%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98</guid>
    <description>join 的写法 § 在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。 where a.f2=b.f2 就表示，查询结果里面不会包含 b.f2 是 NULL 的行 使用 left join 时，左边的表不一定是驱动表。 如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面 distinct 和 group by 的性能 § 如果只需要去重，不需要执行聚合函数，distinct 和 group by 哪种效率高一些呢？ 没有索引时一样 select a,count(*) from t group by a order by null; 这条语句的逻辑是：按照字段 a 分组，计算每组的 a 出现的次数。在这个结果里，由于做的是聚合计算，相同的 a 只出现一次。37 章有关于 group by 的相关内容 .</description>
    <pubDate>Fri, 29 Dec 2023 15:00:52 GMT</pubDate>
  </item><item>
    <title>30｜答疑文章（二）：用动态的观点看加锁</title>
    <link>https:/wangze.tech/30%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81</link>
    <guid>https:/wangze.tech/30%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81</guid>
    <description>下面的讨论基于此表 CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); show engine innodb status 命令输出的信息中，LATESTADETECTED DEADLOCK 记录了最后一次死锁信息 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问； 在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lock in share mode 语句，来回滚。 所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。 思考题 § 空表的间隙的定义 一个空表只有一个间隙 比如执行：begin; select * from t where id&gt;1 for update; 加锁范围：next_key lock (-∞, supremum] 评论区 § 删除数据，导致锁扩大的描述：“因此，我们就知道了，由于 delete 操作把 id=10 这一行删掉了，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。”我觉得这个提到的(5, 10) 和 (10, 15)两个间隙会让人有点误解，实际上在删除之前间隙锁只有一个(10, 15)，删除了数据之后，导致间隙锁左侧扩张成了5，间隙锁成为了(5, 15)。 .</description>
    <pubDate>Fri, 29 Dec 2023 15:00:52 GMT</pubDate>
  </item><item>
    <title>开发环境</title>
    <link>https:/wangze.tech/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83</link>
    <guid>https:/wangze.tech/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83</guid>
    <description>设备 § M1 MacBook Pro 14 先更新系统 Homebrew § 官网安装 brew tap homebrew/cask-drivers brew tap homebrew/cask-fonts brew tap homebrew/cask-versions brew tap buo/cask-upgrade brew tap mongodb/brew brew install git git-lfs git-flow git config --global core.</description>
    <pubDate>Fri, 29 Dec 2023 09:38:09 GMT</pubDate>
  </item><item>
    <title>添加评论区</title>
    <link>https:/wangze.tech/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8C%BA</link>
    <guid>https:/wangze.tech/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8C%BA</guid>
    <description> 适用于 Quartz v4 到 giscus 生成自己的评论区代码并复制 创建组件 quartz/components/pages/Giscus.tsx import { QuartzComponentConstructor } from &quot;.</description>
    <pubDate>Wed, 27 Dec 2023 05:29:56 GMT</pubDate>
  </item><item>
    <title>配置图床</title>
    <link>https:/wangze.tech/%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A</link>
    <guid>https:/wangze.tech/%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A</guid>
    <description> 配置步骤 在 GitHub 创建图床仓库 到个人 Settings - Developer settings 创建 Personal access token 给 PicGo 用 官网下载 PicGo 参考链接 使用 PicGo + Github + JSD 搭建免费图床 jsDelivr 指定分支：在仓库名后拼接 \@xx，如 https://cdn.</description>
    <pubDate>Wed, 27 Dec 2023 04:51:56 GMT</pubDate>
  </item><item>
    <title>Linux 安装 oh-my-zsh</title>
    <link>https:/wangze.tech/Linux-%E5%AE%89%E8%A3%85-oh-my-zsh</link>
    <guid>https:/wangze.tech/Linux-%E5%AE%89%E8%A3%85-oh-my-zsh</guid>
    <description>安装 Zsh § https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH sudo apt install zsh # 查看所有可用 shell chsh -l # 将终端默认 shell 切换到 zsh，后面要输入实际看到的 zsh 路径 chsh -s /bin/zsh # 新开一个终端确认是否切换成功 echo $SHELL 安装 Oh-my-zsh § https://ohmyz.</description>
    <pubDate>Wed, 27 Dec 2023 02:47:54 GMT</pubDate>
  </item><item>
    <title>17｜如何正确地显示随机消息？</title>
    <link>https:/wangze.tech/17%EF%BD%9C%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF%EF%BC%9F</link>
    <guid>https:/wangze.tech/17%EF%BD%9C%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF%EF%BC%9F</guid>
    <description>内存临时表 § explain 结果中 extra 包含 Using temporary，表示需要使用临时表 Using filesort 表示需要执行排序操作 比如执行 order by rand() 的时候就需要用到上面两个 随机排序完整执行流程图 pos 是数据的位置信息 对于内存表，回表过程只是简单地根据数据行的位置直接访问内存得到数据，MySQL 优化器没有多访问磁盘的顾虑，会直接选择 rowid 排序（排序的行越小越好） 学习技巧：先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论 rowid 的含义：每个引擎用来唯一标识数据行的信息 对于有主键的 InnoDB 表，rowid 是主键 ID； 对于没有主键的 InnoDB 表，rowid 是由系统生成的； MEMORY 引擎不是索引组织表。在这个例子里面，可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。 磁盘临时表 § tmp_table_size 配置限制内存表的大小，默认值 16M 如果临时表过大，就会转成磁盘临时表 当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。 对于使用磁盘临时表的 order by rand()，MySQL 5.</description>
    <pubDate>Fri, 22 Dec 2023 06:46:41 GMT</pubDate>
  </item><item>
    <title>04｜AOF 日志：宕机了，Redis 如何避免数据丢失？</title>
    <link>https:/wangze.tech/04%EF%BD%9CAOF-%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%EF%BC%9F</link>
    <guid>https:/wangze.tech/04%EF%BD%9CAOF-%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%EF%BC%9F</guid>
    <description> Redis 作为缓存使用 从数据库读取数据恢复 当需要恢复时数据库压力大、Redis 响应慢 写后日志：先执行命令把数据写入内存，再记录日志 不会阻塞当前的写操作 记录的命令没有错误 没来得及记录时，宕机会丢失数据 在主线程写，写盘压力大可能导致后续操作无法执行 日志格式示例 执行 set testkey testvalue AOF 文件（Append Only File） *3：命令有三个部分 $3：命令、键或值一共有多少字节 每个 $n 下一行跟着命令、键或值 三种写回策略 Always：同步写回 Everysec：每秒写回 优先使用，在可靠性和性能取了一个平衡 No：操作系统控制的写回 重写机制 多个操作同一个键值的命令合并为一个命令 避免重写日志过大 直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志 一个拷贝 由后台子进程 bgrewiteaof 完成，避免阻塞主线程 fork 创建 bgrewriteaof 子进程时，阻塞主线程，如果实例内存大，执行时间还会更长 共享主线程内存，主线程执行新写或修改操作时会申请新的内存空间保存新的数据，如果操作的是 bigkey，可能因为申请大空间而面临阻塞风险 两处日志 正在使用的 AOF 日志 + 新的重写日志 避免竞争文件系统的锁 减小日志大小 AOF 非阻塞重写过程 适用于读操作比较多的场景 .</description>
    <pubDate>Tue, 19 Dec 2023 15:57:56 GMT</pubDate>
  </item><item>
    <title>31｜事务机制｜Redis 能实现 ACID 属性吗？</title>
    <link>https:/wangze.tech/31%EF%BD%9C%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%EF%BD%9CRedis-%E8%83%BD%E5%AE%9E%E7%8E%B0-ACID-%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F</link>
    <guid>https:/wangze.tech/31%EF%BD%9C%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%EF%BD%9CRedis-%E8%83%BD%E5%AE%9E%E7%8E%B0-ACID-%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F</guid>
    <description>事务命令 § MULTI：开启一个事务 EXEC：提交事务，从命令队列中去除提交的操作命令，进行实际执行 DISCARD：放弃一个事务，清空命令队列 只是清空，起不到回滚的作用 WATCH：检测一个或多个键的值在事务执行期间是否发生变化，如果发生变化，那么当前事务放弃执行 Redis 的事务机制 § 可以保证一致性和隔离性，无法保证持久性（非必要） 原子性 命令语法有误时，得不到保证 不存在的命令一开始就会被记录错误 无法得到保证的原因：命令和操作的数据类型不匹配，但 Redis 实例没检查出错误并开始执行 预防建议：严格按照 Redis 的命令规范进行程序开发，并且通过 code review 确保命令的正确性 实例发生故障，且 Redis 使用了 RDB 机制 RDB 不会在事务执行时执行，也就不会记录下事务执行了一部分的结果 存在一种情况无法保证原子性：如果事务执行完成，还没执行 RDB 快照，此时发生故障，会丢失事务修改的数据 其他情况，事务都可以原子性执行 前提：执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败 开启 AOF 日志 只会有部分的事务操作被记录到 AOF 日志中 使用 redis-check-aof 工具检查 AOF 日志文件 工具会把未完成的事务操作从 AOF 日志中去除 这时再使用 AOF 恢复实例，失败的事务操作不会再被执行 事务使用建议 § 配合 Pipeline 使用 隔离性由服务端保证，此时不需要使用 WATCH WATCH 的使用场景 WATCH key，读取 key，修改 key，写回 .</description>
    <pubDate>Tue, 19 Dec 2023 15:49:56 GMT</pubDate>
  </item>
    </channel>
  </rss>