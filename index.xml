<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🪴 11ze's Garden on</title><link>https://wangze.tech/</link><description>Recent content in 🪴 11ze's Garden on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 10 May 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://wangze.tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Think in English</title><link>https://wangze.tech/Think-in-English/</link><pubDate>Tue, 30 May 2023 10:44:21 +0800</pubDate><guid>https://wangze.tech/Think-in-English/</guid><description>How to THINK in English | No More Translating in Your Head! - YouTube
Introduction If you’re translating in your head, then you know that that’s a frustrating way to speak English.</description></item><item><title>应用已损坏</title><link>https://wangze.tech/%E5%BA%94%E7%94%A8%E5%B7%B2%E6%8D%9F%E5%9D%8F/</link><pubDate>Fri, 26 May 2023 15:58:50 +0800</pubDate><guid>https://wangze.tech/%E5%BA%94%E7%94%A8%E5%B7%B2%E6%8D%9F%E5%9D%8F/</guid><description> 安装后打开提示已损坏时执行命令：sudo xattr -d com.apple.quarantine &amp;quot;/Applications/{appName}.app&amp;quot;</description></item><item><title>从微博的 Redis 实践中，我们可以学到哪些经验？</title><link>https://wangze.tech/%E4%BB%8E%E5%BE%AE%E5%8D%9A%E7%9A%84-Redis-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AD%A6%E5%88%B0%E5%93%AA%E4%BA%9B%E7%BB%8F%E9%AA%8C/</link><pubDate>Wed, 24 May 2023 21:54:19 +0800</pubDate><guid>https://wangze.tech/%E4%BB%8E%E5%BE%AE%E5%8D%9A%E7%9A%84-Redis-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AD%A6%E5%88%B0%E5%93%AA%E4%BA%9B%E7%BB%8F%E9%AA%8C/</guid><description>微博对 Redis 的技术需求
能够提供高性能、高并发的读写访问，保证读写延迟低 能够支持大容量存储 可以灵活扩展，对于不同业务能进行快速扩容 对 Redis 的基本改进</description></item><item><title>Redis 的使用规范小建议</title><link>https://wangze.tech/Redis-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83%E5%B0%8F%E5%BB%BA%E8%AE%AE/</link><pubDate>Wed, 24 May 2023 21:51:12 +0800</pubDate><guid>https://wangze.tech/Redis-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83%E5%B0%8F%E5%BB%BA%E8%AE%AE/</guid><description>键值对使用规范
通过命名区分不同业务数据 SELECT 命令进行数据库切换相当于增加一个额外的操作
业务名缩写作为 key 的前缀
对于业务名或业务数据名，可以使用相应的英文单词的首字母表示，（比如 user 用 u 表示，message 用 m），或者是用缩写表示（例如 unique visitor 使用 uv）。 避免使用 bigkey 尽量把集合类型的元素个数控制在 1 万以下 控制 String 类型数据的大小不超过 10KB 使用高效序列化方法和压缩方法减小 value 的大小 使用整数对象共享池 如果一个键值对中有 0 到 9999 范围的整数，Redis 会服用共享池中的整数对象</description></item><item><title>Redis 有哪些好用的运维工具？</title><link>https://wangze.tech/Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 24 May 2023 21:46:32 +0800</pubDate><guid>https://wangze.tech/Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/</guid><description>最基本的监控命令：INFO 命令
INFO 命令的返回信息
重点关注 stat、commandstat、cpu、memory 参数的返回结果
通过 persistence 参数的返回结果查看 RDB 或者 AOF 的执行情况</description></item><item><title>Redis 客户端如何与服务端交换命令和数据？</title><link>https://wangze.tech/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E6%8D%A2%E5%91%BD%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE/</link><pubDate>Wed, 24 May 2023 21:40:54 +0800</pubDate><guid>https://wangze.tech/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E6%8D%A2%E5%91%BD%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE/</guid><description>客户端和服务端交互内容
命令 键 单个值 集合值 OK 回复 整数回复 错误信息 RESP 2 协议
两个基本规范</description></item><item><title>Redis 学习路径</title><link>https://wangze.tech/Redis-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</link><pubDate>Wed, 24 May 2023 21:40:07 +0800</pubDate><guid>https://wangze.tech/Redis-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</guid><description>掌握数据结构和缓存的基本使用方法
学会基础数据类型的用法
String List Hash Set Sorted Set 掌握扩展数据类型的用法
HyperLogLog Bitmap GEO 积累 Redis 用作缓存的方法以及典型问题的解决方案</description></item><item><title>经典的 Redis 学习资料</title><link>https://wangze.tech/%E7%BB%8F%E5%85%B8%E7%9A%84-Redis-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</link><pubDate>Wed, 24 May 2023 21:38:18 +0800</pubDate><guid>https://wangze.tech/%E7%BB%8F%E5%85%B8%E7%9A%84-Redis-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</guid><description>工具书：《Redis 使用手册》
最有用的是「数据结构与应用」的内容
工具网站
Redis 命令参考 原理书：《Redis 设计与实现》</description></item><item><title>41｜第 35～40 讲课后思考题答案及常见问题答疑</title><link>https://wangze.tech/41%E7%AC%AC-3540-%E8%AE%B2%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/</link><pubDate>Wed, 24 May 2023 21:35:17 +0800</pubDate><guid>https://wangze.tech/41%E7%AC%AC-3540-%E8%AE%B2%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/</guid><description>Memcached 是内存键值数据库
RocksDB 是硬盘键值数据库（持久化）
Redis 和 Memcached 的比较
Redis 和 RocksDB 的比较</description></item><item><title>40｜Redis 的下一步：基于 NVM 内存的实践</title><link>https://wangze.tech/40Redis-%E7%9A%84%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%9F%BA%E4%BA%8E-NVM-%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E8%B7%B5/</link><pubDate>Wed, 24 May 2023 21:34:18 +0800</pubDate><guid>https://wangze.tech/40Redis-%E7%9A%84%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%9F%BA%E4%BA%8E-NVM-%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E8%B7%B5/</guid><description>特性
能持久化保存数据
读写速度比 DRAM 内存稍慢
DRAM：Dynamic random-access memory 动态随机存取存储器（半导体记存储器） 容量大</description></item><item><title>39｜Redis 6.0 的新特性：多线程、客户端缓存与安全</title><link>https://wangze.tech/39Redis-6.0-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E5%AE%89%E5%85%A8/</link><pubDate>Wed, 24 May 2023 21:29:34 +0800</pubDate><guid>https://wangze.tech/39Redis-6.0-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E5%AE%89%E5%85%A8/</guid><description>多 IO 线程
作用：使用多个 IO 线程并行读取网络请求、进行协议解析、回写 Socket
主线程和 IO 线程协作完成请求处理
阶段一：服务端和客户端建立 Socket 连接，并分配处理线程</description></item><item><title>38｜通信开销：限制 Redis Cluster 规模的关键因素</title><link>https://wangze.tech/38%E9%80%9A%E4%BF%A1%E5%BC%80%E9%94%80%E9%99%90%E5%88%B6-Redis-Cluster-%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/</link><pubDate>Wed, 24 May 2023 21:26:49 +0800</pubDate><guid>https://wangze.tech/38%E9%80%9A%E4%BF%A1%E5%BC%80%E9%94%80%E9%99%90%E5%88%B6-Redis-Cluster-%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/</guid><description>Redis Cluster 实例间以 Gossip 协议进行通信的机制
Gossip 协议的工作原理
两个实例间进行 PING、PONG 消息传递的情况 每个实例默认每秒从集群中随机挑选一些实例，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息 PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表 一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样 Gossip 消息大小</description></item><item><title>37｜数据分布优化：如何应对数据倾斜？</title><link>https://wangze.tech/37%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E4%BC%98%E5%8C%96%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/</link><pubDate>Wed, 24 May 2023 21:25:30 +0800</pubDate><guid>https://wangze.tech/37%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E4%BC%98%E5%8C%96%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/</guid><description>数据量倾斜：在某些情况下，实例上的数据分布不均衡，某个实例上的数据特别多
bigkey
集合类型的 bigkey 如果是集合类型，可以拆分成很多个小的集合类型数据，分散保存在不同的实例上
比如通过 ID 范围拆分 避免 bigkey</description></item><item><title>36｜Redis 支撑秒杀场景的关键技术和实践都有哪些？</title><link>https://wangze.tech/36Redis-%E6%94%AF%E6%92%91%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%92%8C%E5%AE%9E%E8%B7%B5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B/</link><pubDate>Wed, 24 May 2023 21:23:19 +0800</pubDate><guid>https://wangze.tech/36Redis-%E6%94%AF%E6%92%91%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%92%8C%E5%AE%9E%E8%B7%B5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B/</guid><description>特征
瞬时并发访问量非常高 读多写少 秒杀场景的所有环节
活动前</description></item><item><title>35｜Codis VS Redis Cluster：我该选择哪一个集群方案？</title><link>https://wangze.tech/35Codis-VS-Redis-Cluster%E6%88%91%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</link><pubDate>Wed, 24 May 2023 21:14:27 +0800</pubDate><guid>https://wangze.tech/35Codis-VS-Redis-Cluster%E6%88%91%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</guid><description>Codis 集群
Codis 集群的架构和关键组件图
codis server
进行了二次开发的 Redis 实例，其中增加了额外的数据结构，支持数据迁移操作，主要负责处理具体的数据读写请求 codis proxy</description></item><item><title>33｜脑裂：一次奇怪的数据丢失</title><link>https://wangze.tech/33%E8%84%91%E8%A3%82%E4%B8%80%E6%AC%A1%E5%A5%87%E6%80%AA%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</link><pubDate>Wed, 24 May 2023 21:12:29 +0800</pubDate><guid>https://wangze.tech/33%E8%84%91%E8%A3%82%E4%B8%80%E6%AC%A1%E5%A5%87%E6%80%AA%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</guid><description>脑裂：指在主从集群中，同时有两个主节点，都能接收写请求
图 1
图 2
影响：客户端不知道该往哪个主节点写入数据，结果不同客户端往不同的主节点写数据，严重的会导致数据丢失</description></item><item><title>32｜Redis 主从同步与故障切换，有哪些坑？</title><link>https://wangze.tech/32Redis-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</link><pubDate>Wed, 24 May 2023 21:10:58 +0800</pubDate><guid>https://wangze.tech/32Redis-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</guid><description>主从数据不一致 因为主从数据是异步复制
a）使用外部监控程序对比主从库复制进度，不让客户端从落后的从库中读取数据
开发一个工具：
基于 INFO replication 命令查看主库接收写命令的进度信息（master_repl_offset）和从库复制写命令的进度信息（slave_repl_offset）</description></item><item><title>31｜事务机制｜Redis 能实现 ACID 属性吗？</title><link>https://wangze.tech/31%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6Redis-%E8%83%BD%E5%AE%9E%E7%8E%B0-ACID-%E5%B1%9E%E6%80%A7%E5%90%97/</link><pubDate>Wed, 24 May 2023 21:09:04 +0800</pubDate><guid>https://wangze.tech/31%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6Redis-%E8%83%BD%E5%AE%9E%E7%8E%B0-ACID-%E5%B1%9E%E6%80%A7%E5%90%97/</guid><description>事务命令
MULTI
开启一个事务 EXEC
提交事务，从命令队列中去除提交的操作命令，进行实际执行 DISCARD
放弃一个事务，清空命令队列</description></item><item><title>30｜如何使用 Redis 实现分布式锁？</title><link>https://wangze.tech/30%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Tue, 23 May 2023 21:12:16 +0800</pubDate><guid>https://wangze.tech/30%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>单机版
用一个变量表示：0 没有线程获取到锁；1 有线程获取到锁 分布式锁
锁变量需要有一个共享存储系统来维护
基于单个节点
加锁</description></item><item><title>29｜无锁的原子操作：Redis 如何应对并发访问？</title><link>https://wangze.tech/29%E6%97%A0%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CRedis-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</link><pubDate>Tue, 23 May 2023 21:09:35 +0800</pubDate><guid>https://wangze.tech/29%E6%97%A0%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CRedis-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</guid><description>加锁
原子操作
单命令操作
多个操作在 Redis 中实现成一个操作（如改源码） INCR/DECR 命令 以原子性方式执行 Lua 脚本</description></item><item><title>28｜Pika：如何基于 SSD 实现大容量 Redis？</title><link>https://wangze.tech/28Pika%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-SSD-%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AE%B9%E9%87%8F-Redis/</link><pubDate>Tue, 23 May 2023 21:04:30 +0800</pubDate><guid>https://wangze.tech/28Pika%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-SSD-%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AE%B9%E9%87%8F-Redis/</guid><description>基于大内存实现大容量 Redis 实例的潜在问题
内存快照 RDB 生成和恢复效率低 主从节点全量同步时长增加、缓冲区易溢出 Pika 键值数据库</description></item><item><title>27｜缓存被污染了，该怎么办？</title><link>https://wangze.tech/27%E7%BC%93%E5%AD%98%E8%A2%AB%E6%B1%A1%E6%9F%93%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Tue, 23 May 2023 21:03:11 +0800</pubDate><guid>https://wangze.tech/27%E7%BC%93%E5%AD%98%E8%A2%AB%E6%B1%A1%E6%9F%93%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>缓存污染
留存在缓存中的数据，实际不会被再次访问了，但是又占据了缓存空间。 如果这样的数据体量很大，甚至占满了缓存，每次有新数据写入缓存时，还需要把这些数据逐步淘汰出缓存，就会增加缓存操作的时间开销。 解决
volatile-ttl 策略：设置时需明确知道数据被再次访问的情况时
LRU 缓存策略：只看数据的访问时间，可能在对大量数据进行一次全体读取后没能及时删除缓存数据
LFU 缓存策略</description></item><item><title>26｜缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？</title><link>https://wangze.tech/26%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%87%BB%E7%A9%BF%E7%A9%BF%E9%80%8F%E9%9A%BE%E9%A2%98/</link><pubDate>Tue, 23 May 2023 21:02:06 +0800</pubDate><guid>https://wangze.tech/26%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%87%BB%E7%A9%BF%E7%A9%BF%E9%80%8F%E9%9A%BE%E9%A2%98/</guid><description>三大问题的原因和应对方案
缓存雪崩 大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。 缓存击穿 针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。 缓存击穿的情况，经常发生在热点数据过期失效时。 缓存穿透 要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。 此时缓存成了摆设。 同时给缓存和数据库巨大压力。 尽量使用预防式方案</description></item><item><title>25｜缓存异常（上）：如何解决缓存和数据库的数据不一致问题？</title><link>https://wangze.tech/25%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E4%B8%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 23 May 2023 21:01:05 +0800</pubDate><guid>https://wangze.tech/25%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E4%B8%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</guid><description>数据的一致性
缓存中有数据，缓存的数据值需要和数据库中的值相同 缓存中没有数据，数据库中的值必须是最新值 「读写缓存」
要保证一致性可以采用同步直写策略 适用于读写相当的业务场景 「只读缓存」
数据不一致的问题原因、现象和应对方案</description></item><item><title>24｜替换策略：缓存满了怎么办？</title><link>https://wangze.tech/24%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5%E7%BC%93%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Tue, 23 May 2023 20:58:51 +0800</pubDate><guid>https://wangze.tech/24%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5%E7%BC%93%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销
CONFIG SET maxmemory 4gb 数据淘汰策略
noeviction（不进行数据淘汰）
一旦缓存被写满，再有写请求时，Redis 不再提供服务，直接返回错误 进行数据淘汰的策略</description></item><item><title>23｜旁路缓存：Redis 是如何工作的？</title><link>https://wangze.tech/23%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Tue, 23 May 2023 20:57:57 +0800</pubDate><guid>https://wangze.tech/23%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>旁路缓存：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中完成
Redis 适合做缓存
在分层系统中，数据暂存在快速子系统中有助于加速访问 缓存容量有限，缓存写满时，数据需要被淘汰 只读缓存</description></item><item><title>22｜第 11～21 讲课后思考题答案及常见问题答疑</title><link>https://wangze.tech/22%E7%AC%AC-1121-%E8%AE%B2%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/</link><pubDate>Tue, 23 May 2023 20:56:48 +0800</pubDate><guid>https://wangze.tech/22%E7%AC%AC-1121-%E8%AE%B2%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/</guid><description>问题 1：如何使用慢查询日志和 latency monitor 排查执行慢的操作？
设置 slowlog-log-slower-than：对执行时间大于多少微妙的命令进行记录 设置 slowlog-max-len：日志最多记录多少调命令 使用 SLOWLOG GET 命令查看慢查询日志 也可以使用 latency monitor 监控工具 监控 Redis 运行过程中的峰值延迟情况 从 2.</description></item><item><title>21｜缓冲区：一个可能引发“惨案”的地方</title><link>https://wangze.tech/21%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E6%83%A8%E6%A1%88%E7%9A%84%E5%9C%B0%E6%96%B9/</link><pubDate>Tue, 23 May 2023 20:53:57 +0800</pubDate><guid>https://wangze.tech/21%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E6%83%A8%E6%A1%88%E7%9A%84%E5%9C%B0%E6%96%B9/</guid><description>客户端输入和输出缓冲区
避免客户端和服务端的请求发送和处理速度不匹配
输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端
查看输入缓冲区的内存使用情况：CLIENT LIST 命令</description></item><item><title>20｜删除数据后，为什么内存占用率还是很高？</title><link>https://wangze.tech/20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98/</link><pubDate>Tue, 23 May 2023 20:52:16 +0800</pubDate><guid>https://wangze.tech/20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98/</guid><description>内存碎片
现象：内存空间闲置
生成原因：操作系统的内存分配机制 + Redis 的负载特征
操作系统按固定大小分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配
当程序申请的内存最接近某个固定值时，Redis 使用的 jemalloc 会给它分配相应大小的空间</description></item><item><title>19｜波动的响应延迟：如何应对变慢的 Redis？（下）</title><link>https://wangze.tech/19%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%E4%B8%8B/</link><pubDate>Tue, 23 May 2023 20:49:49 +0800</pubDate><guid>https://wangze.tech/19%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%E4%B8%8B/</guid><description>文件系统：AOF 模式
AOF 重写会对磁盘进行大量 IO 操作，fsync 需要等到数据写到磁盘后才能返回
everysec 时，使用后台子线程调用 fsync 写日志</description></item><item><title>18｜波动的响应延迟：如何应对变慢的 Redis？（上）</title><link>https://wangze.tech/18%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%E4%B8%8A/</link><pubDate>Mon, 22 May 2023 21:27:57 +0800</pubDate><guid>https://wangze.tech/18%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84-Redis%E4%B8%8A/</guid><description>Redis 真的变慢了吗？
查看 Redis 的响应延迟 redis-cli &amp;ndash;latency -h host -p port 基于当前环境下的 Redis 基线性能做判断 基线性能：一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定</description></item><item><title>17｜为什么 CPU 结构也会影响 Redis 的性能？</title><link>https://wangze.tech/17%E4%B8%BA%E4%BB%80%E4%B9%88-CPU-%E7%BB%93%E6%9E%84%E4%B9%9F%E4%BC%9A%E5%BD%B1%E5%93%8D-Redis-%E7%9A%84%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 22 May 2023 21:23:13 +0800</pubDate><guid>https://wangze.tech/17%E4%B8%BA%E4%BB%80%E4%B9%88-CPU-%E7%BB%93%E6%9E%84%E4%B9%9F%E4%BC%9A%E5%BD%B1%E5%93%8D-Redis-%E7%9A%84%E6%80%A7%E8%83%BD/</guid><description>NUMA 架构（Non-Uniform Memory Access 非统一内存访问架构）
图
第一步
第二步</description></item><item><title>16｜异步机制：如何避免单线程模型的阻塞？</title><link>https://wangze.tech/16%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E/</link><pubDate>Mon, 22 May 2023 21:21:08 +0800</pubDate><guid>https://wangze.tech/16%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E/</guid><description>4 类交互对象和具体的操作之间的关系
和客户端交互时的阻塞点
集合的全量查询和聚合操作 删除 bigkey 清空数据库 和磁盘交互时的阻塞点</description></item><item><title>15｜消息队列的考验：Redis 有哪些解决方案？</title><link>https://wangze.tech/15%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E8%80%83%E9%AA%8CRedis-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 22 May 2023 21:19:48 +0800</pubDate><guid>https://wangze.tech/15%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E8%80%83%E9%AA%8CRedis-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>消息队列的三大需求：消息保序、重复消息处理、消息可靠性保证
List
支持阻塞获取数据 不支持消费组 Stream
Redis 5.0 之后专门为消息队列设计的数据类型 不同消费组的消费者可以消费同一个消息 同一消费组的消费者不消费同一消息 自动生成全局唯一 ID 两者比较</description></item><item><title>14｜如何在 Redis 中保存时间序列数据？</title><link>https://wangze.tech/14%E5%A6%82%E4%BD%95%E5%9C%A8-Redis-%E4%B8%AD%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 22 May 2023 21:18:22 +0800</pubDate><guid>https://wangze.tech/14%E5%A6%82%E4%BD%95%E5%9C%A8-Redis-%E4%B8%AD%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/</guid><description>要求
写要快 查询模式多 一、同时使用 Hash 和 Sorted Set
{1: a, 2: b, 3: c} + setKey: {1: a, 2: b, 3: c}</description></item><item><title>13｜GEO 是什么？还可以定义新的数据类型吗？</title><link>https://wangze.tech/13GEO-%E6%98%AF%E4%BB%80%E4%B9%88%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97/</link><pubDate>Mon, 22 May 2023 21:16:00 +0800</pubDate><guid>https://wangze.tech/13GEO-%E6%98%AF%E4%BB%80%E4%B9%88%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97/</guid><description>LBS：位置信息服务（Location-Based Service）
GEO：数据类型
底层数据结构用 Sorted Set 实现
GeoHash 编码方法
基本原理：二分区间，区间编码</description></item><item><title>12｜有一亿个 keys 要统计，应该用哪种集合？</title><link>https://wangze.tech/12%E6%9C%89%E4%B8%80%E4%BA%BF%E4%B8%AA-keys-%E8%A6%81%E7%BB%9F%E8%AE%A1%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9B%86%E5%90%88/</link><pubDate>Sun, 21 May 2023 22:54:45 +0800</pubDate><guid>https://wangze.tech/12%E6%9C%89%E4%B8%80%E4%BA%BF%E4%B8%AA-keys-%E8%A6%81%E7%BB%9F%E8%AE%A1%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9B%86%E5%90%88/</guid><description>聚合统计
统计多个集合元素的聚合结果，包括：
统计多个集合的共有元素（交集统计） 把两个集合相比，统计其中一个集合独有的元素（差集统计） 统计多个集合的所有元素（并集统计） 使用 Set
并集：SUNIONSTORE user:new user:id user:id:20200803 差集：SDIFFSTORE user:new user:id:20200804 user:id 交集：SINTERSTORE user:id:rem user:id:20200803 user:id:20200804 计算复杂度较高，数据量较大时会导致 Redis 实例阻塞 三个命令都会生成新 key，但从库一般是 readonly（不建议开写），想在从库操作需使用 SUNION、SDIFF、SINTER，这些命令可以计算出结果，但不会生成新 key 可以从主从集群中选择一个从库专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了 排序统计</description></item><item><title>11｜“万金油”的 String，为什么不好用了？</title><link>https://wangze.tech/11%E4%B8%87%E9%87%91%E6%B2%B9%E7%9A%84-String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%A5%BD%E7%94%A8%E4%BA%86/</link><pubDate>Fri, 19 May 2023 22:32:31 +0800</pubDate><guid>https://wangze.tech/11%E4%B8%87%E9%87%91%E6%B2%B9%E7%9A%84-String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%A5%BD%E7%94%A8%E4%BA%86/</guid><description>Redis 容量预估工具
String 类型
元数据：内存空间记录数据长度、空间使用等信息
int 编码方式：当保存 64 位有符号整数时，会保存为 8 字节的 Long 类型整数</description></item><item><title>09｜切片集群：数据增多了，是该加内存还是加实例？</title><link>https://wangze.tech/09%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%A4%9A%E4%BA%86%E6%98%AF%E8%AF%A5%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B/</link><pubDate>Thu, 18 May 2023 21:33:25 +0800</pubDate><guid>https://wangze.tech/09%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%A4%9A%E4%BA%86%E6%98%AF%E8%AF%A5%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B/</guid><description>纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU
实施起来简单、直接 当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞（耗时长） 不要求持久化保存 Redis 数据时是一个不错的选择 受到硬件和成本的限制 横向扩展：增加当前 Redis 实例的个数</description></item><item><title>08｜哨兵集群：哨兵挂了，主从库还能切换吗？</title><link>https://wangze.tech/08%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86%E4%B8%BB%E4%BB%8E%E5%BA%93%E8%BF%98%E8%83%BD%E5%88%87%E6%8D%A2%E5%90%97/</link><pubDate>Thu, 18 May 2023 21:29:15 +0800</pubDate><guid>https://wangze.tech/08%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86%E4%B8%BB%E4%BB%8E%E5%BA%93%E8%BF%98%E8%83%BD%E5%88%87%E6%8D%A2%E5%90%97/</guid><description>本质上哨兵就是一个运行在特定模式下的 Redis 实例。
基于 pub/sub 机制的哨兵集群组成过程（发布/订阅机制）
只有订阅了同一个频道的应用才能通过发布的消息进行信息交换 哨兵通过 sentinel:hello 频道互相发现、通信 给主库发送 INFO 命令拿到从库列表，哨兵根据列表上的连接信息和从库建立连接并监控</description></item><item><title>07｜哨兵机制：主库挂了，如何不间断服务？</title><link>https://wangze.tech/07%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/</link><pubDate>Thu, 18 May 2023 21:27:01 +0800</pubDate><guid>https://wangze.tech/07%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/</guid><description>哨兵机制的基本流程
监控：判断主从库下线 主观下线
哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。 如果哨兵发现主库或从库对 PING 命令的响应超时了，哨兵就会先把它标记为“主观下线”。 从库会被直接标记为“主观下线”。 客观下线</description></item><item><title>06｜数据同步：主从库如何实现数据一致？</title><link>https://wangze.tech/06%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/</link><pubDate>Thu, 18 May 2023 21:20:46 +0800</pubDate><guid>https://wangze.tech/06%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/</guid><description>写操作：首先到主库执行，主库将写操作同步给从库
同步流程
主从库第一次同步的流程
增量复制流程
全量复制 第一次同步无法避免</description></item><item><title>05｜内存快照：宕机后，Redis 如何实现快速恢复？</title><link>https://wangze.tech/05%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E5%AE%95%E6%9C%BA%E5%90%8ERedis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/</link><pubDate>Thu, 18 May 2023 21:16:43 +0800</pubDate><guid>https://wangze.tech/05%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E5%AE%95%E6%9C%BA%E5%90%8ERedis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/</guid><description>和 AOF 相比，RDB 记录某一时刻的数据，恢复时直接把 RDB 文件读入内存
类比拍照 全量快照 生成 RDB 文件的方案
save：在主线程中执行，会导致阻塞</description></item><item><title>04｜AOF 日志：宕机了，Redis 如何避免数据丢失？</title><link>https://wangze.tech/04AOF-%E6%97%A5%E5%BF%97%E5%AE%95%E6%9C%BA%E4%BA%86Redis-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</link><pubDate>Thu, 18 May 2023 21:13:32 +0800</pubDate><guid>https://wangze.tech/04AOF-%E6%97%A5%E5%BF%97%E5%AE%95%E6%9C%BA%E4%BA%86Redis-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</guid><description>Redis 作为缓存使用
从数据库读取数据恢复 当需要恢复时数据库压力大、Redis 响应慢 写后日志：先执行命令把数据写入内存，再记录日志
不会阻塞当前的写操作 记录的命令没有错误 没来得及记录时，宕机会丢失数据 在主线程写，写盘压力大可能导致后续操作无法执行 日志格式示例</description></item><item><title>03｜高性能 IO 模型：为什么单线程 Redis 那么快？</title><link>https://wangze.tech/03%E9%AB%98%E6%80%A7%E8%83%BD-IO-%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B-Redis-%E9%82%A3%E4%B9%88%E5%BF%AB/</link><pubDate>Thu, 18 May 2023 21:11:47 +0800</pubDate><guid>https://wangze.tech/03%E9%AB%98%E6%80%A7%E8%83%BD-IO-%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B-Redis-%E9%82%A3%E4%B9%88%E5%BF%AB/</guid><description>Redis 的网络 IO 和键值对读写由一个线程完成
当客户端和 Reids 的网络连接断开时，Redis 不会等待客户端恢复连接 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，由额外的线程执行
单线程设计机制
多线程编程模式：共享资源的并发访问控制问题 在内存中完成大部分操作 + 高效的数据结构 多路复用机制（select/epoll 机制）</description></item><item><title>02｜数据结构：快速的 Redis 有哪些慢操作？</title><link>https://wangze.tech/02%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E7%9A%84-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C/</link><pubDate>Thu, 18 May 2023 21:02:10 +0800</pubDate><guid>https://wangze.tech/02%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E7%9A%84-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C/</guid><description>Redis 数据类型和底层数据结构的对应关系
Redis 使用一个哈希表 O(1) 保存所有键值对
全局哈希表（数组）
哈希桶</description></item><item><title>01｜基础架构：一个键值数据库包含什么？</title><link>https://wangze.tech/01%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88/</link><pubDate>Thu, 18 May 2023 14:57:04 +0800</pubDate><guid>https://wangze.tech/01%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88/</guid><description>操作模块
PUT：新写入或更新一个 key-value 对，如 PUT hello world GET：根据 K 读取 V DELETE：根据 K 删除整个 KV 对 SCAN：根据一段 key 的范围返回相应的 value 值 访问模式</description></item><item><title>00｜开篇词</title><link>https://wangze.tech/00%E5%BC%80%E7%AF%87%E8%AF%8D/</link><pubDate>Thu, 18 May 2023 14:52:44 +0800</pubDate><guid>https://wangze.tech/00%E5%BC%80%E7%AF%87%E8%AF%8D/</guid><description>1 Redis 的“两大维度，三大主线
应用纬度
缓存应用 集群应用 数据结构应用 系统纬度
高性能主线</description></item><item><title>Redis 核心技术与实战</title><link>https://wangze.tech/Redis-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/</link><pubDate>Thu, 18 May 2023 00:27:15 +0800</pubDate><guid>https://wangze.tech/Redis-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/</guid><description>内容整理自极客时间 《Redis 核心技术与实战》
基础篇 [[00｜开篇词]] [[01｜基础架构：一个键值数据库包含什么？]] [[02｜数据结构：快速的 Redis 有哪些慢操作？]] [[03｜高性能 IO 模型：为什么单线程 Redis 那么快？]] [[04｜AOF 日志：宕机了，Redis 如何避免数据丢失？]] [[05｜内存快照：宕机后，Redis 如何实现快速恢复？]] [[06｜数据同步：主从库如何实现数据一致？]] [[07｜哨兵机制：主库挂了，如何不间断服务？]] [[08｜哨兵集群：哨兵挂了，主从库还能切换吗？]] [[09｜切片集群：数据增多了，是该加内存还是加实例？]] 实践篇 [[11｜“万金油”的 String，为什么不好用了？]] [[12｜有一亿个 keys 要统计，应该用哪种集合？]] [[13｜GEO 是什么？还可以定义新的数据类型吗？]] [[14｜如何在 Redis 中保存时间序列数据？]] [[15｜消息队列的考验：Redis 有哪些解决方案？]] [[16｜异步机制：如何避免单线程模型的阻塞？]] [[17｜为什么 CPU 结构也会影响 Redis 的性能？]] [[18｜波动的响应延迟：如何应对变慢的 Redis？（上）]] [[19｜波动的响应延迟：如何应对变慢的 Redis？（下）]] [[20｜删除数据后，为什么内存占用率还是很高？]] [[21｜缓冲区：一个可能引发“惨案”的地方]] [[22｜第 11～21 讲课后思考题答案及常见问题答疑]] [[23｜旁路缓存：Redis 是如何工作的？]] [[24｜替换策略：缓存满了怎么办？]] [[25｜缓存异常（上）：如何解决缓存和数据库的数据不一致问题？]] [[26｜缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？]] [[27｜缓存被污染了，该怎么办？]] [[28｜Pika：如何基于 SSD 实现大容量 Redis？]] [[29｜无锁的原子操作：Redis 如何应对并发访问？]] [[30｜如何使用 Redis 实现分布式锁？]] [[31｜事务机制｜Redis 能实现 ACID 属性吗？]] [[32｜Redis 主从同步与故障切换，有哪些坑？]] [[33｜脑裂：一次奇怪的数据丢失]] [[35｜Codis VS Redis Cluster：我该选择哪一个集群方案？]] [[36｜Redis 支撑秒杀场景的关键技术和实践都有哪些？]] [[37｜数据分布优化：如何应对数据倾斜？]] [[38｜通信开销：限制 Redis Cluster 规模的关键因素]] 未来篇 [[39｜Redis 6.</description></item><item><title>45｜自增 id 用完怎么办？</title><link>https://wangze.tech/45%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 22:27:40 +0800</pubDate><guid>https://wangze.tech/45%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。
row_id
InnoDB 表没有指定主键时，会创建一个不可见的，长度为 6 个字节的 row_id。
row_id 是一个长度 8 字节的无符号长整形</description></item><item><title>44｜答疑文章（三）：说一说这些好问题</title><link>https://wangze.tech/44%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 22:26:57 +0800</pubDate><guid>https://wangze.tech/44%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</guid><description>join 的写法
在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。
where a.f2=b.f2 就表示，查询结果里面不会包含 b.</description></item><item><title>43｜要不要使用分区表？</title><link>https://wangze.tech/43%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:24:46 +0800</pubDate><guid>https://wangze.tech/43%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</guid><description>分区表：对于引擎层，n 个表对于 server 层，1 个表
分区策略
MyISAM 分区表
InnoDB 分区表
通用分区策略：每次访问都由 server 层控制</description></item><item><title>42｜grant 之后要跟着 flush privileges 吗？</title><link>https://wangze.tech/42grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97/</link><pubDate>Wed, 17 May 2023 22:23:12 +0800</pubDate><guid>https://wangze.tech/42grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97/</guid><description>不用
在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户，因此 ua@ip1 和 ua@ip2 代表的是两个不同的用户。
全局权限
保存在 mysql.</description></item><item><title>41｜怎么最快地复制一张表？</title><link>https://wangze.tech/41%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:20:02 +0800</pubDate><guid>https://wangze.tech/41%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</guid><description>逻辑导数据
在两张表中拷贝数据，最简单地使用 insert … select 语句即可实现
将数据写到外部文本文件，然后再写回目标表
mysqldump 方法 a.</description></item><item><title>40｜insert 语句的锁为什么这么多？</title><link>https://wangze.tech/40insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Wed, 17 May 2023 22:17:02 +0800</pubDate><guid>https://wangze.tech/40insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>insert … select 语句
并发 insert 场景
实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了 (-∞,1]这个 next-key lock，会在语句执行完成后，才允许 session A 的 insert 语句执行。</description></item><item><title>39｜自增主键为什么不是连续的？</title><link>https://wangze.tech/39%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</link><pubDate>Wed, 17 May 2023 22:15:09 +0800</pubDate><guid>https://wangze.tech/39%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</guid><description>自增值保存在哪儿？
表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。
MyISAM 引擎的自增值保存在数据文件中。
InnoDB
在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。 在 MySQL 8.</description></item><item><title>38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？</title><link>https://wangze.tech/38%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E/</link><pubDate>Wed, 17 May 2023 22:13:35 +0800</pubDate><guid>https://wangze.tech/38%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E/</guid><description>内存表的数据组织结构
InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。
而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。
InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的； 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值； 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引； InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。 InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。 内存表也支持 B-Tree 索引的</description></item><item><title>37｜什么时候会使用内部临时表？</title><link>https://wangze.tech/37%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:10:20 +0800</pubDate><guid>https://wangze.tech/37%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</guid><description>union 执行流程
(select 1000 as f) union (select id from t1 order by id desc limit 2);这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。 创建临时表，执行第一个查询，拿到 1000，放入临时表，执行第二个查询，拿到 1000 和 999，1000 由于违反唯一性约束插入失败，接着放入 999 后返回，最后从临时表中按行取出数据，返回结果，并删除临时表 改成 union all 则没有去重的语义，执行时不需要临时表 group by 执行流程</description></item><item><title>36｜为什么临时表可以重名？</title><link>https://wangze.tech/36%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</link><pubDate>Wed, 17 May 2023 22:07:50 +0800</pubDate><guid>https://wangze.tech/36%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</guid><description>临时表和内存表不同
内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。 而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。临时表也可以使用 Memory 引擎。 临时表的特性</description></item><item><title>35｜join 语句怎么优化？</title><link>https://wangze.tech/35join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</link><pubDate>Wed, 17 May 2023 22:03:17 +0800</pubDate><guid>https://wangze.tech/35join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</guid><description>Multi-Range Read 优化（MRR）
目的：尽量使用顺序读盘
因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。
MRR 的设计思路 优化后的执行流程
根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ; read_rnd_buffer：MySQL 的随机读缓冲区。当按任意顺序读取行时（例如按照排序顺序）将分配一个随机读取缓冲区，进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度。 将 read_rnd_buffer 中的 id 进行递增排序； 排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。 read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</description></item><item><title>34｜到底可不可以使用 join ？</title><link>https://wangze.tech/34%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join-/</link><pubDate>Wed, 17 May 2023 21:59:52 +0800</pubDate><guid>https://wangze.tech/34%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join-/</guid><description>Index Nested-Loop Join（NLJ）
使用 join 语句，性能比强行拆成多个但表执行 SQL 语句的性能要好； 如果使用 join 语句的话，需要让小表做驱动表 前提是“可以使用被驱动表的索引” Simple Nested-Loop Join</description></item><item><title>33｜我查这么多数据，会不会把数据库内存打爆？</title><link>https://wangze.tech/33%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</link><pubDate>Wed, 17 May 2023 21:55:07 +0800</pubDate><guid>https://wangze.tech/33%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</guid><description>全表扫描对 server 层的影响
服务端并不需要保存一个完整的结果集，取数据和发数据的流程（边读边发）：
获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。2. 重复获取行，直到 net_buffer 写满，调用网络接口发出去。（发给 socket send buffer）3.</description></item><item><title>32｜为什么还有 kill 不掉的语句？</title><link>https://wangze.tech/32%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</link><pubDate>Wed, 17 May 2023 21:51:21 +0800</pubDate><guid>https://wangze.tech/32%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</guid><description>两个 kill 命令
kill query + 线程 id 终止这个线程中正在执行的语句 kill connection + 线程 id connection 可以不写 断开这个线程的连接 会先停止正在执行的语句 使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed。</description></item><item><title>31｜误删数据后除了跑路，还能怎么办？</title><link>https://wangze.tech/31%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 21:48:05 +0800</pubDate><guid>https://wangze.tech/31%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>使用 delete 语句误删数据行； 使用 drop table 或者 truncate table 语句误删数据表； 使用 drop database 语句误删数据库； 使用 rm 命令误删整个 MySQL 实例。 误删行</description></item><item><title>30｜答疑文章（二）：用动态的观点看加锁</title><link>https://wangze.tech/30%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</link><pubDate>Wed, 17 May 2023 21:46:35 +0800</pubDate><guid>https://wangze.tech/30%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</guid><description>CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), KEY c (c)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</description></item><item><title>29｜如何判断一个数据库是不是出问题了？</title><link>https://wangze.tech/29%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/</link><pubDate>Wed, 17 May 2023 21:44:09 +0800</pubDate><guid>https://wangze.tech/29%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/</guid><description>select 1 判断
select 1 这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的 MHA（Master High Availability），默认使用的就是这个方法。 只能说明这个库的进程还在，不能说明主库没问题 mysqladmin ping 机制也属于同一类 建议把 innodb_thread_concurrency 设置为 64~128 之间的值</description></item><item><title>28｜读写分离有哪些坑？</title><link>https://wangze.tech/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</link><pubDate>Wed, 17 May 2023 21:40:49 +0800</pubDate><guid>https://wangze.tech/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</guid><description>客户端直连 查询性能稍微好点，整体架构简单，排查问题更方便 主备切换、库迁移等操作时，客户端会感知到，并且需要调整数据库连接信息 一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发 带 proxy 的架构 对客户端友好，连接维护、后端信息等工作都由 proxy 完成 对后端维护团队的要求更高，需要高可用，整体架构比较复杂 过期读：在从库上会读到系统的一个过期状态</description></item><item><title>27｜主库出问题了，从库怎么办？</title><link>https://wangze.tech/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 21:37:54 +0800</pubDate><guid>https://wangze.tech/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>基于位点的主备切换
change master 命令：CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password MASTER_LOG_FILE=$master_log_name MASTER_LOG_POS=$master_log_pos  最后两个参数就是位点参数：从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步</description></item><item><title>26｜备库为什么会延迟好几个小时？</title><link>https://wangze.tech/26%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</link><pubDate>Wed, 17 May 2023 21:30:25 +0800</pubDate><guid>https://wangze.tech/26%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</guid><description>多线程复制机制 = 将单线程 sql_thread 拆成多个线程
coordinator 就是原来的 sql_thread，但不再更新数据，只负责读取中转日志和分发事务真正更新日志的变成 worker 线程，个数由参数 slave_parallel_workers 决定一般设置 8～16 之间最好（32 核物理机的情况）需要留资源给读查询</description></item><item><title>25｜MySQL 是怎么保证高可用的？</title><link>https://wangze.tech/25MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:27:01 +0800</pubDate><guid>https://wangze.tech/25MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</guid><description>正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性
主动切换的场景
主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1; 之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2; 很快 备库 B 执行完成这个事务，我们把这个时刻记为 T3 主备延迟</description></item><item><title>24｜MySQL 是怎么保证主备一致的？</title><link>https://wangze.tech/24MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:21:01 +0800</pubDate><guid>https://wangze.tech/24MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</guid><description>本章的内容是所有 MySQL 高可用方案的基础
将备库设置为只读模式（readonly）
防止误操作 防止切换逻辑有 bug，比如切换过程中出现双写造成主备不一致 可以用 readonly 状态判断节点的角色 readonly 设置对超级权限用户（super）是无效的，用于同步更新的线程拥有超级权限 一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图。（主备同步内部流程）</description></item><item><title>23｜MySQL 是怎么保证数据不丢的？</title><link>https://wangze.tech/23MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:13:18 +0800</pubDate><guid>https://wangze.tech/23MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</guid><description>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。
binlog 的写入机制
写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</description></item><item><title>22｜MySQL有哪些“饮鸩止渴”提高性能的方法？</title><link>https://wangze.tech/22MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 17 May 2023 21:07:09 +0800</pubDate><guid>https://wangze.tech/22MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>短连接风暴
max_connections 参数控制一个 MySQL 实例同时存在的连接数上限
超过这个数，系统就会拒绝接下来的连接请求，并报错提示“Too many connections” 只要连着就会计数 解决方案
一、先处理掉那些占着连接但是不工作的线程</description></item><item><title>21｜为什么我只改一行的语句，锁这么多？</title><link>https://wangze.tech/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Wed, 17 May 2023 21:03:25 +0800</pubDate><guid>https://wangze.tech/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>规则的前提说明
加锁策略可能改变，下面的只限于 5.x 系列 &amp;lt;= 5.7.24，8.0 系列 &amp;lt;= 8.0.13 间隙锁在可重复读隔离级别下才有效
读提交在外键场景下也有 两个原则、两个优化、一个 bug</description></item><item><title>20｜幻读是什么，幻读有什么问题？</title><link>https://wangze.tech/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 20:59:28 +0800</pubDate><guid>https://wangze.tech/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</guid><description>InnoDB 的默认事务隔离级别是可重复读
和下一章共用的表：CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), KEY c (c)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</description></item><item><title>19｜为什么我只查一行的语句，也执行这么慢？</title><link>https://wangze.tech/19%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</link><pubDate>Wed, 17 May 2023 20:48:04 +0800</pubDate><guid>https://wangze.tech/19%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</guid><description>有个表 t：mysql&amp;gt; CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB;</description></item><item><title>18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？</title><link>https://wangze.tech/18%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</link><pubDate>Wed, 17 May 2023 20:43:38 +0800</pubDate><guid>https://wangze.tech/18%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</guid><description>案例一：条件字段函数操作
原语句：mysql&amp;gt; select count(*) from tradelog where month(t_modified)=7;
字段值如：2017-7-1 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能
但是，优化器并不是要放弃使用这个索引，还可以选择遍历主键索引，也可以选择遍历索引 t_modified</description></item><item><title>17｜如何正确地显示随机消息？</title><link>https://wangze.tech/17%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</link><pubDate>Wed, 17 May 2023 20:35:47 +0800</pubDate><guid>https://wangze.tech/17%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</guid><description>内存临时表
explain 结果中 extra 包含 Using temporary，表示的是需要使用临时表
Using filesort 表示需要执行排序操作
比如执行 order by rand() 的时候就需要用到上面两个</description></item><item><title>16｜“order by”是怎么工作的？</title><link>https://wangze.tech/16order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 20:29:51 +0800</pubDate><guid>https://wangze.tech/16order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer
select city,name,age from t where city=&amp;lsquo;杭州&amp;rsquo; order by name limit 1000 ;
city varchar 16，name varchar 16，age int 11，city 有索引</description></item><item><title>15｜答疑文章（一）：日志和索引相关问题</title><link>https://wangze.tech/15%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 15:31:36 +0800</pubDate><guid>https://wangze.tech/15%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description>业务设计问题
业务上有这样的需求，A、B 两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是 like 表，一个是 friend 表，like 表有 user_id、liker_id 两个字段，我设置为复合唯一索引即 uk_user_id_liker_id。语句执行逻辑是这样的：以 A 关注 B 为例：第一步，先查询对方有没有关注自己（B 有没有关注 A）select * from like where user_id = B and liker_id = A;如果有，则成为好友insert into friend;没有，则只是单向关注关系insert into like;但是如果 A、B 同时关注对方，会出现不会成为好友的情况。因为上面第 1 步，双方都没关注对方。第 1 步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在 MySQL 锁层面有没有办法处理？</description></item><item><title>14｜count(*) 这么慢，我该怎么办？</title><link>https://wangze.tech/14count-%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 15:25:11 +0800</pubDate><guid>https://wangze.tech/14count-%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>count(*) 的实现方式
MyISAM 引擎把一个表的总行数存在磁盘上，执行时直接返回这个树
InnoDB 引擎每次都需要把数据一行行地从引擎里面读出来，累计行数
以上都是在说没有过滤条件的 count(*)
show table status 命令输出结果有一个 TABLE_ROWS 用于显示这个表当前行数，执行很快，但是这个结果是采样估算的（误差可能达到 40% 到 50%）</description></item><item><title>13｜为什么表数据删掉一半，表文件大小不变？</title><link>https://wangze.tech/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</link><pubDate>Wed, 17 May 2023 15:24:09 +0800</pubDate><guid>https://wangze.tech/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</guid><description>参数 innodb_file_per_table
OFF：表的数据放在系统共享表空间，也就是跟数据字典放在一起
ON：每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中
从 5.6.6 版本开始是默认值
建议无论使用哪个版本都将这个值设置为 ON</description></item><item><title>12｜为什么我的 MySQL 会“抖”一下？</title><link>https://wangze.tech/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-MySQL-%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</link><pubDate>Wed, 17 May 2023 15:19:54 +0800</pubDate><guid>https://wangze.tech/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-MySQL-%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</guid><description>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。
内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
即何时内存中的脏页往硬盘上刷？
redo log 满 把绿色部分的日志对应的所有脏页都 flush 到磁盘上</description></item><item><title>11｜怎么给字符串字段加索引？</title><link>https://wangze.tech/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</link><pubDate>Wed, 17 May 2023 15:19:11 +0800</pubDate><guid>https://wangze.tech/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</guid><description>直接创建完整索引，这样可能比较占用空间； 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引； 即使前缀完全覆盖了字段内容也会回表，因为不确定是不是真的完整数据
在索引上找到数据后还需要回到主键上拿到完整数据进行判断
倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题，不支持范围扫描； index index_name(email(6)); 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，需要多一个字段保存 hash 字段，不支持范围扫描。 比如通过 crc32() 函数得到 hash 值 思考题</description></item><item><title>10｜MySQL 为什么有时候会选错索引？</title><link>https://wangze.tech/10MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</link><pubDate>Wed, 17 May 2023 15:18:30 +0800</pubDate><guid>https://wangze.tech/10MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</guid><description>优化器的逻辑
扫描行数
一个索引上不同的值越多（指基数），这个索引的区分度就越好。
基数（cardinality）：一个索引上不同的值的个数。
采样统计：InnoDB 默认选择索引的 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面树，就得到这个索引的基数。
当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</description></item><item><title>09｜普通索引和唯一索引，应该怎么选择？</title><link>https://wangze.tech/09%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</link><pubDate>Wed, 17 May 2023 15:15:56 +0800</pubDate><guid>https://wangze.tech/09%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</guid><description>查询性能
「where = 」时，唯一索引找到了立马返回，普通索引需要找到下一个不等于的值
因为 InnoDB 的数据是按数据页为单位读写的，所以性能差距微乎其微
对于整形字段，一个 16KB 的数据页可以放近千个 key change buffer</description></item><item><title>08｜事务到底是隔离的还是不隔离的？</title><link>https://wangze.tech/08%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</link><pubDate>Wed, 17 May 2023 14:45:12 +0800</pubDate><guid>https://wangze.tech/08%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</guid><description>事务的启动时机 begin/start transaction 命令之后的第一个操作 InnoDB 表的语句，事务才真正启动。 马上启动一个事务：start transaction with consistent snapshot。 整个专栏，如果没有特别说明，都默认 autocommit = 1。 事务自动提交设置，默认为1，即除非显示声明一个事务的开始，否则每一个查询都会被当做独立的事务被处理。 MySQL 里的两个“视图”的概念 一个是 view。是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是 create view …，查询方法和表一样。 另一个是 InnoDB 在实现 MVCC（多版本并发控制） 时用到的一致性读视图（consistent read view），用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。 视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据” “快照”在 MVCC 里是怎么工作的？ 秒级创建快照的能力，快照是基于整库的。 InnoDB 的行数据有多个版本（row），每个版本有自己的 row trx_id（严格递增）。 图中的虚线就是 undo log。 在实现上，InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。 活跃：启动了但还没提交。 数组里事务 ID 的最小值记为低水位。 当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。 数据版本的可见性规则：基于数据的 row trx_id 和一致性视图的对比结果得到的。 绿色：表示这个版本是已提交的事务或者是当前事务自己生成的，可见。 红色：表示是由将来启动的事务生成的，不可见。 黄色 a）若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b）若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。 翻译：对于一个事务视图，除了自己的更新总是可见以外，有三种情况 版本未提交，不可见； 版本已提交，但是是在视图创建后提交的，不可见； 版本已提交，而且是在视图创建前提交的，可见。 每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 对于读提交，查询只承认在语句启动前就已经提交完成的数据； 更新逻辑 更新数据都是先读后写的。 当前读：总是读取已经提交完成的最新版本。 除了 update 语句外，select 语句如果加锁，也是当前读。 加上 lock in share mode 或 for update。 事务的可重复读是怎么实现的？ 可重复读的核心是一致性读；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。 读提交的逻辑和可重复读的逻辑类似，最主要的区别： 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图； 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的事务。 为什么表结构不支持“可重复读”？ 因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。 MySQL 8.</description></item><item><title>07｜行锁功过：怎么减少锁对性能的影响？</title><link>https://wangze.tech/07%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</link><pubDate>Wed, 17 May 2023 14:43:52 +0800</pubDate><guid>https://wangze.tech/07%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</guid><description> MyISAM 不支持行锁 InnoDB 的行锁 两阶段锁协议：事务中，行锁在需要的时候才加上，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。 两种策略 直接进入等待，直到超时。 超时时间可以通过 innodb_lock_wait_timeout 设置 默认 50s。 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。 死锁：每当一个事务被锁，就要看看它所依赖的线程有没有被别的锁住，如此循环，最后判断是否出现连循环等待。 假设现在已经有999个线程在同一行等锁，新来一个请求也要访问这个行，他要判断有没有死锁要判断 1000 次。然后这个结果乘以 1000。 正常情况下采用第二种策略，默认也是第二种。 怎么解决热点行更新导致的性能问题？ 问题的症结：死锁检测要耗费大量的 CPU 资源。 确保业务一定不会出现死锁，关闭死锁检测（不推荐） 控制并发度。 a）在中间件或修改 MySQL 源码实现：对于相同行的更新，在进入引擎之前排队，这样 InnoDB 就不会有大量的死锁检测工作。 b）如果做不到第 a 点，可以考虑从设计上优化 以考虑通过将一行改成逻辑上的多行来减少锁冲突。 以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。 思考题 如果要删除一个表里面的前 1w 行数据，选择哪一种方法 直接执行 delete from T limit 10000; 单个语句占用时间长，锁的时间也比较长； 大事务还会导致主从延迟。 在一个连接中循环执行 20 次 delete from T limit 500; 选 2。 在 20 个连接中同时执行 delete from T limit 500; 认为造成锁冲突。 评论区 关于本篇思考题 第二种方法难道不会引起数据一致性问题吗？如果在 InnoDB 中开启了自动事务并且没有显式用 begin, commit 来做的话，在上一次循环结束和下一次循环开始之间如果有其他事务插入了新数据，而且正好位置也在前面 500条，那不就不一致了么 加个 order by id（假设 id 是表的主键） 排序后新增的 id 肯定大于要删除的最大 id 如果有多种锁，必须全部不互斥才能并行。 没有嵌套事务，开启下一个会自动提交上一个</description></item><item><title>06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？</title><link>https://wangze.tech/06%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</link><pubDate>Wed, 17 May 2023 14:40:34 +0800</pubDate><guid>https://wangze.tech/06%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</guid><description>全局锁 典型使用场景：做全库逻辑备份。 使用 MySQL 提供的加全局读锁的方法 Flush tables with read lock（FTWRL） 整个库进入只读状态 执行 FTWRL 命令之后由于客户端发生异常断开，MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。 推荐：可以在可重复读隔离级别下开启一个事务 备份期间可以正常读写数据库 需要所有的表的引擎都支持（全库备份） mysqldump 备份工具使用 -single-transaction 参数，就会开启一个事务，确保拿到一致性视图 为什么不使用 set global readonly=true？ 建议用 FTWRL 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。 将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。 readonly 对 super 权限的用户无效 表级锁 表锁 语法：lock tables … read/write unlock tables 主动释放锁，或者客户端断开的时候自动释放 除了会限制比的线程的读写，也会限定本线程自己接下来的操作对象 不推荐使用，若引擎不支持事务，安排升级换引擎。 升级后把使用 lock/unlock tables 语法的地方换成 begin 和 commit。 元数据锁 MDL（metadata lock） 不需要显示使用，在访问一个表的时候会被自动加上 MySQL 5.</description></item><item><title>05｜深入浅出索引（下）</title><link>https://wangze.tech/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8B/</link><pubDate>Wed, 17 May 2023 10:13:29 +0800</pubDate><guid>https://wangze.tech/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8B/</guid><description>如何安排联合索引内的字段顺序 第一原则：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。 如果既有联合查询，又有基于 a、b 各自的查询，此时要考虑空间 比如 a 比 b 大，就建 (a, b) + 单 b 还有其他情况，需要结合业务分析 查询语句的 where 里面各个判断调换顺序不影响 覆盖索引 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果 覆盖索引可以减少树的搜索次数，显著提升查询性能，是常见的性能优化手段 要全用上必须是条件 =，不能是 &amp;gt; 或 &amp;lt; (c, b)，这个索引是当 c 相同时,才按照 b 字段升序或者降序排序建立索引 b那如果 &amp;gt; 的话 相当于可能获取到多个 c 不同的情况 在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 如果有一个高频请求是根据身份证号查询姓名，就有必要 前缀索引 最左前缀原则 可以是联合索引的最左 N 个字段 也可以是字符串索引的最左 M 个字符 索引下推 MySQL 5.</description></item><item><title>04｜深入浅出索引（上）</title><link>https://wangze.tech/04%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8A/</link><pubDate>Wed, 17 May 2023 10:09:25 +0800</pubDate><guid>https://wangze.tech/04%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8A/</guid><description>每遇到一个新数据库，先关注它的数据模型，分析数据库的适用场景 数据库底层存储的核心基于的数据模型：哈希表、有序数组、二叉树、N 叉树等 哈希表 以键 - 值（key-value）存储数据的结构 思路：把值放到数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置 不可避免出现哈希冲突，其中一种解决方法是用链表存储相同 key 的值，查找时从链表头开始按顺序遍历链表 适用于只有等值查询的场景 插入数据很快 无序，用哈希索引做区间查询很慢 比如 Memcached 及其他一些 NoSQL 引擎 有序数组 在等值查询和范围查询场景中的性能非常优秀 用二分法可以快速找到对应的数据，O(Log(N)) 只适用于静态存储引擎 插入数据慢，需要挪动插入的记录后面所有的记录 二叉搜索树 特点 父节点左子树所有节点的值小于父节点的值 父节点右子树所有节点的值大于父节点的值 需要保持这棵树是平衡二叉树 查询复杂度O(log(N)) 更新复杂度O(log(N)) N 叉树 B+ 树就是一种 N 叉树 相比于二叉树，能够有效减少单次查询的磁盘访问次数 N 取决于数据块的大小 MySQL 5.</description></item><item><title>02｜日志系统：一条 SQL 更新语句是如何执行的？</title><link>https://wangze.tech/02%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1-SQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 09:52:27 +0800</pubDate><guid>https://wangze.tech/02%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1-SQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>Update 语句执行流程 重要的日志模块：redo Log 是 InnoDB 引擎特有的日志 WAL（Write-Ahead Logging）技术 先写日志，再写磁盘 当有一条记录需要更新的时候，InnoDB 引擎先把记录写到 redo log，并更新内存，引擎会在适当的时候，将这个操作记录更新到磁盘，这个更新往往是在系统比较空闲的时候做 redo log 大小固定，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，所有文件组成一块“粉板” write pos 是当前记录的位置，一边写一边后移，写到文件末尾后会回到文件开头 checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。 如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 crash-safe：有了 redo log，InnoDB 可以保证数据库发生异常重启也不丢失数据 重要的日志模块：binlog（归档日志） 是 Server 层的日志 statement 格式：记 SQL 语句 row 格式：记录行的内容，记两条，更新前和更新后都有 建议使用 Redo Log 和 Binlog 的不同 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 逻辑：其他引擎都能用，都讲得通这个“逻辑” 物理：只有“我“能用，别人没有共享我的”物理格式“ redo log 是循环写，空间固定会用完；binlog 是追加写入。 “追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 两阶段提交 提交流程 redolog 的 prepare 阶段 写 binlog redolog 的 commit 在 2 之前崩溃时，重启恢复后发现没有 commit，回滚；备份恢复，没有 binlog。一致 在 3 之前崩溃，重启恢复后发现虽然没有 commit，但满足 prepare 和 binlog 完整，自动 commit；备份恢复，有 binlog。一致 设置建议 innodb_flush_log_at_trx_commit 建议设置成 1，表示每次事务的 redo log 都直接持久化到磁盘，保证 MySQL 异常重启之后数据不丢失 sync_binlog 建议设置成 1，表示每次事务的 binlog 都持久化到磁盘，保证 MySQL 异常重启之后 binlog 不丢失 答疑文章（一） MySQL 怎么知道 Binlog 是完整的？ 一个事务的 binlog 有完整格式： statement 格式的 binlog，最后会有 COMMIT； row 格式的 binlog，最后会有一个 XID event。 MySQL 5.</description></item><item><title>03｜事务隔离：为什么你改了为还看不见？</title><link>https://wangze.tech/03%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E4%B8%BA%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</link><pubDate>Wed, 17 May 2023 09:40:20 +0800</pubDate><guid>https://wangze.tech/03%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E4%B8%BA%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</guid><description>隔离型与隔离级别 读未提交 read uncommitted 一个事务还没提交时，它做的变更就能被别的事务看到。 别人改数据的事务尚未提交，我在我的事务中也能读到。 读提交 read committed 一个事务提交之后，它做的变更才会被其他事务看到。 别人改数据的事务已经提交，我在我的事务中才能读到。 可重复读 repeatable read 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 别人改数据的事务已经提交，我在我的事务中也读不到。 串行化 serializable 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 我的事务尚未提交，别人就别想改数据。 事务隔离的实现 以可重复读为例 每条记录在更新的时候会同时记录一条回滚操作 记录上的最新值，通过回滚操作，都可以得到前一个状态的值 系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志才会被删除 如事务提交之前都可能用到 不要使用长事务 MySQL 5.</description></item><item><title>01｜基础架构：一条 SQL 查询语句是如何执行的？</title><link>https://wangze.tech/01%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 09:36:32 +0800</pubDate><guid>https://wangze.tech/01%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>MySQL 的逻辑链接架构图 1. 客户端连接数据库 wait_timeout 参数控制连接器长时间没操作自动断开的时间 断开后再发送请求会报错 对已连接用户的权限做了修改，只有新建的连接才会使用新的权限设置 尽量使用长连接 问题：可能内存疯涨，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放 两个解决方案 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，主动断开连接，之后要查询再重连 MySQL 5.</description></item><item><title>MySQL 实战 45 讲</title><link>https://wangze.tech/MySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/</link><pubDate>Wed, 17 May 2023 09:23:16 +0800</pubDate><guid>https://wangze.tech/MySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/</guid><description> 内容整理自极客时间 《MySQL 实战 45 讲》
章节分类 分类名 章节 基础知识 01 索引 04、05、09、10、11、15、16、18 事务 03、08、20 锁 06、07、13、19、20、21、30、40 日志与主备 02、12、23、24、25、26、27、28、29、31 临时表 17、34、35、36、37、43 实用性 14、32、33、38、41、44、45 基础篇 [[01｜基础架构：一条 SQL 查询语句是如何执行的？]] [[02｜日志系统：一条 SQL 更新语句是如何执行的？]] [[03｜事务隔离：为什么你改了为还看不见？]] [[04｜深入浅出索引（上）]] [[05｜深入浅出索引（下）]] [[06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？]] [[07｜行锁功过：怎么减少锁对性能的影响？]] [[08｜事务到底是隔离的还是不隔离的？]] 实践篇 [[09｜普通索引和唯一索引，应该怎么选择？]] [[10｜MySQL 为什么有时候会选错索引？]] [[11｜怎么给字符串字段加索引？]] [[12｜为什么我的 MySQL 会“抖”一下？]] [[13｜为什么表数据删掉一半，表文件大小不变？]] [[14｜count(*) 这么慢，我该怎么办？]] [[15｜答疑文章（一）：日志和索引相关问题]] [[16｜“order by”是怎么工作的？]] [[17｜如何正确地显示随机消息？]] [[18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？]] [[19｜为什么我只查一行的语句，也执行这么慢？]] [[20｜幻读是什么，幻读有什么问题？]] [[21｜为什么我只改一行的语句，锁这么多？]] [[22｜MySQL有哪些“饮鸩止渴”提高性能的方法？]] [[23｜MySQL 是怎么保证数据不丢的？]] [[24｜MySQL 是怎么保证主备一致的？]] [[25｜MySQL 是怎么保证高可用的？]] [[26｜备库为什么会延迟好几个小时？]] [[27｜主库出问题了，从库怎么办？]] [[28｜读写分离有哪些坑？]] [[29｜如何判断一个数据库是不是出问题了？]] [[30｜答疑文章（二）：用动态的观点看加锁]] [[31｜误删数据后除了跑路，还能怎么办？]] [[32｜为什么还有 kill 不掉的语句？]] [[33｜我查这么多数据，会不会把数据库内存打爆？]] [[34｜到底可不可以使用 join ？]] [[35｜join 语句怎么优化？]] [[36｜为什么临时表可以重名？]] [[37｜什么时候会使用内部临时表？]] [[38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？]] [[39｜自增主键为什么不是连续的？]] [[40｜insert 语句的锁为什么这么多？]] [[41｜怎么最快地复制一张表？]] [[42｜grant 之后要跟着 flush privileges 吗？]] [[43｜要不要使用分区表？]] [[44｜答疑文章（三）：说一说这些好问题]] [[45｜自增 id 用完怎么办？]]</description></item><item><title>特殊字符</title><link>https://wangze.tech/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link><pubDate>Tue, 16 May 2023 16:34:45 +0800</pubDate><guid>https://wangze.tech/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</guid><description> &amp;amp;#64 表示邮箱的 at 符号，否则发布后显示 email protected 上面的编码在代码块里无效，但直接用 at 符号会被当成邮箱</description></item><item><title>抢红包系统</title><link>https://wangze.tech/%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 15 May 2023 22:03:40 +0800</pubDate><guid>https://wangze.tech/%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/</guid><description>不能超抢 剩余的到期需要返还 通常使用的解决高并发问题方案 方案一：使用内存操作替代实时的 DB 事务操作 可能丢数据
方案二：使用乐观锁替代悲观锁 同时抢的只能有一个能成功，可能手慢的反而能抢到
微信红包系统的高并发解决方案
方案三：将关于同一个红包的所有请求聚合到同一个 双维度库表设计：db_xx.t_y_dd xx/y 红包 ID 的 hash 值后三位，dd 的取值范围 01～31，一个月最多 31 天</description></item><item><title>秒杀系统</title><link>https://wangze.tech/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 15 May 2023 21:55:29 +0800</pubDate><guid>https://wangze.tech/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</guid><description>主要问题：并发读、并发写
关键点 高性能 一致性 高可用 原则 请求数据要尽量少 减少序列化和反序列化 字符转化 请求数要尽量少 如在请求路径上将多个 Javascript 用逗号合并，服务端一次性返回多个文件 路径要尽量短 将多个相互强依赖的应用合并部署到一起 依赖要尽量少 可以把依赖的服务先降级或停用 不要有单点 将服务无状态化，让实例可以动态伸缩 把秒杀系统独立出来单独打造一个系统，并且在系统部署上也独立做一个机器集群，避免影响非秒杀商品的机器 动静分离 根据情况把静态数据缓存到离用户近的地方（浏览器、CDN、服务端的 Cache） 直接缓存 HTTP 连接 怎么做： URL 唯一化（如 /id=xxx） 分离浏览者相关的因素（比如登录信息，这些通过动态请求获取） 分离时间因素，也通过动态请求获取 异步化地域因素 去掉 Cookie（让缓存的静态数据中不含有 Cookie） 服务端： 生成完整页面 客户端获取动态内容 架构方案 实体机单机部署：大 Cache 容量，高缓存命中率 统一 Cache 层 上 CDN：二级 Cache（一级发现没缓存数据就去二级找，都没有就回源获取数据并缓存到一级、二级缓存） 热点数据 静态热点数据：能提前预测的 通过商业手段（强制让商家登记、对买家每天访问的商品进行大数据计算） 动态热点数据：不能提前预测的 （异步）收集交易链路上各个环节中的中间件产品的热点 Key（Nginx、缓存、RPC 服务框架等） 上报热点，透传给下游系统 流量削峰 排队 答题：延缓请求，并可以防止买家使用秒杀器作弊 分层过滤：只在写数据时进行强一致性校验 性能优化 影响：</description></item><item><title>本地预览</title><link>https://wangze.tech/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88/</link><pubDate>Sun, 14 May 2023 13:04:38 +0800</pubDate><guid>https://wangze.tech/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88/</guid><description>准备 ⚠️ 不要在你正式写笔记的发布仓库和文档仓库里操作 复制你要预览的仓库到新文件夹 进入新文件夹 将笔记转成发布仓库支持的格式 ⚠️ 这一步会修改你的笔记文档
1 2 3 4 5 6 7 git submodule update --init --recursive rm -rf content/.</description></item><item><title>Crontab 执行提示没有权限</title><link>https://wangze.tech/Crontab-%E6%89%A7%E8%A1%8C%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</link><pubDate>Sat, 13 May 2023 23:54:24 +0800</pubDate><guid>https://wangze.tech/Crontab-%E6%89%A7%E8%A1%8C%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</guid><description> Mac 的解决方案： How to Fix Cron &amp;ldquo;Operation not permitted&amp;rdquo; error in macOS - ITPro Helper</description></item><item><title>配置 Google Analytics</title><link>https://wangze.tech/%E9%85%8D%E7%BD%AE-Google-Analytics/</link><pubDate>Sat, 13 May 2023 18:35:42 +0800</pubDate><guid>https://wangze.tech/%E9%85%8D%E7%BD%AE-Google-Analytics/</guid><description>配置方法 到 Google Analytics（分析） 创建一个媒体资源并获取 ID 打开发布仓库根目录下的 config.toml 文件 写入：googleAnalytics = &amp;quot;G-XXX&amp;quot; 打开发布仓库的 layouts/partials/header.html 文件 在末尾写入：{{ template &amp;quot;_internal/google_analytics.</description></item><item><title>本库自动提交到 GitHub</title><link>https://wangze.tech/%E6%9C%AC%E5%BA%93%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E5%88%B0-GitHub/</link><pubDate>Sat, 13 May 2023 14:19:34 +0800</pubDate><guid>https://wangze.tech/%E6%9C%AC%E5%BA%93%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E5%88%B0-GitHub/</guid><description> 配置 crontab 每天自动执行 auto_push.sh 可能遇到的问题：[[Crontab 执行提示没有权限]] 由于已配置 GitHub Action，自动提交后会触发 Action 自动部署网站</description></item><item><title>换新设备</title><link>https://wangze.tech/%E6%8D%A2%E6%96%B0%E8%AE%BE%E5%A4%87/</link><pubDate>Sat, 13 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%8D%A2%E6%96%B0%E8%AE%BE%E5%A4%87/</guid><description>推荐做法 clone 文档仓库到本地 将 .git 移到 iCloud 的 Obsidian 目录下的花园 [[Vault]] 根目录 强烈不推荐做法 删掉 iCloud 里的 [[Vault]] 再走一遍 [[同步方案]]</description></item><item><title>文章最后更新时间错误</title><link>https://wangze.tech/%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF/</link><pubDate>Sat, 13 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%96%87%E7%AB%A0%E6%9C%80%E5%90%8E%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF/</guid><description>解决方法 在发布仓库做如下修改，让 Lastmod 比 Date 优先级高 修改发布仓库的 GitHub Action： Hugo 和 Github Action 正确修改文章的最后更新日期
修改文档仓库的 GitHub Action</description></item><item><title>添加评论区</title><link>https://wangze.tech/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8C%BA/</link><pubDate>Sat, 13 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8C%BA/</guid><description> 到 giscus 生成自己的评论区代码并复制 到发布仓库找到以下文件，将代码粘贴到图中红框位置</description></item><item><title>配置图床</title><link>https://wangze.tech/%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/</link><pubDate>Sat, 13 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/</guid><description> 使用 PicGo + Github + JSD 搭建免费图床 | ZeaLotSean jsDelivr</description></item><item><title>配置自定义域名</title><link>https://wangze.tech/%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</link><pubDate>Sat, 13 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</guid><description>Vercel + Cloudflare How to Use a Cloudflare Domain with Vercel</description></item><item><title>iCloud 不同步指定文件</title><link>https://wangze.tech/iCloud-%E4%B8%8D%E5%90%8C%E6%AD%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/iCloud-%E4%B8%8D%E5%90%8C%E6%AD%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6/</guid><description>说明 iCloud 不同步带有 .nosync 后缀的文件和文件夹
使用场景 在 iCloud 中忽略 .git 且 Git 命令可以正常使用 1 2 3 cd repo mv .</description></item><item><title>Obsidian</title><link>https://wangze.tech/Obsidian/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Obsidian/</guid><description> 官网 Obsidian 是一个功能强大且可扩展的知识库，它在您的本地纯文本文件文件夹之上运行。 此数字花园的文本编辑器</description></item><item><title>Vault</title><link>https://wangze.tech/Vault/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Vault/</guid><description>保管库是本地文件系统上的一个文件夹，Obsidian 将您的笔记存储在其中。您可以将所有笔记保存在一个保险库中，或为每个不同的项目创建多个保险库。
Create a vault - Obsidian Help</description></item><item><title>发布方案</title><link>https://wangze.tech/%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88/</guid><description>选用方案 quartz 怎么做 注意事项 参考文章 Making your own Quartz 001_部署Obsidian静态知识库网站</description></item><item><title>同步方案</title><link>https://wangze.tech/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</guid><description>多种方案 Obsidian Sync：官方，要钱 Remotely Sync：第三方插件，但自动同步最短间隔 1 分钟（可以手动同步），免费 iCloud：实时同步，免费 我使用的同步方案（iCloud） 优点 免费实时同步文档、插件、设置
怎么做 我的设备：iPhone + MacBook
iPhone 安装 [[Obsidian]]</description></item><item><title>常见错误</title><link>https://wangze.tech/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</guid><description>Connection Closed by 20.205.243.166 Port 22 添加以下代码到 ~/.ssh/config
1 2 3 4 Host github.com HostName ssh.github.com User username Port 443</description></item><item><title>搭建数字花园</title><link>https://wangze.tech/%E6%90%AD%E5%BB%BA%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%90%AD%E5%BB%BA%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</guid><description> [[同步方案]] [[发布方案]] [[配置自定义域名]] [[添加评论区]] [[配置图床]] [[配置 Google Analytics]] [[本库自动提交到 GitHub]] [[本地预览]] [[iCloud 不同步指定文件|不同步 .git 文件夹]] [[换新设备]] [[问题合集]] 参考： Setup | Quartz</description></item><item><title>油猴脚本</title><link>https://wangze.tech/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/</guid><description>安装说明 Greasy Fork - safe and useful user scripts 我发布的脚本 https://github.com/11ze/user-scripts 推荐脚本 Endless Google: Google 搜索结果列表可以无限下拉 redirect 外链跳转: 从 QQ 邮箱、知乎等网站点击外链时自动跳转，免去点击步骤</description></item><item><title>笔记 404</title><link>https://wangze.tech/%E5%8F%91%E5%B8%83%E7%AC%94%E8%AE%B0-404/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E5%8F%91%E5%B8%83%E7%AC%94%E8%AE%B0-404/</guid><description>记录此问题的时间：[[2023-05-12]] 01:26 东八区
现象：
[[油猴脚本]] 在 [[2023-05-12]] 0 点创建，发布失败，改成 2023-05-11，发布成功 笔记出现在搜索结果，点击自动跳转到 404 页面 猜测：执行发布的 GitHub Action 服务器时间比文档头标记的创建时间早，文档属于未来，所以未发布成功</description></item><item><title>问题合集</title><link>https://wangze.tech/%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</guid><description> [[发布笔记 404]] [[文章最后更新时间错误]]</description></item><item><title>About Atlas</title><link>https://wangze.tech/About-Atlas/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/About-Atlas/</guid><description/></item><item><title>Capslock</title><link>https://wangze.tech/Capslock/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Capslock/</guid><description>功能 加强 Caps 键功能
安装 Github
单击 Caps 切换输入法 打开配置文件 ~/.config/karabiner/karabiner.json 做如下修改： 找到 caps_lock 的 to_if_alone 将 key_code 改成 caps_lock 找到 spacebar = language switch 删除所在 {} 代码块 目的：维持单点 Caps 切换输入法</description></item><item><title>Linux 安装 oh-my-zsh</title><link>https://wangze.tech/Linux-%E5%AE%89%E8%A3%85-oh-my-zsh/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Linux-%E5%AE%89%E8%A3%85-oh-my-zsh/</guid><description>安装 Zsh https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH
1 2 3 4 5 6 7 8 9 10 sudo apt install zsh # 查看所有可用 shell chsh -l # 将终端默认 shell 切换到 zsh，后面要输入实际看到的 zsh 路径 chsh -s /bin/zsh # 新开一个终端确认是否切换成功 echo $SHELL 安装 Oh-my-zsh https://ohmyz.</description></item><item><title>Oh My Zsh</title><link>https://wangze.tech/Oh-My-Zsh/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Oh-My-Zsh/</guid><description>Linux 用户请看：[[Linux 安装 oh-my-zsh]]
安装 切换到系统自带的 Zsh：chsh -s /bin/zsh Oh My Zsh 系统终端的配色方案 Powerlevel10k</description></item><item><title>PHP-FPM 配置</title><link>https://wangze.tech/PHP-FPM-%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/PHP-FPM-%E9%85%8D%E7%BD%AE/</guid><description>以下内容适用于 IO 密集型应用
一个 PHP-FPM 进程大约占 30M 内存
进程数量 计算公式：进程数 = 内存大小（M） * 0.6 / 30 举例：8G * 1024 * 0.</description></item><item><title>学习方法</title><link>https://wangze.tech/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid><description>费曼学习法 https://mp.weixin.qq.com/s/mUAQX_2b0Ut3APWB-pyYSQ
在纸上写下要学习的知识点 写下自己对于这个知识点所知的一切, 然后假装讲给一个孩子听 反复理解: 复习卡住的地方, 直到能用大白话讲清楚为止 在第二步的基础上进行补充和简化, 循环 高效学习: 深度, 归纳和坚持时间 https://time.</description></item><item><title>收藏文章</title><link>https://wangze.tech/%E6%94%B6%E8%97%8F%E6%96%87%E7%AB%A0/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%94%B6%E8%97%8F%E6%96%87%E7%AB%A0/</guid><description>技术 Linter上手完全指南 一文搞懂 Redis 架构演化之路 规范 编程中的命名设计那点事 | 酷 壳 - CoolShell 经济 经济是机器怎样运行的 沟通 X-Y Problem | 酷 壳 - CoolShell 你会问问题吗？ | 酷 壳 - CoolShell</description></item><item><title>背单词</title><link>https://wangze.tech/%E8%83%8C%E5%8D%95%E8%AF%8D/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E8%83%8C%E5%8D%95%E8%AF%8D/</guid><description>准备 手机安装不背单词 APP 浏览器安装 不背单词查词 制作生词本 APP 内添加生词 到不背单词首页下拉弹出单词搜索框 输入单词或短语到搜索框进行搜索 点击搜索结果 点击星星图标添加到生词本 在网页添加生词 划词 在弹出的窗口点击添加生词 开始背单词 将生词本设置为正在学习的词书 在 APP 进行学习 生词来源 英文文章 英文文档 生词的例句或英文解释</description></item><item><title>英语</title><link>https://wangze.tech/%E8%8B%B1%E8%AF%AD/</link><pubDate>Thu, 11 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E8%8B%B1%E8%AF%AD/</guid><description> [[Think in English]] 跟宝藏 UP 视频学： 【M14】英语学习唯一正确方法具体实践_哔哩哔哩 [[背单词]]</description></item><item><title>Laravel Pint 使用</title><link>https://wangze.tech/Laravel-Pint-%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 09 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Laravel-Pint-%E4%BD%BF%E7%94%A8/</guid><description>参考：
https://laraveldaily.com/post/laravel-pint-pre-commit-hooks-github-actions</description></item><item><title>PHP 错误码设计</title><link>https://wangze.tech/PHP-%E9%94%99%E8%AF%AF%E7%A0%81%E8%AE%BE%E8%AE%A1/</link><pubDate>Tue, 09 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/PHP-%E9%94%99%E8%AF%AF%E7%A0%81%E8%AE%BE%E8%AE%A1/</guid><description>目标 错误码包含：数字、英文、含义，还可以有 HTTP Status
这些最好放到一起，不然添加时容易漏
方案 静态变量：数组
多个名字类似的静态变量
静态工厂方法
枚举和注解
讨论 结论 参考 Using attributes to add value</description></item><item><title>iCloud 同步卡住</title><link>https://wangze.tech/iCloud-%E5%90%8C%E6%AD%A5%E5%8D%A1%E4%BD%8F/</link><pubDate>Mon, 08 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/iCloud-%E5%90%8C%E6%AD%A5%E5%8D%A1%E4%BD%8F/</guid><description>解决方案 ~/.zshrc 1 2 # ~/.zshrc alias killicloud=&amp;#39;killall bird &amp;amp;&amp;amp; killall cloudd&amp;#39; 终端执行命令 kill iCloud 进程 1 killicloud 点击访达侧边栏的 iCloud ，观察同步进度，若还是卡住，继续 kill iCloud 进程直到正常</description></item><item><title>3-2-1 的有趣想法</title><link>https://wangze.tech/3-2-1-%E7%9A%84%E6%9C%89%E8%B6%A3%E6%83%B3%E6%B3%95/</link><pubDate>Sun, 07 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/3-2-1-%E7%9A%84%E6%9C%89%E8%B6%A3%E6%83%B3%E6%B3%95/</guid><description>内容摘抄自： https://jamesclear.com/3-2-1
想法 If you&amp;rsquo;re searching for more time this year, start with a clean slate and choose what to add to your days rather than starting with a full schedule and trying to figure out what to eliminate.</description></item><item><title>Obsidian 插件</title><link>https://wangze.tech/Obsidian-%E6%8F%92%E4%BB%B6/</link><pubDate>Sun, 07 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Obsidian-%E6%8F%92%E4%BB%B6/</guid><description>推荐 Enhancing Mindmap：思维导图，只需修改文档头，没有额外学习成本 其他 2022年7月，obsidian 依然必装的 10 个插件</description></item><item><title>README</title><link>https://wangze.tech/README/</link><pubDate>Sun, 07 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/README/</guid><description>🪴 11ze&amp;rsquo;s Garden</description></item><item><title>Tips</title><link>https://wangze.tech/Tips/</link><pubDate>Sun, 07 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Tips/</guid><description> 想到什么点子就赶紧记下来，不然过一会就忘了，即使只是上个厕所洗个手也会忘。 做一件事的时候，想象一下，最坏的情况能坏到哪呢。 你花在挑选寝室用的电视机上的时间比你选择专业和学习领域的时间长。 找出自己擅长和不擅长做的事。 什么工作是我非做不可的。 用搜索。</description></item><item><title>开发环境</title><link>https://wangze.tech/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 07 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>设备 MacBook Pro（M1） 先更新系统 Homebrew 官网 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 brew tap homebrew/cask-drivers brew tap homebrew/cask-fonts brew tap homebrew/cask-versions brew tap buo/cask-upgrade brew tap mongodb/brew brew install git-lfs brew install git-flow brew install font-jetbrains-mono brew install font-lxgw-wenkai # 访达插件 brew install --cask qlmarkdown # Markdown brew install --cask --no-quarantine syntax-highlight # 代码高亮 brew install --cask qlstephen # 查看没有文件扩展名的纯文本文件 # 以下应用，安装后关闭自动检查更新 brew install --cask font-hack-nerd-font brew install --cask maczip brew install --cask wechatwebdevtools # 微信小程序开发者工具 brew install --cask mini-program-studio # 支付宝小程序开发者工具 brew install --cask macs-fan-control brew install --cask mongodb-compass brew install --cask another-redis-desktop-manager brew install --cask iina # 本地音视频播放器 brew install --cask cheatsheet # 快捷键提示 brew install --cask raycast brew install battery # https://github.</description></item><item><title>PHP 开发设置</title><link>https://wangze.tech/PHP-%E5%BC%80%E5%8F%91%E8%AE%BE%E7%BD%AE/</link><pubDate>Sat, 06 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/PHP-%E5%BC%80%E5%8F%91%E8%AE%BE%E7%BD%AE/</guid><description>Laravel Pint 如何在PHPSTORM 配置Laravel Pint 代码格式化包
Laravel Pint
VSCode</description></item><item><title>Rate Limit</title><link>https://wangze.tech/Rate-Limit/</link><pubDate>Fri, 05 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/Rate-Limit/</guid><description>功能 限制接口请求数
缓存数据格式 1 2 3 4 5 6 7 key: { current_count: number; // 也可以不要该字段，每次请求都算一次队列长度 started_at: date; request_time_queue: date[]; time_range: number; // 时间窗口大小 count_limit: number; } 实现流程 请求进来 拼接出 key 查找 key 对应的缓存 取出队头，跟当前时间比较 a.</description></item></channel></rss>