<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>🫧 11ze</title>
      <link>https://wangze.tech</link>
      <description>Last 10 notes on 🫧 11ze</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>44｜答疑文章（三）：说一说这些好问题</title>
    <link>https://wangze.tech/44%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98</link>
    <guid>https://wangze.tech/44%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98</guid>
    <description>join 的写法 § 在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。 where a.f2=b.f2 就表示，查询结果里面不会包含 b.f2 是 NULL 的行 使用 left join 时，左边的表不一定是驱动表。 如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面 distinct 和 group by 的性能 § 如果只需要去重，不需要执行聚合函数，distinct 和 group by 哪种效率高一些呢？ 没有索引时一样 select a,count(*) from t group by a order by null; 这条语句的逻辑是：按照字段 a 分组，计算每组的 a 出现的次数。在这个结果里，由于做的是聚合计算，相同的 a 只出现一次。37 章有关于 group by 的相关内容 .</description>
    <pubDate>Mon, 20 Nov 2023 01:10:09 GMT</pubDate>
  </item><item>
    <title>30｜答疑文章（二）：用动态的观点看加锁</title>
    <link>https://wangze.tech/30%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81</link>
    <guid>https://wangze.tech/30%EF%BD%9C%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81</guid>
    <description>下面的讨论基于此表 CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); show engine innodb status 命令输出的信息中，LATESTADETECTED DEADLOCK 记录了最后一次死锁信息 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问； 在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lock in share mode 语句，来回滚。 所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。 思考题 § 空表的间隙的定义 一个空表只有一个间隙 比如执行：begin; select * from t where id&gt;1 for update; 加锁范围：next_key lock (-∞, supremum] 评论区 § 删除数据，导致锁扩大的描述：“因此，我们就知道了，由于 delete 操作把 id=10 这一行删掉了，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。”我觉得这个提到的(5, 10) 和 (10, 15)两个间隙会让人有点误解，实际上在删除之前间隙锁只有一个(10, 15)，删除了数据之后，导致间隙锁左侧扩张成了5，间隙锁成为了(5, 15)。 .</description>
    <pubDate>Mon, 20 Nov 2023 01:10:09 GMT</pubDate>
  </item><item>
    <title>PHP 测试</title>
    <link>https://wangze.tech/PHP-%E6%B5%8B%E8%AF%95</link>
    <guid>https://wangze.tech/PHP-%E6%B5%8B%E8%AF%95</guid>
    <description> 10 testing best practices for Laravel in 2023 .</description>
    <pubDate>Thu, 02 Nov 2023 06:31:17 GMT</pubDate>
  </item><item>
    <title>Laravel Pint 使用</title>
    <link>https://wangze.tech/Laravel-Pint-%E4%BD%BF%E7%94%A8</link>
    <guid>https://wangze.tech/Laravel-Pint-%E4%BD%BF%E7%94%A8</guid>
    <description> 参考：https://laraveldaily.com/post/laravel-pint-pre-commit-hooks-github-actions PhpStorm 已内置支持，可在设置里搜索到并主动打开 Vscode 安装插件：https://marketplace.visualstudio.</description>
    <pubDate>Wed, 01 Nov 2023 05:04:02 GMT</pubDate>
  </item><item>
    <title>Linux 安装 oh-my-zsh</title>
    <link>https://wangze.tech/Linux-%E5%AE%89%E8%A3%85-oh-my-zsh</link>
    <guid>https://wangze.tech/Linux-%E5%AE%89%E8%A3%85-oh-my-zsh</guid>
    <description>安装 Zsh § https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH sudo apt install zsh # 查看所有可用 shell chsh -l # 将终端默认 shell 切换到 zsh，后面要输入实际看到的 zsh 路径 chsh -s /bin/zsh # 新开一个终端确认是否切换成功 echo $SHELL 安装 Oh-my-zsh § https://ohmyz.</description>
    <pubDate>Thu, 21 Sep 2023 08:08:56 GMT</pubDate>
  </item><item>
    <title>开发环境</title>
    <link>https://wangze.tech/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83</link>
    <guid>https://wangze.tech/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83</guid>
    <description>设备 § M1 MacBook Pro 14 先更新系统 Homebrew § 官网 brew tap homebrew/cask-drivers brew tap homebrew/cask-fonts brew tap homebrew/cask-versions brew tap buo/cask-upgrade brew tap mongodb/brew brew install git git-lfs git-flow git config --global core.</description>
    <pubDate>Wed, 06 Sep 2023 03:24:09 GMT</pubDate>
  </item><item>
    <title>Redis 客户端如何与服务端交换命令和数据？</title>
    <link>https://wangze.tech/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E6%8D%A2%E5%91%BD%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE%EF%BC%9F</link>
    <guid>https://wangze.tech/Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E6%8D%A2%E5%91%BD%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE%EF%BC%9F</guid>
    <description>客户端和服务端交互内容 § 命令 键 单个值 集合值 OK 回复 整数回复 错误信息 RESP 2 协议 § 两个基本规范 实现 5 种编码格式类型，在每种编码类型的开头使用一个专门的字符区分 按照单个命令或单个数据的粒度进行编码，在每个编码结果后面增加一个换行符 \r\n 表示编码结束 简单字符串类型 RESP Simple Strings +OK\r\n 长字符串类型 RESP Bulk String $9 testvalue\r\n Redis SDS 结构 len = 14; alloc; buf (“Redis\0Cluster\0”) \0 解析成正常的 0 字符 最大 512MB 整数类型 RESP Integer :3\r\n 错误类型 RESP Errors -ERR unknown command PUT, with args beginning with: testkey, testvalue 数组编码类型 RESP Arrays *2\r\n3\nGET˚​\n˚​7\r\ntestkey\r\n 2：数组元素个数，命令 GET 和键 testkey 不足 只能区分字符串和整数，其他类型需要客户端进行额外的转换操作 使用数组类别编码表示所有的集合类型，客户端需要根据发送的命令操作把返回结果转换成相应的集合类型数据结构 RESP 2 协议的 5 种编码类型和相应的开头字符 RESP 3 协议（6.</description>
    <pubDate>Wed, 06 Sep 2023 02:08:56 GMT</pubDate>
  </item><item>
    <title>从微博的 Redis 实践中，我们可以学到哪些经验？</title>
    <link>https://wangze.tech/%E4%BB%8E%E5%BE%AE%E5%8D%9A%E7%9A%84-Redis-%E5%AE%9E%E8%B7%B5%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AD%A6%E5%88%B0%E5%93%AA%E4%BA%9B%E7%BB%8F%E9%AA%8C%EF%BC%9F</link>
    <guid>https://wangze.tech/%E4%BB%8E%E5%BE%AE%E5%8D%9A%E7%9A%84-Redis-%E5%AE%9E%E8%B7%B5%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AD%A6%E5%88%B0%E5%93%AA%E4%BA%9B%E7%BB%8F%E9%AA%8C%EF%BC%9F</guid>
    <description>微博对 Redis 的技术需求 § 能够提供高性能、高并发的读写访问，保证读写延迟低 能够支持大容量存储 可以灵活扩展，对于不同业务能进行快速扩容 对 Redis 的基本改进 § 避免阻塞和节省内存 持久化需求：使用全量 RDB + 增量 AOF 复制 在 AOF 日志写入刷盘时，用额外的 BIO 线程负责实际的刷盘工作，避免 AOF 日志慢速刷盘阻塞主线程 增加 aofnumber 配置项设置 AOF 文件的数量 使用独立的复制线程进行主从库同步，避免对主线程的阻塞影响 定制化设计了 LongSet 数据类型 § 数据区分冷热度 § 用异步线程将冷数据从 Redis 迁移到 RocksDB，保存到硬盘中 服务化改造 § 使用 Redis 集群服务不同的业务场景需求，每一个业务拥有独立的资源 所有的 Redis 实例形成资源池，轻松扩容 采用类似 Codis 的方案，通过集群代理层连接客户端和服务端 客户端连接监听和端口自动增删 Redis 协议解析：确定需要路由的请求，如果是非法和不支持的请求，直接返回错误 请求路由：根据数据和后端实例间的映射规则，将请求路由到对应的后端实例进行处理，并将结果返回给客户端 指标采集监控：采集集群运行的状态，并发送到专门的可视化组件，由这些组件进行监控处理 配置中心：管理整个集群的元数据 微博 Redis 服务化集群架构图 原文 § 万亿级日访问量下，Redis 在微博的 9 年优化历程 .</description>
    <pubDate>Wed, 06 Sep 2023 02:05:56 GMT</pubDate>
  </item><item>
    <title>39｜Redis 6.0 的新特性：多线程、客户端缓存与安全</title>
    <link>https://wangze.tech/39%EF%BD%9CRedis-6.0-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E5%AE%89%E5%85%A8</link>
    <guid>https://wangze.tech/39%EF%BD%9CRedis-6.0-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E5%AE%89%E5%85%A8</guid>
    <description>多 IO 线程 § 作用：使用多个 IO 线程并行读取网络请求、进行协议解析、回写 Socket 主线程和 IO 线程协作完成请求处理 阶段一：服务端和客户端建立 Socket 连接，并分配处理线程 阶段二：IO 线程读取并解析请求 阶段三：主线程执行请求操作 阶段四：IO 线程回写 Socket 和主线程清空全局队列 启用多线程命令：io-threads-do-reads yes 设置线程个数命令：io-threads 6 一般要小于实例所在机器的 CPU 核个数 例如，对于一个 8 核的机器来说，Redis 官方建议配置 6 个 IO 线程 如果在实际应用中，发现 Redis 实例的 CPU 开销不大，吞吐量却没有提升，可以考虑使用 Redis 6.</description>
    <pubDate>Wed, 06 Sep 2023 01:59:56 GMT</pubDate>
  </item><item>
    <title>38｜通信开销：限制 Redis Cluster 规模的关键因素</title>
    <link>https://wangze.tech/38%EF%BD%9C%E9%80%9A%E4%BF%A1%E5%BC%80%E9%94%80%EF%BC%9A%E9%99%90%E5%88%B6-Redis-Cluster-%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0</link>
    <guid>https://wangze.tech/38%EF%BD%9C%E9%80%9A%E4%BF%A1%E5%BC%80%E9%94%80%EF%BC%9A%E9%99%90%E5%88%B6-Redis-Cluster-%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0</guid>
    <description> Redis Cluster 实例间以 Gossip 协议进行通信的机制 Gossip 协议的工作原理 两个实例间进行 PING、PONG 消息传递的情况 每个实例默认每秒从集群中随机挑选一些实例，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息 PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表 一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样 Gossip 消息大小 PING 和 PONG 消息的消息体都大约 12KB PING 消息中带有一个长度为 16384 bit 的 Bitmap 每一位对应一个 Slot，如果某一位为 1，表示这个 Slot 属于当前实例 实例间通信频率 Gossip 协议的工作原理第二点 实例每 100ms 扫描本地的实例列表，如果发现有实例最近一次接收 PONG 消息的时间已经大于配置项 cluster-node-timeout 的一半，就会立刻给该实例发送 PING 消息，更新这个实例上的集群状态信息 每秒会发送的 PING 消息数量 = 1 + 10 * 实例数 实例数 = 最近一次接收 PONG 消息的时间超出 cluster-node-timeout/2 降低实例间的通信开销 不能减小实例传输的消息大小 只能修改 cluster-node-timeout 配置项 默认 15 秒，调大到 20 或 25 秒 验证调整后的值是否能减少心跳消息占用的集群网络带宽 调整前后使用 tcpdump 命令抓取实例发送心跳信息网络包的情况 例如，执行：tcpdump host 192.</description>
    <pubDate>Wed, 06 Sep 2023 01:53:56 GMT</pubDate>
  </item>
    </channel>
  </rss>