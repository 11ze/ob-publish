<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>🫧 11ze</title>
      <link>https://wangze.tech</link>
      <description>Last 10 notes on 🫧 11ze</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>00｜开篇词</title>
    <link>https://wangze.tech/00%EF%BD%9C%E5%BC%80%E7%AF%87%E8%AF%8D</link>
    <guid>https://wangze.tech/00%EF%BD%9C%E5%BC%80%E7%AF%87%E8%AF%8D</guid>
    <description>Redis 的两大维度，三大主线 § Redis 问题画像图 § .</description>
    <pubDate>Fri, 01 Sep 2023 13:27:56 GMT</pubDate>
  </item><item>
    <title>01｜基础架构：一个键值数据库包含什么？</title>
    <link>https://wangze.tech/01%EF%BD%9C%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F</link>
    <guid>https://wangze.tech/01%EF%BD%9C%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F</guid>
    <description> 操作模块 PUT：新写入或更新一个 key-value 对，如 PUT hello world GET：根据 K 读取 V DELETE：根据 K 删除整个 KV 对 SCAN：根据一段 key 的范围返回相应的 value 值 访问模式 通过函数库调用的方式供外部应用使用 通过网络框架以 Socket 通信的形式对外提供键值对操作 I/O 模型设计 单线程、多线程、多进程 索引模块 让键值数据库根据 key 找到 value 的存储位置，进而执行操作 Memcached 和 Redis 采用哈希表作为 key-value 索引 内存的高性能随机访问特性和哈希表 O(1) 的操作复杂度相匹配 存储模块 分配器 内存：读写快，掉电数据丢失 外存：读写慢，数据持久化 持久化 对于每个键值对都进行落盘保存 数据可靠 性能差 周期性把内存中的键值数据保存到文件 数据可能丢失 性能较好 从 SimpleKV 到 Redis 的架构图转变 从键值数据库开发和运维的辅助工具上做对比 .</description>
    <pubDate>Sun, 03 Sep 2023 09:31:56 GMT</pubDate>
  </item><item>
    <title>01｜基础架构：一条 SQL 查询语句是如何执行的？</title>
    <link>https://wangze.tech/01%EF%BD%9C%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F</link>
    <guid>https://wangze.tech/01%EF%BD%9C%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F</guid>
    <description>MySQL 的逻辑链接架构图 § 1. 客户端连接数据库 § wait_timeout 参数控制连接器长时间没操作自动断开的时间 只有新建的连接才会使用新的权限设置 尽量使用长连接 使用长连接的问题：可能内存疯涨，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面，在连接断开的时候才释放 两个解决方案 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，主动断开连接，之后要查询再重连 MySQL 5.</description>
    <pubDate>Tue, 22 Aug 2023 15:19:56 GMT</pubDate>
  </item><item>
    <title>02｜数据结构：快速的 Redis 有哪些慢操作？</title>
    <link>https://wangze.tech/02%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C%EF%BC%9F</link>
    <guid>https://wangze.tech/02%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C%EF%BC%9F</guid>
    <description> Redis 数据类型和底层数据结构的对应关系 Redis 使用一个哈希表 O(1) 保存所有键值对 全局哈希表（数组） 每个数组元素称为一个哈希桶（指针） 每个哈希桶保存多个键值对数据 计算键的哈希值就可以知道对应的哈希桶位置 哈希冲突 两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。 解决方案：链式哈希。同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。 当一个桶中的元素过多，访问时间变长时 采用两个全局哈希表，当哈希表 1 不够大时 copy 到更大的哈希表 2 rehash：增加现有哈希桶的数量 装载因子的大小 = 所有 entry 个数除以哈希表的哈希桶个数 &lt; 1 或者在进行 RDB 和 AOF 重写时禁止 rehash = 1，且允许进行 rehash 时会进行 rehash = 5，立马开始 rehash 渐进式 rehash（实际） 每次处理请求时，顺带拷贝一部分数据到另一个哈希表。 定时任务周期性地搬移一些数据到新的哈希表中 压缩列表 ziplist 的结构 表头 zlbytes：列表长度 zltail：列表尾的偏移量 zllen：entry 个数 表尾 zlend：列表结束，取值默认是 255 元素 entry prev_len 前一个 entry 的长度 1 字节：上一个 entry 的长度 &lt; 254 字节 5 字节：1 字节以外的情况 prev_len的第一个字节表示一个entry的开始，如果等于255表示列表结束，如果等于254那后四个字节才是prev_len的实际值，如果小于254，那就不需要后四个字节，直接使用这一个字节表示prev_len的实际值 当前一节点长度大于等于254时，第一个字节为254(1111 1110)作为标志，后面4个字节组成一个整型用来存储长度 encoding 编码方式，1 字节 content 实际数据 其他操作同整数数组、双向列表 顺序查找 O(N) 跳表 O(logN)：多级索引，通过索引位置的几个跳转，实现数据的快速定位 不同操作的复杂度 单元素操作是基础 每一种集合类型对单个数据实现的增删改查操作 范围操作非常耗时 集合类型中的遍历操作，可以返回集合中的所有数据 用 SCAN 代替遍历操作 统计操作通常高效 集合类型中对集合中所有元素个数的记录 例外情况只有几个 某些数据结构的特殊记录 .</description>
    <pubDate>Sun, 03 Sep 2023 09:50:56 GMT</pubDate>
  </item><item>
    <title>02｜日志系统：一条 SQL 更新语句是如何执行的？</title>
    <link>https://wangze.tech/02%EF%BD%9C%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1-SQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F</link>
    <guid>https://wangze.tech/02%EF%BD%9C%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1-SQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F</guid>
    <description>Update 语句执行流程 § 重要的日志模块：redo Log § 是 InnoDB 引擎特有的日志 WAL（Write-Ahead Logging）技术 先写日志，再写磁盘 当有一条记录需要更新的时候，InnoDB 引擎先把记录写到 redo log，并更新内存，引擎会在适当的时候，将这个操作记录更新到磁盘，这个更新往往是在系统比较空闲的时候做 redo log 大小固定，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，所有文件组成一块“粉板” write pos 是当前记录的位置，一边写一边后移，写到文件末尾后会回到文件开头 checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。 如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 crash-safe：有了 redo log，InnoDB 可以保证数据库发生异常重启也不丢失数据 重要的日志模块：binlog（归档日志） § 是 Server 层的日志 statement 格式：记 SQL 语句 row 格式：记录行的内容，记两条，更新前和更新后都有 建议使用 Redo Log 和 Binlog 的不同 § redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 逻辑：其他引擎都能用，都讲得通这个“逻辑” 物理：只有“我“能用，别人没有共享我的”物理格式“ redo log 是循环写，空间固定会用完；binlog 是追加写入。 “追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 两阶段提交 § 提交流程 redolog 的 prepare 阶段 写 binlog redolog 的 commit 在 2 之前崩溃时，重启恢复后发现没有 commit，回滚；备份恢复，没有 binlog。一致 在 3 之前崩溃，重启恢复后发现虽然没有 commit，但满足 prepare 和 binlog 完整，自动 commit；备份恢复，有 binlog。一致 设置建议 § innodb_flush_log_at_trx_commit 建议设置成 1，表示每次事务的 redo log 都直接持久化到磁盘，保证 MySQL 异常重启之后数据不丢失 sync_binlog 建议设置成 1，表示每次事务的 binlog 都持久化到磁盘，保证 MySQL 异常重启之后 binlog 不丢失 答疑文章（一） § MySQL 怎么知道 Binlog 是完整的？ § 一个事务的 binlog 有完整格式： statement 格式的 binlog，最后会有 COMMIT； row 格式的 binlog，最后会有一个 XID event。 MySQL 5.</description>
    <pubDate>Tue, 22 Aug 2023 15:19:56 GMT</pubDate>
  </item><item>
    <title>03｜事务隔离：为什么你改了为还看不见？</title>
    <link>https://wangze.tech/03%EF%BD%9C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E4%B8%BA%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F</link>
    <guid>https://wangze.tech/03%EF%BD%9C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E4%B8%BA%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F</guid>
    <description>隔离型与隔离级别 § 读未提交 read uncommitted 一个事务还没提交时，它做的变更就能被别的事务看到。 读提交 read committed 一个事务提交之后，它做的变更才会被其他事务看到。 可重复读 repeatable read 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化 serializable 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 设置隔离级别 select @@transaction_isolation; set @global transaction isolation level read committed; 事务隔离的实现 § 以可重复读为例 每条记录在更新的时候会同时记录一条回滚操作 记录上的最新值，通过回滚操作，都可以得到前一个状态的值 系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志才会被删除 如事务提交之前都可能用到 ⚠️ 不要使用长事务 MySQL 5.</description>
    <pubDate>Tue, 22 Aug 2023 15:19:56 GMT</pubDate>
  </item><item>
    <title>03｜高性能 IO 模型：为什么单线程 Redis 那么快？</title>
    <link>https://wangze.tech/03%EF%BD%9C%E9%AB%98%E6%80%A7%E8%83%BD-IO-%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B-Redis-%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F</link>
    <guid>https://wangze.tech/03%EF%BD%9C%E9%AB%98%E6%80%A7%E8%83%BD-IO-%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B-Redis-%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F</guid>
    <description> Redis 的网络 IO 和键值对读写由一个线程完成 当客户端和 Reids 的网络连接断开时，Redis 不会等待客户端恢复连接 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，由额外的线程执行 单线程设计机制 多线程编程模式：共享资源的并发访问控制问题 在内存中完成大部分操作 + 高效的数据结构 多路复用机制（select/epoll 机制） 该机制允许内核中同时存在多个监听套接字和已连接套接字 内核监听这些套接字上的连接请求或数据请求，一旦有请求到达，就交给 Redis 处理 基于事件的回调机制 事件队列 基于多路复用的 Redis 高性能 IO 模型 .</description>
    <pubDate>Sun, 03 Sep 2023 09:52:56 GMT</pubDate>
  </item><item>
    <title>04｜AOF 日志：宕机了，Redis 如何避免数据丢失？</title>
    <link>https://wangze.tech/04%EF%BD%9CAOF-%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%EF%BC%9F</link>
    <guid>https://wangze.tech/04%EF%BD%9CAOF-%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%EF%BC%9F</guid>
    <description> Redis 作为缓存使用 从数据库读取数据恢复 当需要恢复时数据库压力大、Redis 响应慢 写后日志：先执行命令把数据写入内存，再记录日志 不会阻塞当前的写操作 记录的命令没有错误 没来得及记录时，宕机会丢失数据 在主线程写，写盘压力大可能导致后续操作无法执行 日志格式示例 执行 set testkey testvalue AOF 文件（Append Only File） *3：命令有三个部分 $3：命令、键或值一共有多少字节 每个 $n 下一行跟着命令、键或值 三种写回策略 Always：同步写回 Everysec：每秒写回 优先使用，在可靠性和性能取了一个平衡 No：操作系统控制的写回 重写机制 多个操作同一个键值的命令合并为一个命令 避免重写日志过大 直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志 一个拷贝 由后台子进程 bgrewiteaof 完成，避免阻塞主线程 fork 创建 bgrewriteaof 子进程时，阻塞主线程，如果实例内存大，执行时间还会更长 共享主线程内存，主线程执行新写或修改操作时会申请新的内存空间保存新的数据，如果操作的是 bigkey，可能因为申请大空间而面临阻塞风险 两处日志 正在使用的 AOF 日志 + 新的重写日志 避免竞争文件系统的锁 减小日志大小 AOF 非阻塞重写过程 适用于读操作比较多的场景 .</description>
    <pubDate>Sun, 03 Sep 2023 10:01:56 GMT</pubDate>
  </item><item>
    <title>04｜深入浅出索引（上）</title>
    <link>https://wangze.tech/04%EF%BD%9C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89</link>
    <guid>https://wangze.tech/04%EF%BD%9C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89</guid>
    <description> 每遇到一个新数据库，先关注它的数据模型，分析数据库的适用场景 数据库底层存储的核心基于的数据模型：哈希表、有序数组、二叉树、N 叉树等 InnoDB 的索引模型 § 每一个索引在 InnoDB 里面对应一颗 B+ 树 主键索引也被称为聚簇索引（clustered index） 叶子节点内容是整行数据 主键查询只需要搜索主键这颗 B+ 树 整张表的数据存在主键索引中，这就是“聚簇索引”的意思 非主键索引也被称为二级索引（secondary index） 叶子节点内容是主键的值 如果主键索引是多个列，二级索引里包含的主键也是多列 回表：普通索引查询，先拿到主键，再到主键索引树搜索一次 叶子节点是 page（数据页），一个页里面可以存多个行 页大小 16k，则行个数 = 16k/行大小 索引维护 页分裂 新增加一个数据页，挪动部分数据过去，空间利用率降低大概 50% 不挪动数据的新增数据页操作不叫页分裂 当相邻的两个数据页利用率很低的时候会做数据页合并 主键 建议使用自增主键 建议设置 bigint unsigned 使用业务主键的场景（典型的 KV 场景） 只有一个索引 该索引必须是唯一索引 没有主键的表，InnoDB 会默认创建一个 RowId 做主键 ⚠️ 加主键会重建表 索引只能定位到 page，page 内部是个有序数组，用二分法 数据页中有页目录，页目录的 key 为 id ，value 为槽位 二分搜索页目录定位到槽位中的行记录 内存数据页和磁盘数据页是一一对应的，持久化的时候直接覆盖写进去 叶子节点中的数据连接方式 叶子内是单向链表 叶子间是双向链表 什么时候需要重建索引 § 索引可能因为删除操作、页分裂等原因，导致数据页有空洞 即空间未释放 重建索引的过程会创建一个新的索引，把数据按顺序插入，页面的利用率最高，更省空间 思考题 § 重建普通 k 索引 alter table T drop index k; alter table T add index(k); 重建主键索引 alter table T drop primary key; alter table T add primary key(id); 对于上面这两个重建索引的做法，说出你的理解。 重建索引 k 的做法合理，可以达到省空间的目的 重建主键的过程不合理 为什么不合适？ 删除或创建主键都会将整个表重建，导致第一个语句白做 更好的方法 使用 alter table T engine=InnoDB 代替 触发 MySQL 重建该表，并进行碎片处理 5.</description>
    <pubDate>Tue, 22 Aug 2023 15:19:56 GMT</pubDate>
  </item><item>
    <title>05｜内存快照：宕机后，Redis 如何实现快速恢复？</title>
    <link>https://wangze.tech/05%EF%BD%9C%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%EF%BC%9A%E5%AE%95%E6%9C%BA%E5%90%8E%EF%BC%8CRedis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%EF%BC%9F</link>
    <guid>https://wangze.tech/05%EF%BD%9C%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%EF%BC%9A%E5%AE%95%E6%9C%BA%E5%90%8E%EF%BC%8CRedis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%EF%BC%9F</guid>
    <description> 和 AOF 相比，RDB 记录某一时刻的数据，恢复时直接把 RDB 文件读入内存 全量快照 生成 RDB 文件的方案 save：在主线程中执行，会导致阻塞 （默认）bgsave：创建一个子进程，复制主线程的页表，专门写入 RDB 文件，避免阻塞。 共享主线程的所有内存数据 快照时数据能修改吗？ 读操作：bgsave 子进程和主线程互不影响 能 写操作：生成被修改的一块数据的副本，bgsave 子进程继续写 RDB 文件，主线程在副本上进行修改 写时复制：主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射 可以每秒做一次快照吗？ 磁盘压力 fork bgsave 子进程的过程会阻塞主线程 混合使用 AOF 和内存快照 AOF 只保留从最后一次快照开始的改动 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择 如果允许分钟级别的数据丢失，可以只使用 RDB 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡 持久化有关的风险 服务器内存不足 写时复制为写、修改操作涉及的数据分配相同大小的内存副本 子进程也会占用 CPU 资源 需要开启定时 RDB 和 AOF 重写时进程一定不要绑定 CPU：子进程会与父进程争夺同一个 CPU 资源（具体搜索关键字找到后面有关绑定 CPU 的章节） .</description>
    <pubDate>Sun, 03 Sep 2023 10:10:56 GMT</pubDate>
  </item>
    </channel>
  </rss>