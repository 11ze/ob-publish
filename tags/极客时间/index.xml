<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>极客时间 on</title><link>https://wangze.tech/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/</link><description>Recent content in 极客时间 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 17 May 2023 22:27:40 +0800</lastBuildDate><atom:link href="https://wangze.tech/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>45｜自增 id 用完怎么办？</title><link>https://wangze.tech/45%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 22:27:40 +0800</pubDate><guid>https://wangze.tech/45%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。
row_id
InnoDB 表没有指定主键时，会创建一个不可见的，长度为 6 个字节的 row_id。
row_id 是一个长度 8 字节的无符号长整形</description></item><item><title>44｜答疑文章（三）：说一说这些好问题</title><link>https://wangze.tech/44%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 22:26:57 +0800</pubDate><guid>https://wangze.tech/44%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</guid><description>join 的写法
在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。
where a.f2=b.f2 就表示，查询结果里面不会包含 b.</description></item><item><title>43｜要不要使用分区表？</title><link>https://wangze.tech/43%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:24:46 +0800</pubDate><guid>https://wangze.tech/43%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</guid><description>分区表：对于引擎层，n 个表对于 server 层，1 个表
分区策略
MyISAM 分区表
InnoDB 分区表
通用分区策略：每次访问都由 server 层控制</description></item><item><title>42｜grant 之后要跟着 flush privileges 吗？</title><link>https://wangze.tech/42grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97/</link><pubDate>Wed, 17 May 2023 22:23:12 +0800</pubDate><guid>https://wangze.tech/42grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97/</guid><description>不用
在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户，因此 ua@ip1 和 ua@ip2 代表的是两个不同的用户。
全局权限
保存在 mysql.</description></item><item><title>41｜怎么最快地复制一张表？</title><link>https://wangze.tech/41%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:20:02 +0800</pubDate><guid>https://wangze.tech/41%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</guid><description>逻辑导数据
在两张表中拷贝数据，最简单地使用 insert … select 语句即可实现
将数据写到外部文本文件，然后再写回目标表
mysqldump 方法 a.</description></item><item><title>40｜insert 语句的锁为什么这么多？</title><link>https://wangze.tech/40insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Wed, 17 May 2023 22:17:02 +0800</pubDate><guid>https://wangze.tech/40insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>insert … select 语句
并发 insert 场景
实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了 (-∞,1]这个 next-key lock，会在语句执行完成后，才允许 session A 的 insert 语句执行。</description></item><item><title>39｜自增主键为什么不是连续的？</title><link>https://wangze.tech/39%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</link><pubDate>Wed, 17 May 2023 22:15:09 +0800</pubDate><guid>https://wangze.tech/39%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</guid><description>自增值保存在哪儿？
表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。
MyISAM 引擎的自增值保存在数据文件中。
InnoDB
在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。 在 MySQL 8.</description></item><item><title>38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？</title><link>https://wangze.tech/38%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E/</link><pubDate>Wed, 17 May 2023 22:13:35 +0800</pubDate><guid>https://wangze.tech/38%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E/</guid><description>内存表的数据组织结构
InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。
而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。
InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的； 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值； 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引； InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。 InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。 内存表也支持 B-Tree 索引的</description></item><item><title>37｜什么时候会使用内部临时表？</title><link>https://wangze.tech/37%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:10:20 +0800</pubDate><guid>https://wangze.tech/37%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</guid><description>union 执行流程
(select 1000 as f) union (select id from t1 order by id desc limit 2);这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。 创建临时表，执行第一个查询，拿到 1000，放入临时表，执行第二个查询，拿到 1000 和 999，1000 由于违反唯一性约束插入失败，接着放入 999 后返回，最后从临时表中按行取出数据，返回结果，并删除临时表 改成 union all 则没有去重的语义，执行时不需要临时表 group by 执行流程</description></item><item><title>36｜为什么临时表可以重名？</title><link>https://wangze.tech/36%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</link><pubDate>Wed, 17 May 2023 22:07:50 +0800</pubDate><guid>https://wangze.tech/36%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</guid><description>临时表和内存表不同
内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。 而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。临时表也可以使用 Memory 引擎。 临时表的特性</description></item><item><title>35｜join 语句怎么优化？</title><link>https://wangze.tech/35join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</link><pubDate>Wed, 17 May 2023 22:03:17 +0800</pubDate><guid>https://wangze.tech/35join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</guid><description>Multi-Range Read 优化（MRR）
目的：尽量使用顺序读盘
因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。
MRR 的设计思路 优化后的执行流程
根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ; read_rnd_buffer：MySQL 的随机读缓冲区。当按任意顺序读取行时（例如按照排序顺序）将分配一个随机读取缓冲区，进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度。 将 read_rnd_buffer 中的 id 进行递增排序； 排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。 read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</description></item><item><title>34｜到底可不可以使用 join ？</title><link>https://wangze.tech/34%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join-/</link><pubDate>Wed, 17 May 2023 21:59:52 +0800</pubDate><guid>https://wangze.tech/34%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join-/</guid><description>Index Nested-Loop Join（NLJ）
使用 join 语句，性能比强行拆成多个但表执行 SQL 语句的性能要好； 如果使用 join 语句的话，需要让小表做驱动表 前提是“可以使用被驱动表的索引” Simple Nested-Loop Join</description></item><item><title>33｜我查这么多数据，会不会把数据库内存打爆？</title><link>https://wangze.tech/33%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</link><pubDate>Wed, 17 May 2023 21:55:07 +0800</pubDate><guid>https://wangze.tech/33%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</guid><description>全表扫描对 server 层的影响
服务端并不需要保存一个完整的结果集，取数据和发数据的流程（边读边发）：
获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。2. 重复获取行，直到 net_buffer 写满，调用网络接口发出去。（发给 socket send buffer）3.</description></item><item><title>32｜为什么还有 kill 不掉的语句？</title><link>https://wangze.tech/32%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</link><pubDate>Wed, 17 May 2023 21:51:21 +0800</pubDate><guid>https://wangze.tech/32%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</guid><description>两个 kill 命令
kill query + 线程 id 终止这个线程中正在执行的语句 kill connection + 线程 id connection 可以不写 断开这个线程的连接 会先停止正在执行的语句 使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed。</description></item><item><title>31｜误删数据后除了跑路，还能怎么办？</title><link>https://wangze.tech/31%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 21:48:05 +0800</pubDate><guid>https://wangze.tech/31%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>使用 delete 语句误删数据行； 使用 drop table 或者 truncate table 语句误删数据表； 使用 drop database 语句误删数据库； 使用 rm 命令误删整个 MySQL 实例。 误删行</description></item><item><title>30｜答疑文章（二）：用动态的观点看加锁</title><link>https://wangze.tech/30%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</link><pubDate>Wed, 17 May 2023 21:46:35 +0800</pubDate><guid>https://wangze.tech/30%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</guid><description>CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), KEY c (c)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</description></item><item><title>29｜如何判断一个数据库是不是出问题了？</title><link>https://wangze.tech/29%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/</link><pubDate>Wed, 17 May 2023 21:44:09 +0800</pubDate><guid>https://wangze.tech/29%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/</guid><description>select 1 判断
select 1 这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的 MHA（Master High Availability），默认使用的就是这个方法。 只能说明这个库的进程还在，不能说明主库没问题 mysqladmin ping 机制也属于同一类 建议把 innodb_thread_concurrency 设置为 64~128 之间的值</description></item><item><title>28｜读写分离有哪些坑？</title><link>https://wangze.tech/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</link><pubDate>Wed, 17 May 2023 21:40:49 +0800</pubDate><guid>https://wangze.tech/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</guid><description>客户端直连 查询性能稍微好点，整体架构简单，排查问题更方便 主备切换、库迁移等操作时，客户端会感知到，并且需要调整数据库连接信息 一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发 带 proxy 的架构 对客户端友好，连接维护、后端信息等工作都由 proxy 完成 对后端维护团队的要求更高，需要高可用，整体架构比较复杂 过期读：在从库上会读到系统的一个过期状态</description></item><item><title>27｜主库出问题了，从库怎么办？</title><link>https://wangze.tech/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 21:37:54 +0800</pubDate><guid>https://wangze.tech/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>基于位点的主备切换
change master 命令：CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password MASTER_LOG_FILE=$master_log_name MASTER_LOG_POS=$master_log_pos  最后两个参数就是位点参数：从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步</description></item><item><title>26｜备库为什么会延迟好几个小时？</title><link>https://wangze.tech/26%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</link><pubDate>Wed, 17 May 2023 21:30:25 +0800</pubDate><guid>https://wangze.tech/26%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</guid><description>多线程复制机制 = 将单线程 sql_thread 拆成多个线程
coordinator 就是原来的 sql_thread，但不再更新数据，只负责读取中转日志和分发事务真正更新日志的变成 worker 线程，个数由参数 slave_parallel_workers 决定一般设置 8～16 之间最好（32 核物理机的情况）需要留资源给读查询</description></item><item><title>25｜MySQL 是怎么保证高可用的？</title><link>https://wangze.tech/25MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:27:01 +0800</pubDate><guid>https://wangze.tech/25MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</guid><description>正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性
主动切换的场景
主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1; 之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2; 很快 备库 B 执行完成这个事务，我们把这个时刻记为 T3 主备延迟</description></item><item><title>24｜MySQL 是怎么保证主备一致的？</title><link>https://wangze.tech/24MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:21:01 +0800</pubDate><guid>https://wangze.tech/24MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</guid><description>本章的内容是所有 MySQL 高可用方案的基础
将备库设置为只读模式（readonly）
防止误操作 防止切换逻辑有 bug，比如切换过程中出现双写造成主备不一致 可以用 readonly 状态判断节点的角色 readonly 设置对超级权限用户（super）是无效的，用于同步更新的线程拥有超级权限 一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图。（主备同步内部流程）</description></item><item><title>23｜MySQL 是怎么保证数据不丢的？</title><link>https://wangze.tech/23MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:13:18 +0800</pubDate><guid>https://wangze.tech/23MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</guid><description>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。
binlog 的写入机制
写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</description></item><item><title>22｜MySQL有哪些“饮鸩止渴”提高性能的方法？</title><link>https://wangze.tech/22MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 17 May 2023 21:07:09 +0800</pubDate><guid>https://wangze.tech/22MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>短连接风暴
max_connections 参数控制一个 MySQL 实例同时存在的连接数上限
超过这个数，系统就会拒绝接下来的连接请求，并报错提示“Too many connections” 只要连着就会计数 解决方案
一、先处理掉那些占着连接但是不工作的线程</description></item><item><title>21｜为什么我只改一行的语句，锁这么多？</title><link>https://wangze.tech/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Wed, 17 May 2023 21:03:25 +0800</pubDate><guid>https://wangze.tech/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>规则的前提说明
加锁策略可能改变，下面的只限于 5.x 系列 &amp;lt;= 5.7.24，8.0 系列 &amp;lt;= 8.0.13 间隙锁在可重复读隔离级别下才有效
读提交在外键场景下也有 两个原则、两个优化、一个 bug</description></item><item><title>20｜幻读是什么，幻读有什么问题？</title><link>https://wangze.tech/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 20:59:28 +0800</pubDate><guid>https://wangze.tech/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</guid><description>InnoDB 的默认事务隔离级别是可重复读
和下一章共用的表：CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), KEY c (c)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</description></item><item><title>19｜为什么我只查一行的语句，也执行这么慢？</title><link>https://wangze.tech/19%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</link><pubDate>Wed, 17 May 2023 20:48:04 +0800</pubDate><guid>https://wangze.tech/19%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</guid><description>有个表 t：mysql&amp;gt; CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB;</description></item><item><title>18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？</title><link>https://wangze.tech/18%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</link><pubDate>Wed, 17 May 2023 20:43:38 +0800</pubDate><guid>https://wangze.tech/18%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</guid><description>案例一：条件字段函数操作
原语句：mysql&amp;gt; select count(*) from tradelog where month(t_modified)=7;
字段值如：2017-7-1 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能
但是，优化器并不是要放弃使用这个索引，还可以选择遍历主键索引，也可以选择遍历索引 t_modified</description></item><item><title>17｜如何正确地显示随机消息？</title><link>https://wangze.tech/17%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</link><pubDate>Wed, 17 May 2023 20:35:47 +0800</pubDate><guid>https://wangze.tech/17%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</guid><description>内存临时表
explain 结果中 extra 包含 Using temporary，表示的是需要使用临时表
Using filesort 表示需要执行排序操作
比如执行 order by rand() 的时候就需要用到上面两个</description></item><item><title>16｜“order by”是怎么工作的？</title><link>https://wangze.tech/16order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 20:29:51 +0800</pubDate><guid>https://wangze.tech/16order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer
select city,name,age from t where city=&amp;lsquo;杭州&amp;rsquo; order by name limit 1000 ;
city varchar 16，name varchar 16，age int 11，city 有索引</description></item><item><title>15｜答疑文章（一）：日志和索引相关问题</title><link>https://wangze.tech/15%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 15:31:36 +0800</pubDate><guid>https://wangze.tech/15%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description>业务设计问题
业务上有这样的需求，A、B 两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是 like 表，一个是 friend 表，like 表有 user_id、liker_id 两个字段，我设置为复合唯一索引即 uk_user_id_liker_id。语句执行逻辑是这样的：以 A 关注 B 为例：第一步，先查询对方有没有关注自己（B 有没有关注 A）select * from like where user_id = B and liker_id = A;如果有，则成为好友insert into friend;没有，则只是单向关注关系insert into like;但是如果 A、B 同时关注对方，会出现不会成为好友的情况。因为上面第 1 步，双方都没关注对方。第 1 步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在 MySQL 锁层面有没有办法处理？</description></item><item><title>14｜count(*) 这么慢，我该怎么办？</title><link>https://wangze.tech/14count-%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 15:25:11 +0800</pubDate><guid>https://wangze.tech/14count-%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>count(*) 的实现方式
MyISAM 引擎把一个表的总行数存在磁盘上，执行时直接返回这个树
InnoDB 引擎每次都需要把数据一行行地从引擎里面读出来，累计行数
以上都是在说没有过滤条件的 count(*)
show table status 命令输出结果有一个 TABLE_ROWS 用于显示这个表当前行数，执行很快，但是这个结果是采样估算的（误差可能达到 40% 到 50%）</description></item><item><title>13｜为什么表数据删掉一半，表文件大小不变？</title><link>https://wangze.tech/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</link><pubDate>Wed, 17 May 2023 15:24:09 +0800</pubDate><guid>https://wangze.tech/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</guid><description>参数 innodb_file_per_table
OFF：表的数据放在系统共享表空间，也就是跟数据字典放在一起
ON：每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中
从 5.6.6 版本开始是默认值
建议无论使用哪个版本都将这个值设置为 ON</description></item><item><title>12｜为什么我的 MySQL 会“抖”一下？</title><link>https://wangze.tech/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-MySQL-%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</link><pubDate>Wed, 17 May 2023 15:19:54 +0800</pubDate><guid>https://wangze.tech/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-MySQL-%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</guid><description>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。
内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
即何时内存中的脏页往硬盘上刷？
redo log 满 把绿色部分的日志对应的所有脏页都 flush 到磁盘上</description></item><item><title>11｜怎么给字符串字段加索引？</title><link>https://wangze.tech/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</link><pubDate>Wed, 17 May 2023 15:19:11 +0800</pubDate><guid>https://wangze.tech/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</guid><description>直接创建完整索引，这样可能比较占用空间； 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引； 即使前缀完全覆盖了字段内容也会回表，因为不确定是不是真的完整数据
在索引上找到数据后还需要回到主键上拿到完整数据进行判断
倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题，不支持范围扫描； index index_name(email(6)); 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，需要多一个字段保存 hash 字段，不支持范围扫描。 比如通过 crc32() 函数得到 hash 值 思考题</description></item><item><title>10｜MySQL 为什么有时候会选错索引？</title><link>https://wangze.tech/10MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</link><pubDate>Wed, 17 May 2023 15:18:30 +0800</pubDate><guid>https://wangze.tech/10MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</guid><description>优化器的逻辑
扫描行数
一个索引上不同的值越多（指基数），这个索引的区分度就越好。
基数（cardinality）：一个索引上不同的值的个数。
采样统计：InnoDB 默认选择索引的 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面树，就得到这个索引的基数。
当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</description></item><item><title>09｜普通索引和唯一索引，应该怎么选择？</title><link>https://wangze.tech/09%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</link><pubDate>Wed, 17 May 2023 15:15:56 +0800</pubDate><guid>https://wangze.tech/09%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</guid><description>查询性能
「where = 」时，唯一索引找到了立马返回，普通索引需要找到下一个不等于的值
因为 InnoDB 的数据是按数据页为单位读写的，所以性能差距微乎其微
对于整形字段，一个 16KB 的数据页可以放近千个 key change buffer</description></item><item><title>08｜事务到底是隔离的还是不隔离的？</title><link>https://wangze.tech/08%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</link><pubDate>Wed, 17 May 2023 14:45:12 +0800</pubDate><guid>https://wangze.tech/08%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</guid><description>事务的启动时机 begin/start transaction 命令之后的第一个操作 InnoDB 表的语句，事务才真正启动。 马上启动一个事务：start transaction with consistent snapshot。 整个专栏，如果没有特别说明，都默认 autocommit = 1。 事务自动提交设置，默认为1，即除非显示声明一个事务的开始，否则每一个查询都会被当做独立的事务被处理。 MySQL 里的两个“视图”的概念 一个是 view。是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是 create view …，查询方法和表一样。 另一个是 InnoDB 在实现 MVCC（多版本并发控制） 时用到的一致性读视图（consistent read view），用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。 视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据” “快照”在 MVCC 里是怎么工作的？ 秒级创建快照的能力，快照是基于整库的。 InnoDB 的行数据有多个版本（row），每个版本有自己的 row trx_id（严格递增）。 图中的虚线就是 undo log。 在实现上，InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。 活跃：启动了但还没提交。 数组里事务 ID 的最小值记为低水位。 当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。 数据版本的可见性规则：基于数据的 row trx_id 和一致性视图的对比结果得到的。 绿色：表示这个版本是已提交的事务或者是当前事务自己生成的，可见。 红色：表示是由将来启动的事务生成的，不可见。 黄色 a）若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b）若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。 翻译：对于一个事务视图，除了自己的更新总是可见以外，有三种情况 版本未提交，不可见； 版本已提交，但是是在视图创建后提交的，不可见； 版本已提交，而且是在视图创建前提交的，可见。 每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 对于读提交，查询只承认在语句启动前就已经提交完成的数据； 更新逻辑 更新数据都是先读后写的。 当前读：总是读取已经提交完成的最新版本。 除了 update 语句外，select 语句如果加锁，也是当前读。 加上 lock in share mode 或 for update。 事务的可重复读是怎么实现的？ 可重复读的核心是一致性读；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。 读提交的逻辑和可重复读的逻辑类似，最主要的区别： 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图； 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的事务。 为什么表结构不支持“可重复读”？ 因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。 MySQL 8.</description></item><item><title>07｜行锁功过：怎么减少锁对性能的影响？</title><link>https://wangze.tech/07%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</link><pubDate>Wed, 17 May 2023 14:43:52 +0800</pubDate><guid>https://wangze.tech/07%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</guid><description> MyISAM 不支持行锁 InnoDB 的行锁 两阶段锁协议：事务中，行锁在需要的时候才加上，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。 两种策略 直接进入等待，直到超时。 超时时间可以通过 innodb_lock_wait_timeout 设置 默认 50s。 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。 死锁：每当一个事务被锁，就要看看它所依赖的线程有没有被别的锁住，如此循环，最后判断是否出现连循环等待。 假设现在已经有999个线程在同一行等锁，新来一个请求也要访问这个行，他要判断有没有死锁要判断 1000 次。然后这个结果乘以 1000。 正常情况下采用第二种策略，默认也是第二种。 怎么解决热点行更新导致的性能问题？ 问题的症结：死锁检测要耗费大量的 CPU 资源。 确保业务一定不会出现死锁，关闭死锁检测（不推荐） 控制并发度。 a）在中间件或修改 MySQL 源码实现：对于相同行的更新，在进入引擎之前排队，这样 InnoDB 就不会有大量的死锁检测工作。 b）如果做不到第 a 点，可以考虑从设计上优化 以考虑通过将一行改成逻辑上的多行来减少锁冲突。 以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。 思考题 如果要删除一个表里面的前 1w 行数据，选择哪一种方法 直接执行 delete from T limit 10000; 单个语句占用时间长，锁的时间也比较长； 大事务还会导致主从延迟。 在一个连接中循环执行 20 次 delete from T limit 500; 选 2。 在 20 个连接中同时执行 delete from T limit 500; 认为造成锁冲突。 评论区 关于本篇思考题 第二种方法难道不会引起数据一致性问题吗？如果在 InnoDB 中开启了自动事务并且没有显式用 begin, commit 来做的话，在上一次循环结束和下一次循环开始之间如果有其他事务插入了新数据，而且正好位置也在前面 500条，那不就不一致了么 加个 order by id（假设 id 是表的主键） 排序后新增的 id 肯定大于要删除的最大 id 如果有多种锁，必须全部不互斥才能并行。 没有嵌套事务，开启下一个会自动提交上一个</description></item><item><title>06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？</title><link>https://wangze.tech/06%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</link><pubDate>Wed, 17 May 2023 14:40:34 +0800</pubDate><guid>https://wangze.tech/06%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</guid><description>全局锁 典型使用场景：做全库逻辑备份。 使用 MySQL 提供的加全局读锁的方法 Flush tables with read lock（FTWRL） 整个库进入只读状态 执行 FTWRL 命令之后由于客户端发生异常断开，MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。 推荐：可以在可重复读隔离级别下开启一个事务 备份期间可以正常读写数据库 需要所有的表的引擎都支持（全库备份） mysqldump 备份工具使用 -single-transaction 参数，就会开启一个事务，确保拿到一致性视图 为什么不使用 set global readonly=true？ 建议用 FTWRL 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。 将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。 readonly 对 super 权限的用户无效 表级锁 表锁 语法：lock tables … read/write unlock tables 主动释放锁，或者客户端断开的时候自动释放 除了会限制比的线程的读写，也会限定本线程自己接下来的操作对象 不推荐使用，若引擎不支持事务，安排升级换引擎。 升级后把使用 lock/unlock tables 语法的地方换成 begin 和 commit。 元数据锁 MDL（metadata lock） 不需要显示使用，在访问一个表的时候会被自动加上 MySQL 5.</description></item><item><title>05｜深入浅出索引（下）</title><link>https://wangze.tech/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8B/</link><pubDate>Wed, 17 May 2023 10:13:29 +0800</pubDate><guid>https://wangze.tech/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8B/</guid><description>如何安排联合索引内的字段顺序 第一原则：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。 如果既有联合查询，又有基于 a、b 各自的查询，此时要考虑空间 比如 a 比 b 大，就建 (a, b) + 单 b 还有其他情况，需要结合业务分析 查询语句的 where 里面各个判断调换顺序不影响 覆盖索引 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果 覆盖索引可以减少树的搜索次数，显著提升查询性能，是常见的性能优化手段 要全用上必须是条件 =，不能是 &amp;gt; 或 &amp;lt; (c, b)，这个索引是当 c 相同时,才按照 b 字段升序或者降序排序建立索引 b那如果 &amp;gt; 的话 相当于可能获取到多个 c 不同的情况 在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 如果有一个高频请求是根据身份证号查询姓名，就有必要 前缀索引 最左前缀原则 可以是联合索引的最左 N 个字段 也可以是字符串索引的最左 M 个字符 索引下推 MySQL 5.</description></item><item><title>04｜深入浅出索引（上）</title><link>https://wangze.tech/04%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8A/</link><pubDate>Wed, 17 May 2023 10:09:25 +0800</pubDate><guid>https://wangze.tech/04%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8A/</guid><description>每遇到一个新数据库，先关注它的数据模型，分析数据库的适用场景 数据库底层存储的核心基于的数据模型：哈希表、有序数组、二叉树、N 叉树等 哈希表 以键 - 值（key-value）存储数据的结构 思路：把值放到数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置 不可避免出现哈希冲突，其中一种解决方法是用链表存储相同 key 的值，查找时从链表头开始按顺序遍历链表 适用于只有等值查询的场景 插入数据很快 无序，用哈希索引做区间查询很慢 比如 Memcached 及其他一些 NoSQL 引擎 有序数组 在等值查询和范围查询场景中的性能非常优秀 用二分法可以快速找到对应的数据，O(Log(N)) 只适用于静态存储引擎 插入数据慢，需要挪动插入的记录后面所有的记录 二叉搜索树 特点 父节点左子树所有节点的值小于父节点的值 父节点右子树所有节点的值大于父节点的值 需要保持这棵树是平衡二叉树 查询复杂度O(log(N)) 更新复杂度O(log(N)) N 叉树 B+ 树就是一种 N 叉树 相比于二叉树，能够有效减少单次查询的磁盘访问次数 N 取决于数据块的大小 MySQL 5.</description></item><item><title>MySQL 实战 45 讲</title><link>https://wangze.tech/MySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/</link><pubDate>Wed, 17 May 2023 09:23:16 +0800</pubDate><guid>https://wangze.tech/MySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/</guid><description>章节分类 开篇词｜这一次，让我们一起来搞懂 MySQL - 极客时间
索引：[[04｜深入浅出索引（上）|04]]、[[05｜深入浅出索引（下）|05]]、[[09｜普通索引和唯一索引，应该怎么选择？|09]]、[[10｜MySQL 为什么有时候会选错索引？|10]]、[[11｜怎么给字符串字段加索引？|11]]、[[15｜答疑文章（一）：日志和索引相关问题|15]]、[[16｜“order by”是怎么工作的？|16]]、[[18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？|18]] 事务：[[03｜事务隔离：为什么你改了为还看不见？|03]]、[[08｜事务到底是隔离的还是不隔离的？|08]]、[[20｜幻读是什么，幻读有什么问题？|20]] 锁：[[06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？|06]]、[[07｜行锁功过：怎么减少锁对性能的影响？|07]]、[[13｜为什么表数据删掉一半，表文件大小不变？|13]]、[[19｜为什么我只查一行的语句，也执行这么慢？|19]]、[[20｜幻读是什么，幻读有什么问题？|20]]、[[21｜为什么我只改一行的语句，锁这么多？|21]]、30、40 日志与主备：[[02｜日志系统：一条 SQL 更新语句是如何执行的？|02]]、[[12｜为什么我的 MySQL 会“抖”一下？|12]]、23、24、25、26、27、28、29、31 临时表：[[17｜如何正确地显示随机消息？|17]]、34、35、36、37、43 实用性：[[01｜基础架构：一条 SQL 查询语句是如何执行的？|01]]、[[14｜count(*) 这么慢，我该怎么办？|14]]、32、33、41、44 基础篇 [[01｜基础架构：一条 SQL 查询语句是如何执行的？]] [[02｜日志系统：一条 SQL 更新语句是如何执行的？]] [[03｜事务隔离：为什么你改了为还看不见？]] [[04｜深入浅出索引（上）]] [[05｜深入浅出索引（下）]] [[06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？]] [[07｜行锁功过：怎么减少锁对性能的影响？]] [[08｜事务到底是隔离的还是不隔离的？]] 实践篇 [[09｜普通索引和唯一索引，应该怎么选择？]] [[10｜MySQL 为什么有时候会选错索引？]] [[11｜怎么给字符串字段加索引？]] [[12｜为什么我的 MySQL 会“抖”一下？]] [[13｜为什么表数据删掉一半，表文件大小不变？]] [[14｜count(*) 这么慢，我该怎么办？]] [[15｜答疑文章（一）：日志和索引相关问题]] [[16｜“order by”是怎么工作的？]] [[17｜如何正确地显示随机消息？]] [[18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？]] [[19｜为什么我只查一行的语句，也执行这么慢？]] [[20｜幻读是什么，幻读有什么问题？]] [[21｜为什么我只改一行的语句，锁这么多？]] [[22｜MySQL有哪些“饮鸩止渴”提高性能的方法？]] [[23｜MySQL 是怎么保证数据不丢的？]] [[24｜MySQL 是怎么保证主备一致的？]] [[25｜MySQL 是怎么保证高可用的？]] [[26｜备库为什么会延迟好几个小时？]] [[27｜主库出问题了，从库怎么办？]] [[28｜读写分离有哪些坑？]] [[29｜如何判断一个数据库是不是出问题了？]] [[30｜答疑文章（二）：用动态的观点看加锁]] [[31｜误删数据后除了跑路，还能怎么办？]] [[32｜为什么还有 kill 不掉的语句？]] [[33｜我查这么多数据，会不会把数据库内存打爆？]] [[34｜到底可不可以使用 join ？]] [[35｜join 语句怎么优化？]] [[36｜为什么临时表可以重名？]] [[37｜什么时候会使用内部临时表？]] [[38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？]] [[39｜自增主键为什么不是连续的？]] [[40｜insert 语句的锁为什么这么多？]] [[41｜怎么最快地复制一张表？]] [[42｜grant 之后要跟着 flush privileges 吗？]] [[43｜要不要使用分区表？]] [[44｜答疑文章（三）：说一说这些好问题]] [[45｜自增 id 用完怎么办？]]</description></item><item><title>极客时间专栏笔记</title><link>https://wangze.tech/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E4%B8%93%E6%A0%8F%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 12 May 2023 00:00:00 +0800</pubDate><guid>https://wangze.tech/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E4%B8%93%E6%A0%8F%E7%AC%94%E8%AE%B0/</guid><description> Redis 核心技术与实战</description></item></channel></rss>