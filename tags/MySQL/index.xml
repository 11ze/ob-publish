<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MySQL on</title><link>https://wangze.tech/tags/MySQL/</link><description>Recent content in MySQL on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 17 May 2023 22:27:40 +0800</lastBuildDate><atom:link href="https://wangze.tech/tags/MySQL/index.xml" rel="self" type="application/rss+xml"/><item><title>45｜自增 id 用完怎么办？</title><link>https://wangze.tech/45%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 22:27:40 +0800</pubDate><guid>https://wangze.tech/45%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。
row_id
InnoDB 表没有指定主键时，会创建一个不可见的，长度为 6 个字节的 row_id。
row_id 是一个长度 8 字节的无符号长整形</description></item><item><title>44｜答疑文章（三）：说一说这些好问题</title><link>https://wangze.tech/44%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 22:26:57 +0800</pubDate><guid>https://wangze.tech/44%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</guid><description>join 的写法
在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。
where a.f2=b.f2 就表示，查询结果里面不会包含 b.</description></item><item><title>43｜要不要使用分区表？</title><link>https://wangze.tech/43%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:24:46 +0800</pubDate><guid>https://wangze.tech/43%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</guid><description>分区表：对于引擎层，n 个表对于 server 层，1 个表
分区策略
MyISAM 分区表
InnoDB 分区表
通用分区策略：每次访问都由 server 层控制</description></item><item><title>42｜grant 之后要跟着 flush privileges 吗？</title><link>https://wangze.tech/42grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97/</link><pubDate>Wed, 17 May 2023 22:23:12 +0800</pubDate><guid>https://wangze.tech/42grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97/</guid><description>不用
在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户，因此 ua@ip1 和 ua@ip2 代表的是两个不同的用户。
全局权限
保存在 mysql.</description></item><item><title>41｜怎么最快地复制一张表？</title><link>https://wangze.tech/41%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:20:02 +0800</pubDate><guid>https://wangze.tech/41%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</guid><description>逻辑导数据
在两张表中拷贝数据，最简单地使用 insert … select 语句即可实现
将数据写到外部文本文件，然后再写回目标表
mysqldump 方法 a.</description></item><item><title>40｜insert 语句的锁为什么这么多？</title><link>https://wangze.tech/40insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Wed, 17 May 2023 22:17:02 +0800</pubDate><guid>https://wangze.tech/40insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>insert … select 语句
并发 insert 场景
实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了 (-∞,1]这个 next-key lock，会在语句执行完成后，才允许 session A 的 insert 语句执行。</description></item><item><title>39｜自增主键为什么不是连续的？</title><link>https://wangze.tech/39%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</link><pubDate>Wed, 17 May 2023 22:15:09 +0800</pubDate><guid>https://wangze.tech/39%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</guid><description>自增值保存在哪儿？
表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。
MyISAM 引擎的自增值保存在数据文件中。
InnoDB
在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。 在 MySQL 8.</description></item><item><title>38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？</title><link>https://wangze.tech/38%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E/</link><pubDate>Wed, 17 May 2023 22:13:35 +0800</pubDate><guid>https://wangze.tech/38%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E/</guid><description>内存表的数据组织结构
InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。
而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。
InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的； 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值； 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引； InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。 InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。 内存表也支持 B-Tree 索引的</description></item><item><title>37｜什么时候会使用内部临时表？</title><link>https://wangze.tech/37%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</link><pubDate>Wed, 17 May 2023 22:10:20 +0800</pubDate><guid>https://wangze.tech/37%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</guid><description>union 执行流程
(select 1000 as f) union (select id from t1 order by id desc limit 2);这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。 创建临时表，执行第一个查询，拿到 1000，放入临时表，执行第二个查询，拿到 1000 和 999，1000 由于违反唯一性约束插入失败，接着放入 999 后返回，最后从临时表中按行取出数据，返回结果，并删除临时表 改成 union all 则没有去重的语义，执行时不需要临时表 group by 执行流程</description></item><item><title>36｜为什么临时表可以重名？</title><link>https://wangze.tech/36%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</link><pubDate>Wed, 17 May 2023 22:07:50 +0800</pubDate><guid>https://wangze.tech/36%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</guid><description>临时表和内存表不同
内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。 而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。临时表也可以使用 Memory 引擎。 临时表的特性</description></item><item><title>35｜join 语句怎么优化？</title><link>https://wangze.tech/35join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</link><pubDate>Wed, 17 May 2023 22:03:17 +0800</pubDate><guid>https://wangze.tech/35join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</guid><description>Multi-Range Read 优化（MRR）
目的：尽量使用顺序读盘
因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。
MRR 的设计思路 优化后的执行流程
根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ; read_rnd_buffer：MySQL 的随机读缓冲区。当按任意顺序读取行时（例如按照排序顺序）将分配一个随机读取缓冲区，进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度。 将 read_rnd_buffer 中的 id 进行递增排序； 排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。 read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</description></item><item><title>34｜到底可不可以使用 join ？</title><link>https://wangze.tech/34%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join-/</link><pubDate>Wed, 17 May 2023 21:59:52 +0800</pubDate><guid>https://wangze.tech/34%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join-/</guid><description>Index Nested-Loop Join（NLJ）
使用 join 语句，性能比强行拆成多个但表执行 SQL 语句的性能要好； 如果使用 join 语句的话，需要让小表做驱动表 前提是“可以使用被驱动表的索引” Simple Nested-Loop Join</description></item><item><title>33｜我查这么多数据，会不会把数据库内存打爆？</title><link>https://wangze.tech/33%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</link><pubDate>Wed, 17 May 2023 21:55:07 +0800</pubDate><guid>https://wangze.tech/33%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</guid><description>全表扫描对 server 层的影响
服务端并不需要保存一个完整的结果集，取数据和发数据的流程（边读边发）：
获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。2. 重复获取行，直到 net_buffer 写满，调用网络接口发出去。（发给 socket send buffer）3.</description></item><item><title>32｜为什么还有 kill 不掉的语句？</title><link>https://wangze.tech/32%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</link><pubDate>Wed, 17 May 2023 21:51:21 +0800</pubDate><guid>https://wangze.tech/32%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</guid><description>两个 kill 命令
kill query + 线程 id 终止这个线程中正在执行的语句 kill connection + 线程 id connection 可以不写 断开这个线程的连接 会先停止正在执行的语句 使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed。</description></item><item><title>31｜误删数据后除了跑路，还能怎么办？</title><link>https://wangze.tech/31%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 21:48:05 +0800</pubDate><guid>https://wangze.tech/31%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>使用 delete 语句误删数据行； 使用 drop table 或者 truncate table 语句误删数据表； 使用 drop database 语句误删数据库； 使用 rm 命令误删整个 MySQL 实例。 误删行</description></item><item><title>30｜答疑文章（二）：用动态的观点看加锁</title><link>https://wangze.tech/30%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</link><pubDate>Wed, 17 May 2023 21:46:35 +0800</pubDate><guid>https://wangze.tech/30%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</guid><description>CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), KEY c (c)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</description></item><item><title>29｜如何判断一个数据库是不是出问题了？</title><link>https://wangze.tech/29%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/</link><pubDate>Wed, 17 May 2023 21:44:09 +0800</pubDate><guid>https://wangze.tech/29%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/</guid><description>select 1 判断
select 1 这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的 MHA（Master High Availability），默认使用的就是这个方法。 只能说明这个库的进程还在，不能说明主库没问题 mysqladmin ping 机制也属于同一类 建议把 innodb_thread_concurrency 设置为 64~128 之间的值</description></item><item><title>28｜读写分离有哪些坑？</title><link>https://wangze.tech/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</link><pubDate>Wed, 17 May 2023 21:40:49 +0800</pubDate><guid>https://wangze.tech/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</guid><description>客户端直连 查询性能稍微好点，整体架构简单，排查问题更方便 主备切换、库迁移等操作时，客户端会感知到，并且需要调整数据库连接信息 一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发 带 proxy 的架构 对客户端友好，连接维护、后端信息等工作都由 proxy 完成 对后端维护团队的要求更高，需要高可用，整体架构比较复杂 过期读：在从库上会读到系统的一个过期状态</description></item><item><title>27｜主库出问题了，从库怎么办？</title><link>https://wangze.tech/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 21:37:54 +0800</pubDate><guid>https://wangze.tech/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>基于位点的主备切换
change master 命令：CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password MASTER_LOG_FILE=$master_log_name MASTER_LOG_POS=$master_log_pos  最后两个参数就是位点参数：从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步</description></item><item><title>26｜备库为什么会延迟好几个小时？</title><link>https://wangze.tech/26%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</link><pubDate>Wed, 17 May 2023 21:30:25 +0800</pubDate><guid>https://wangze.tech/26%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</guid><description>多线程复制机制 = 将单线程 sql_thread 拆成多个线程
coordinator 就是原来的 sql_thread，但不再更新数据，只负责读取中转日志和分发事务真正更新日志的变成 worker 线程，个数由参数 slave_parallel_workers 决定一般设置 8～16 之间最好（32 核物理机的情况）需要留资源给读查询</description></item><item><title>25｜MySQL 是怎么保证高可用的？</title><link>https://wangze.tech/25MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:27:01 +0800</pubDate><guid>https://wangze.tech/25MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</guid><description>正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性
主动切换的场景
主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1; 之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2; 很快 备库 B 执行完成这个事务，我们把这个时刻记为 T3 主备延迟</description></item><item><title>24｜MySQL 是怎么保证主备一致的？</title><link>https://wangze.tech/24MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:21:01 +0800</pubDate><guid>https://wangze.tech/24MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</guid><description>本章的内容是所有 MySQL 高可用方案的基础
将备库设置为只读模式（readonly）
防止误操作 防止切换逻辑有 bug，比如切换过程中出现双写造成主备不一致 可以用 readonly 状态判断节点的角色 readonly 设置对超级权限用户（super）是无效的，用于同步更新的线程拥有超级权限 一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图。（主备同步内部流程）</description></item><item><title>23｜MySQL 是怎么保证数据不丢的？</title><link>https://wangze.tech/23MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</link><pubDate>Wed, 17 May 2023 21:13:18 +0800</pubDate><guid>https://wangze.tech/23MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</guid><description>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。
binlog 的写入机制
写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</description></item><item><title>22｜MySQL有哪些“饮鸩止渴”提高性能的方法？</title><link>https://wangze.tech/22MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 17 May 2023 21:07:09 +0800</pubDate><guid>https://wangze.tech/22MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>短连接风暴
max_connections 参数控制一个 MySQL 实例同时存在的连接数上限
超过这个数，系统就会拒绝接下来的连接请求，并报错提示“Too many connections” 只要连着就会计数 解决方案
一、先处理掉那些占着连接但是不工作的线程</description></item><item><title>21｜为什么我只改一行的语句，锁这么多？</title><link>https://wangze.tech/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Wed, 17 May 2023 21:03:25 +0800</pubDate><guid>https://wangze.tech/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>规则的前提说明
加锁策略可能改变，下面的只限于 5.x 系列 &amp;lt;= 5.7.24，8.0 系列 &amp;lt;= 8.0.13 间隙锁在可重复读隔离级别下才有效
读提交在外键场景下也有 两个原则、两个优化、一个 bug</description></item><item><title>20｜幻读是什么，幻读有什么问题？</title><link>https://wangze.tech/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 20:59:28 +0800</pubDate><guid>https://wangze.tech/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</guid><description>InnoDB 的默认事务隔离级别是可重复读
和下一章共用的表：CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), KEY c (c)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</description></item><item><title>19｜为什么我只查一行的语句，也执行这么慢？</title><link>https://wangze.tech/19%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</link><pubDate>Wed, 17 May 2023 20:48:04 +0800</pubDate><guid>https://wangze.tech/19%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</guid><description>有个表 t：mysql&amp;gt; CREATE TABLE t ( id int(11) NOT NULL, c int(11) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB;</description></item><item><title>18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？</title><link>https://wangze.tech/18%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</link><pubDate>Wed, 17 May 2023 20:43:38 +0800</pubDate><guid>https://wangze.tech/18%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B-SQL-%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/</guid><description>案例一：条件字段函数操作 原语句：mysql&amp;gt; select count(*) from tradelog where month(t_modified)=7; 字段值如：2017-7-1 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能 但是，优化器并不是要放弃使用这个索引，还可以选择遍历主键索引，也可以选择遍历索引 t_modified 优化方案：mysql&amp;gt; select count(*) from tradelog where -&amp;gt; (t_modified &amp;gt;= '2016-7-1' and t_modified&amp;lt;'2016-8-1') or -&amp;gt; (t_modified &amp;gt;= '2017-7-1' and t_modified&amp;lt;'2017-8-1') or -&amp;gt; (t_modified &amp;gt;= '2018-7-1' and t_modified&amp;lt;'2018-8-1'); 案例二：隐式类型转换 mysql&amp;gt; select * from tradelog where tradeid=110717; 相当于：mysql&amp;gt; select * from tradelog where CAST(tradid AS signed int) = 110717; 因为 tradeid 的字段类型是 varchar(32)，输入的参数是整形，所以该语句需要走全表扫描 如果字段是整形，输入是字符串，则可以走索引 数据类型转换的规则 为什么有数据类型转换就需要走全索引扫描 这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。 案例三：隐式字符编码转换 两个表的字符集不同，一个是 utf8，一个是 utf8mb4，所以做表连接查询的时候用不上关联字段的索引 utf8mb4 是 utf8 的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。 例子：select * from trade_detail where CONVERT(traideid USING utf8mb4)=$L2.</description></item><item><title>17｜如何正确地显示随机消息？</title><link>https://wangze.tech/17%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</link><pubDate>Wed, 17 May 2023 20:35:47 +0800</pubDate><guid>https://wangze.tech/17%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</guid><description>内存临时表
explain 结果中 extra 包含 Using temporary，表示的是需要使用临时表
Using filesort 表示需要执行排序操作
比如执行 order by rand() 的时候就需要用到上面两个</description></item><item><title>16｜“order by”是怎么工作的？</title><link>https://wangze.tech/16order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 20:29:51 +0800</pubDate><guid>https://wangze.tech/16order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer
select city,name,age from t where city=&amp;lsquo;杭州&amp;rsquo; order by name limit 1000 ;
city varchar 16，name varchar 16，age int 11，city 有索引</description></item><item><title>15｜答疑文章（一）：日志和索引相关问题</title><link>https://wangze.tech/15%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 17 May 2023 15:31:36 +0800</pubDate><guid>https://wangze.tech/15%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description>业务设计问题 业务上有这样的需求，A、B 两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是 like 表，一个是 friend 表，like 表有 user_id、liker_id 两个字段，我设置为复合唯一索引 uk_user_id_liker_id。语句执行逻辑是这样的：以 A 关注 B 为例：第一步，先查询对方有没有关注自己（B 有没有关注 A）select * from like where user_id = B and liker_id = A; 如果有，则成为好友insert into friend; 没有，则只是单向关注关系 insert into like; 但是如果 A、B 同时关注对方，会出现不会成为好友的情况。因为上面第 1 步，双方都没关注对方。第 1 步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在 MySQL 锁层面有没有办法处理？ CREATE TABLE like(idint(11) NOT NULL AUTO_INCREMENT,user_idint(11) NOT NULL,liker_id int(11) NOT NULL, PRIMARY KEY (id), UNIQUE KEY uk_user_id_liker_id (user_id,liker_id)) ENGINE=InnoDB;CREATE TABLE friend(idint(11) NOT NULL AUTO_INCREMENT,friend_1_idint(11) NOT NULL,friend_2_idint(11) NOT NULL, UNIQUE KEYuk_friend (friend_1_id,friend_2_id), PRIMARY KEY (id)) ENGINE=InnoDB; 首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值 1、2、3。值是 1 的时候，表示 user_id 关注 liker_id；值是 2 的时候，表示 liker_id 关注 user_id；值是 3 的时候，表示互相关注。 然后，当 A 关注 B 的时候，逻辑改成如下所示的样子：应用代码里面，比较 A 和 B 的大小，如果 A &amp;lt; B，就执行下面的逻辑 mysql&amp;gt; begin; /*启动事务*/insert into like(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;select relation_ship from like where user_id=A and liker_id=B;/*代码中判断返回的 relation_ship， 如果是1，事务结束，执行 commit 如果是3，则执行下面这两个语句： */insert ignore into friend(friend_1_id, friend_2_id) values(A,B);commit; 如果 A &amp;gt; B，则执行下面的逻辑 mysql&amp;gt; begin; /*启动事务*/insert into like(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;select relation_ship from like where user_id=B and liker_id=A;/*代码中判断返回的 relation_ship， 如果是2，事务结束，执行 commit 如果是3，则执行下面这两个语句：*/insert ignore into friend(friend_1_id, friend_2_id) values(B,A);commit; 这个设计里，让“like”表里的数据保证 user_id &amp;lt; liker_id，这样不论是 A 关注 B，还是 B 关注 A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。然后，insert … on duplicate 语句，确保了在事务内部，执行了这个 SQL 语句后，就强行占住了这个行锁，之后的 select 判断 relation_ship 这个逻辑时就确保了是在行锁保护下的读操作。操作符 “|” 是按位或，连同最后一句 insert 语句里的 ignore，是为了保证重复调用时的幂等性。这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是 like 表里面有一条关于 A 和 B 的记录，而且 relation_ship 的值是 3， 并且 friend 表里面也有了 A 和 B 的这条记录。 思考题 创建一个简单的表 t，并插入一行，然后对这一行做修改。mysql&amp;gt; CREATE TABLE t (id int(11) NOT NULL primary key auto_increment,a int(11) DEFAULT NULL) ENGINE=InnoDB;insert into t values(1,2);</description></item><item><title>14｜count(*) 这么慢，我该怎么办？</title><link>https://wangze.tech/14count-%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Wed, 17 May 2023 15:25:11 +0800</pubDate><guid>https://wangze.tech/14count-%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>count(*) 的实现方式 MyISAM 引擎把一个表的总行数存在磁盘上，执行时直接返回这个数 InnoDB 引擎每次都需要把数据一行行地从引擎里面读出来，累计行数 以上都是在说没有过滤条件的 `count(*) count 是一行行读数据，是一致性读（快照读），不加锁 其他计数方式 在数据库保存计数 新建一个表专门用于计数 全部用 InnoDB 引擎 在修改计数时使用事务 show table status 命令：输出结果有一个 TABLE_ROWS 用于显示这个表当前行数，执行很快，但这个结果是采样估算的（误差可能达到 40% 到 50%） 用缓存系统保存计数 比如用 Redis 将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。 两个系统间存在数据不一致的时刻 不同的 Count 用法（InnoDB） count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。 count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段） 则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。 分析性能差别的时候的原则 server 层要什么就给什么； InnoDB 只给必要的值； 现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。 count(主键 id)：遍历整张表，把每一行的 id 值都取出来，返回给 server 层，server 层拿到后判断是不可能为空的，就按行累加。 count(1)：遍历整张表，但不取值，server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。 count(字段) 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加； 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。 count(*)：例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。 MySQL 版本 &amp;gt;= 5.</description></item><item><title>13｜为什么表数据删掉一半，表文件大小不变？</title><link>https://wangze.tech/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</link><pubDate>Wed, 17 May 2023 15:24:09 +0800</pubDate><guid>https://wangze.tech/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</guid><description>参数 innodb_file_per_table OFF：表的数据放在系统共享表空间，跟数据字典放在一起 ON：每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中 从 5.6.6 版本开始是默认值 建议无论使用哪个版本都将这个值设置为 ON 因为一个表单独存储为一个文件更容易管理 在不需要这个表的时候，通过 drop table 命令可以直接删除这个文件，而如果放在共享表空间，即使表删掉了，空间也不会回收。 下面的内容基于 ON 展开 数据删除流程 删除一行记录，InnoDB 引擎只会把这个记录标记为删除 当再插入一个在被删记录位置的记录时，可能复用该位置 如果删掉一整个数据页上的所有记录，则整个数据页可以被复用 数据页的复用跟记录的复用不同 记录的复用只限于符合范围条件的数据 数据页的复用可以复用到任何位置 如果相邻的两个数据页利用率都很小，系统会把两个页的数据合到其中一个页，另一个被标记为可复用 如果用 delete 命令删除整个表的数据，则所有的数据页都会被标记为可复用，但是磁盘上文件不会变小 重建表 alter table A engine=InnoDB 起到收缩表 A 的作用 5.</description></item><item><title>12｜为什么我的 MySQL 会“抖”一下？</title><link>https://wangze.tech/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-MySQL-%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</link><pubDate>Wed, 17 May 2023 15:19:54 +0800</pubDate><guid>https://wangze.tech/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-MySQL-%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</guid><description>概念 脏页：跟磁盘数据页内容不一致的内存数据页 干净页：跟磁盘数据页内容一致的内存数据页 何时内存中的脏页往硬盘上刷？ redo log 满 把绿色部分的日志对应的所有脏页都 flush 到磁盘上 之后，write pos 到 cp&amp;rsquo; 之间是可以再写入的 redo log 的区域 当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘 不直接把内存淘汰掉，下次需求请求的时候从磁盘读入数据页，然后拿 redo log 出来应用的原因：为了保证每个数据页有两种状态 内存里存在，内存里肯定是正确的结果，直接返回； 内存里没有数据，可以肯定数据文件上是正确的结果，读入内存后返回。 MySQL 认为系统“空闲”的时候会刷，忙的时候也会找机会刷 正常关闭数据库时，会把内存的脏页都 flush 到磁盘上，下次启动时直接从磁盘读数据，启动速度快 第 2 种情况是常态 InnoDB 用缓冲池管理内存，缓冲池中的内存页有三种状态 还没有使用：很少 使用了并且是干净页 使用了并且是脏页。 当要读入的数据页没有在内存的时候，必须到缓冲池申请一个数据页 把最久不使用的数据页从内存中淘汰掉 影响性能的情况 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长； 日志写满，更新全部堵住，写性能跌为 0 InnoDB 刷脏页的控制策略 innodb_io_capacity 建议设置成磁盘的 IOPS 通过 fio 工具测试 IOPS fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest InnoDB 刷盘速度主要参考两个因素 脏页比例 - innodb_max_dirty_pages_pct 脏页比例，默认值 75% - 平时多关注脏页比例，不要让它经常接近 75% - 脏页比例通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到，具体的命令参考下面的代码 mysql&amp;gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b; - InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样 伪代码 F1(M){ if M&amp;gt;=innodb_max_dirty_pages_pct then return 100; return 100*M/innodb_max_dirty_pages_pct;} redo log 写盘速度 - InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。 - 根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。 - 在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。 使用 SSD 这类 IOPS 比较高的设备时，建议设为 0 MySQL 8.</description></item><item><title>11｜怎么给字符串字段加索引？</title><link>https://wangze.tech/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</link><pubDate>Wed, 17 May 2023 15:19:11 +0800</pubDate><guid>https://wangze.tech/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</guid><description> 直接创建完整索引，比较占用空间； 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引； 在索引上找到数据后需要回到主键上拿到完整数据进行判断 即使前缀完全覆盖了字段内容也会回表，因为不确定是不是真的完整数据 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题，不支持范围扫描； index index_name(email(6)); 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，需要多一个字段保存 hash 字段，不支持范围扫描。 比如通过 crc32() 函数得到 hash 值</description></item><item><title>10｜MySQL 为什么有时候会选错索引？</title><link>https://wangze.tech/10MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</link><pubDate>Wed, 17 May 2023 15:18:30 +0800</pubDate><guid>https://wangze.tech/10MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</guid><description>优化器的逻辑 扫描行数 一个索引上不同的值越多，这个索引的区分度越好 基数（cardinality）：一个索引上不同的值的个数。 采样统计：InnoDB 默认选择索引的 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面树，就得到这个索引的基数。 当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。 两种存储索引统计的方式，通过设置参数 innodb_stats_persistent 的值选择 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。 从普通索引拿到一个值后，回到主键索引查出整行数据的代价也要算。 由于索引统计信息不准确导致的问题，用 analyze table 命令来解决。 是否使用临时表 是否排序 解决其他优化器误判的情况 可以在应用端用 force index 来强行指定索引； 也可以通过修改语句来引导优化器； 如，当 xxx order by b limit 1; 最终选择 b 索引而不是 a 索引，可能是因为判断使用 b 就可以不用再排序，此时将语句改成 xxx order by b, a limit 1; 是一个可考虑的解决方法 前提是 SQL 语句语义不变 还可以增加或者删除索引绕过问题 思考题 前面我们在构造第一个例子的过程中，通过 session A 的配合，让 session B 删除数据后又重新插入了一遍数据，然后就发现 explain 结果中，rows 字段从 10001 变成 37000 多。而如果没有 session A 的配合，只是单独执行 delete from t、call idata()、explain 这三句话，会看到 rows 字段其实还是 10000 左右。你可以自己验证一下这个结果。 这是什么原因呢？也请你分析一下吧。 session A 还没有提交，所以之前插入的 10 万行数据还不能删除。 所以之前的数据每一行都有两个版本，旧版本是 delete 之前的数据，新版本是标记为 deleted 的数据。 因为这个是主键，主键是直接按照表的行数来估计的，而表的行数，优化器直接用的是 show table status 的值（后面有章节详细讲解）。</description></item><item><title>09｜普通索引和唯一索引，应该怎么选择？</title><link>https://wangze.tech/09%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</link><pubDate>Wed, 17 May 2023 15:15:56 +0800</pubDate><guid>https://wangze.tech/09%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</guid><description>查询性能 「where = 」时，唯一索引找到了立马返回，普通索引需要找到下一个不等于的值 因为 InnoDB 的数据是按数据页为单位读写，所以性能差距微乎其微 对于整形字段，一个 16KB 的数据页可以放近千个 key Change Buffer 当需要更新一个数据页时，如果数据页在内存中就直接更新 如果数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中 下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行第 2 步缓存在 change buffer 中与这个页有关的操作 这个过程称为 merge</description></item><item><title>08｜事务到底是隔离的还是不隔离的？</title><link>https://wangze.tech/08%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</link><pubDate>Wed, 17 May 2023 14:45:12 +0800</pubDate><guid>https://wangze.tech/08%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</guid><description>事务的启动时机 begin/start transaction 命令之后的第一个操作 InnoDB 表的语句，事务才真正启动。 马上启动一个事务：start transaction with consistent snapshot。 事务自动提交设置，默认为 1，即除非显示声明一个事务的开始，否则每一个查询都会被当做独立的事务被处理。 整个专栏，如果没有特别说明，都默认 autocommit = 1。 MySQL 里的两个“视图”的概念 一个是 view。是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是 create view …，查询方法和表一样。 另一个是 InnoDB 在实现 MVCC（多版本并发控制） 时用到的一致性读视图（consistent read view），用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。 视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据” “快照”在 MVCC 里是怎么工作的？ 秒级创建快照的能力，快照是基于整库的。 InnoDB 的行数据有多个版本（row），每个版本有自己的 row trx_id（严格递增）。 图中的虚线就是 undo log。 在实现上，InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。 活跃：启动了但还没提交。 数组里事务 ID 的最小值记为低水位。 当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。 数据版本的可见性规则：基于数据的 row trx_id 和一致性视图的对比结果得到的。 绿色：表示这个版本是已提交的事务或者是当前事务自己生成的，可见。 红色：表示是由将来启动的事务生成的，不可见。 黄色 a）若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b）若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。 翻译：对于一个事务视图，除了自己的更新总是可见以外，有三种情况 版本未提交，不可见； 版本已提交，但是是在视图创建后提交的，不可见； 版本已提交，而且是在视图创建前提交的，可见。 每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 对于读提交，查询只承认在语句启动前就已经提交完成的数据； 更新逻辑 更新数据都是先读后写。 当前读：总是读取已经提交完成的最新版本。 除了 update 语句，select 语句如果加锁，也是当前读。 加上 lock in share mode 或 for update。 事务的可重复读是怎么实现的？ 可重复读的核心是一致性读；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。 读提交的逻辑和可重复读的逻辑类似，最主要的区别： 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图； 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的事务。 为什么表结构不支持“可重复读”？ 因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。 MySQL 8.</description></item><item><title>07｜行锁功过：怎么减少锁对性能的影响？</title><link>https://wangze.tech/07%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</link><pubDate>Wed, 17 May 2023 14:43:52 +0800</pubDate><guid>https://wangze.tech/07%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</guid><description> MyISAM 不支持行锁 InnoDB 的行锁 两阶段锁协议：事务中，行锁在需要的时候才加上，但要等到事务结束时释放。 如果你的事务中需要锁多个行，要把最可能造成锁冲突、影响并发度的锁尽量往后放。 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。 两种策略 直接进入等待，直到超时。 超时时间可以通过 innodb_lock_wait_timeout 设置 默认 50s。 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。 死锁：每当一个事务被锁，就要看看它所依赖的线程有没有被别的锁住，如此循环，最后判断是否出现连循环等待。 假设现在已经有 999 个线程在同一行等锁，新来一个请求也要访问这个行，他要判断有没有死锁要判断 1000 次。然后这个结果乘以 1000。 正常情况下采用第二种策略，默认也是第二种。 怎么解决热点行更新导致的性能问题？ 问题的症结：死锁检测要耗费大量的 CPU 资源。 确保业务一定不会出现死锁，关闭死锁检测（不推荐） 控制并发度。 在中间件或修改 MySQL 源码实现：对于相同行的更新，在进入引擎之前排队，这样 InnoDB 就不会有大量的死锁检测工作。 如果做不到第 1 点，可以考虑从设计上优化 考虑通过将一行改成逻辑上的多行来减少锁冲突。 以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。 思考题 如果要删除一个表里面的前 1w 行数据，选择哪一种方法（选 2） 直接执行 delete from T limit 10000; 单个语句占用时间长，锁的时间也比较长； 大事务会导致主从延迟。 在一个连接中循环执行 20 次 delete from T limit 500; 在 20 个连接中同时执行 delete from T limit 500; 人为造成锁冲突。 评论区 关于思考题 第二种方法难道不会引起数据一致性问题吗？如果在 InnoDB 中开启了自动事务并且没有显式用 begin, commit 来做的话，在上一次循环结束和下一次循环开始之间如果有其他事务插入了新数据，而且正好位置也在前面 500条，那不就不一致了么 加个 order by id（假设 id 是表的主键） 排序后新增的 id 肯定大于要删除的最大 id 如果有多种锁，必须全部不互斥才能并行。 MySQL 没有嵌套事务，开启下一个会自动提交上一个</description></item><item><title>06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？</title><link>https://wangze.tech/06%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</link><pubDate>Wed, 17 May 2023 14:40:34 +0800</pubDate><guid>https://wangze.tech/06%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</guid><description>全局锁 典型使用场景：做全库逻辑备份。 使用 MySQL 提供的加全局读锁的方法 Flush tables with read lock（FTWRL） 整个库进入只读状态 执行 FTWRL 命令之后由于客户端发生异常断开，MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。 推荐：在可重复读隔离级别下开启一个事务 备份期间可以正常读写数据库 需要所有的表的引擎都支持（全库备份） mysqldump 备份工具使用 -single-transaction 参数，就会开启一个事务，确保拿到一致性视图 ⚠️ 为什么不使用 set global readonly=true？建议用 FTWRL 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。 将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。 readonly 对 super 权限的用户无效 表级锁 表锁 语法：lock tables … read/write unlock tables 主动释放锁，或者客户端断开时自动释放 除了会限制别的线程的读写，也会限定本线程自己接下来的操作对象 不推荐使用，若引擎不支持事务，安排升级换引擎。 升级后把使用 lock/unlock tables 语法的地方换成 begin 和 commit。 元数据锁 MDL（metadata lock） 不需要显式使用，在访问一个表的时候会被自动加上 MySQL 5.</description></item><item><title>05｜深入浅出索引（下）</title><link>https://wangze.tech/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8B/</link><pubDate>Wed, 17 May 2023 10:13:29 +0800</pubDate><guid>https://wangze.tech/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8B/</guid><description>如何安排联合索引内的字段顺序 第一原则：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。 如果既有联合查询，又有基于 a、b 各自的查询，此时要考虑空间 比如 a 比 b 大，就建 (a, b) + 单 b 还有其他情况，需要结合业务分析 查询语句的 where 里面各个判断调换顺序不影响 覆盖索引 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果 要全用上必须是条件 =，不能是 &amp;gt; 或 &amp;lt; 在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？ 如果有一个高频请求是根据身份证号查询姓名，就有必要 前缀索引 最左前缀原则 可以是联合索引的最左 N 个字段 也可以是字符串索引的最左 M 个字符 索引下推 MySQL 5.</description></item><item><title>04｜深入浅出索引（上）</title><link>https://wangze.tech/04%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8A/</link><pubDate>Wed, 17 May 2023 10:09:25 +0800</pubDate><guid>https://wangze.tech/04%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%E4%B8%8A/</guid><description>每遇到一个新数据库，先关注它的数据模型，分析数据库的适用场景 数据库底层存储的核心基于的数据模型：哈希表、有序数组、二叉树、N 叉树等 InnoDB 的索引模型 每一个索引在 InnoDB 里面对应一颗 B+ 树 主键索引也被称为聚簇索引（clustered index） 叶子节点内容是整行数据 主键查询只需要搜索主键这颗 B+ 树 整张表的数据存在主键索引中，这就是“聚簇索引”的意思 非主键索引也被称为二级索引（secondary index） 叶子节点内容是主键的值 如果主键索引是多个列，二级索引里包含的主键也是多列 回表：普通索引查询，先拿到主键，再到主键索引树搜索一次 叶子节点是 page（数据页），一个页里面可以存多个行 页大小 16k，则行个数 = 16k/行大小 索引维护 页分裂 新增加一个数据页，挪动部分数据过去，空间利用率降低大概 50% 不挪动数据的新增数据页操作不叫页分裂 当相邻的两个数据页利用率很低的时候会做数据页合并 主键 建议使用自增主键 建议设置 bigint unsigned 使用业务主键的场景（典型的 KV 场景） 只有一个索引 该索引必须是唯一索引 没有主键的表，InnoDB 会默认创建一个 RowId 做主键 ⚠️ 加主键会重建表 索引只能定位到 page，page 内部是个有序数组，用二分法 数据页中有页目录，页目录的 key 为 id ，value 为槽位 二分搜索页目录定位到槽位中的行记录 内存数据页和磁盘数据页是一一对应的，持久化的时候直接覆盖写进去 叶子节点中的数据连接方式 叶子内是单向链表 叶子间是双向链表 什么时候需要重建索引 索引可能因为删除操作、页分裂等原因，导致数据页有空洞 即空间未释放 重建索引的过程会创建一个新的索引，把数据按顺序插入，页面的利用率最高，更省空间 思考题 重建普通 k 索引 alter table T drop index k; alter table T add index(k); 重建主键索引 alter table T drop primary key; alter table T add primary key(id); 对于上面这两个重建索引的做法，说出你的理解。 重建索引 k 的做法合理，可以达到省空间的目的 重建主键的过程不合理 为什么不合适？ 删除或创建主键都会将整个表重建，导致第一个语句白做 更好的方法 使用 alter table T engine=InnoDB 代替 触发 MySQL 重建该表，并进行碎片处理 5.</description></item><item><title>02｜日志系统：一条 SQL 更新语句是如何执行的？</title><link>https://wangze.tech/02%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1-SQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 09:52:27 +0800</pubDate><guid>https://wangze.tech/02%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1-SQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>Update 语句执行流程 重要的日志模块：redo Log 是 InnoDB 引擎特有的日志 WAL（Write-Ahead Logging）技术 先写日志，再写磁盘 当有一条记录需要更新的时候，InnoDB 引擎先把记录写到 redo log，并更新内存，引擎会在适当的时候，将这个操作记录更新到磁盘，这个更新往往是在系统比较空闲的时候做 redo log 大小固定，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，所有文件组成一块“粉板” write pos 是当前记录的位置，一边写一边后移，写到文件末尾后会回到文件开头 checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。 如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 crash-safe：有了 redo log，InnoDB 可以保证数据库发生异常重启也不丢失数据 重要的日志模块：binlog（归档日志） 是 Server 层的日志 statement 格式：记 SQL 语句 row 格式：记录行的内容，记两条，更新前和更新后都有 建议使用 Redo Log 和 Binlog 的不同 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 逻辑：其他引擎都能用，都讲得通这个“逻辑” 物理：只有“我“能用，别人没有共享我的”物理格式“ redo log 是循环写，空间固定会用完；binlog 是追加写入。 “追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 两阶段提交 提交流程 redolog 的 prepare 阶段 写 binlog redolog 的 commit 在 2 之前崩溃时，重启恢复后发现没有 commit，回滚；备份恢复，没有 binlog。一致 在 3 之前崩溃，重启恢复后发现虽然没有 commit，但满足 prepare 和 binlog 完整，自动 commit；备份恢复，有 binlog。一致 设置建议 innodb_flush_log_at_trx_commit 建议设置成 1，表示每次事务的 redo log 都直接持久化到磁盘，保证 MySQL 异常重启之后数据不丢失 sync_binlog 建议设置成 1，表示每次事务的 binlog 都持久化到磁盘，保证 MySQL 异常重启之后 binlog 不丢失 答疑文章（一） MySQL 怎么知道 Binlog 是完整的？ 一个事务的 binlog 有完整格式： statement 格式的 binlog，最后会有 COMMIT； row 格式的 binlog，最后会有一个 XID event。 MySQL 5.</description></item><item><title>03｜事务隔离：为什么你改了为还看不见？</title><link>https://wangze.tech/03%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E4%B8%BA%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</link><pubDate>Wed, 17 May 2023 09:40:20 +0800</pubDate><guid>https://wangze.tech/03%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E4%B8%BA%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</guid><description>隔离型与隔离级别 读未提交 read uncommitted 一个事务还没提交时，它做的变更就能被别的事务看到。 读提交 read committed 一个事务提交之后，它做的变更才会被其他事务看到。 可重复读 repeatable read 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化 serializable 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 事务隔离的实现 以可重复读为例 每条记录在更新的时候会同时记录一条回滚操作 记录上的最新值，通过回滚操作，都可以得到前一个状态的值 系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志才会被删除 如事务提交之前都可能用到 ⚠️ 不要使用长事务 MySQL 5.</description></item><item><title>01｜基础架构：一条 SQL 查询语句是如何执行的？</title><link>https://wangze.tech/01%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Wed, 17 May 2023 09:36:32 +0800</pubDate><guid>https://wangze.tech/01%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>MySQL 的逻辑链接架构图 1. 客户端连接数据库 wait_timeout 参数控制连接器长时间没操作自动断开的时间 只有新建的连接才会使用新的权限设置 尽量使用长连接 使用长连接的问题：可能内存疯涨，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面，在连接断开的时候才释放 两个解决方案 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，主动断开连接，之后要查询再重连 MySQL 5.7 或更新版本，可以在执行一个比较大的操作后，执行 mysql_reset_connection 重新初始化连接资源 这个过程不需要重连和重新做权限验证，会将连接恢复到刚刚创建完时的状态 2.</description></item><item><title>MySQL 实战 45 讲</title><link>https://wangze.tech/MySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/</link><pubDate>Wed, 17 May 2023 09:23:16 +0800</pubDate><guid>https://wangze.tech/MySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/</guid><description> 内容整理自极客时间 《MySQL 实战 45 讲》
章节分类 分类名 章节 基础知识 01 索引 04、05、09、10、11、15、16、18 事务 03、08、20 锁 06、07、13、19、20、21、30、40 日志与主备 02、12、23、24、25、26、27、28、29、31 临时表 17、34、35、36、37、43 实用性 14、32、33、38、41、44、45 基础篇 [[01｜基础架构：一条 SQL 查询语句是如何执行的？]] [[02｜日志系统：一条 SQL 更新语句是如何执行的？]] [[03｜事务隔离：为什么你改了为还看不见？]] [[04｜深入浅出索引（上）]] [[05｜深入浅出索引（下）]] [[06｜全局锁和表锁：给表加个字段怎么有这么多阻碍？]] [[07｜行锁功过：怎么减少锁对性能的影响？]] [[08｜事务到底是隔离的还是不隔离的？]] 实践篇 [[09｜普通索引和唯一索引，应该怎么选择？]] [[10｜MySQL 为什么有时候会选错索引？]] [[11｜怎么给字符串字段加索引？]] [[12｜为什么我的 MySQL 会“抖”一下？]] [[13｜为什么表数据删掉一半，表文件大小不变？]] [[14｜count(*) 这么慢，我该怎么办？]] [[15｜答疑文章（一）：日志和索引相关问题]] [[16｜“order by”是怎么工作的？]] [[17｜如何正确地显示随机消息？]] [[18｜为什么这些 SQL 语句逻辑相同，性能却差异巨大？]] [[19｜为什么我只查一行的语句，也执行这么慢？]] [[20｜幻读是什么，幻读有什么问题？]] [[21｜为什么我只改一行的语句，锁这么多？]] [[22｜MySQL有哪些“饮鸩止渴”提高性能的方法？]] [[23｜MySQL 是怎么保证数据不丢的？]] [[24｜MySQL 是怎么保证主备一致的？]] [[25｜MySQL 是怎么保证高可用的？]] [[26｜备库为什么会延迟好几个小时？]] [[27｜主库出问题了，从库怎么办？]] [[28｜读写分离有哪些坑？]] [[29｜如何判断一个数据库是不是出问题了？]] [[30｜答疑文章（二）：用动态的观点看加锁]] [[31｜误删数据后除了跑路，还能怎么办？]] [[32｜为什么还有 kill 不掉的语句？]] [[33｜我查这么多数据，会不会把数据库内存打爆？]] [[34｜到底可不可以使用 join ？]] [[35｜join 语句怎么优化？]] [[36｜为什么临时表可以重名？]] [[37｜什么时候会使用内部临时表？]] [[38｜都说 InnoDB 好，那还要不要使用 Memory 引擎？]] [[39｜自增主键为什么不是连续的？]] [[40｜insert 语句的锁为什么这么多？]] [[41｜怎么最快地复制一张表？]] [[42｜grant 之后要跟着 flush privileges 吗？]] [[43｜要不要使用分区表？]] [[44｜答疑文章（三）：说一说这些好问题]] [[45｜自增 id 用完怎么办？]]</description></item></channel></rss>